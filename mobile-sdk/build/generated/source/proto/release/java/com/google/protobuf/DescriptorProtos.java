// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/protobuf/descriptor.proto

package com.google.protobuf;

public final class DescriptorProtos {
  private DescriptorProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface FileDescriptorSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.FileDescriptorSet)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FileDescriptorProto> 
        getFileList();
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    com.google.protobuf.DescriptorProtos.FileDescriptorProto getFile(int index);
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    int getFileCount();
  }
  /**
   * <pre>
   * The protocol compiler can output a FileDescriptorSet containing the .proto
   * files it parses.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.FileDescriptorSet}
   */
  public  static final class FileDescriptorSet extends
      com.google.protobuf.GeneratedMessageLite<
          FileDescriptorSet, FileDescriptorSet.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FileDescriptorSet)
      FileDescriptorSetOrBuilder {
    private FileDescriptorSet() {
      file_ = emptyProtobufList();
    }
    public static final int FILE_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FileDescriptorProto> file_;
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FileDescriptorProto> getFileList() {
      return file_;
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.FileDescriptorProtoOrBuilder> 
        getFileOrBuilderList() {
      return file_;
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    @java.lang.Override
    public int getFileCount() {
      return file_.size();
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FileDescriptorProto getFile(int index) {
      return file_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    public com.google.protobuf.DescriptorProtos.FileDescriptorProtoOrBuilder getFileOrBuilder(
        int index) {
      return file_.get(index);
    }
    private void ensureFileIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FileDescriptorProto> tmp = file_;
      if (!tmp.isModifiable()) {
        file_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void setFile(
        int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
      value.getClass();
  ensureFileIsMutable();
      file_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void addFile(com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
      value.getClass();
  ensureFileIsMutable();
      file_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void addFile(
        int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
      value.getClass();
  ensureFileIsMutable();
      file_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void addAllFile(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FileDescriptorProto> values) {
      ensureFileIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, file_);
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void clearFile() {
      file_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
     */
    private void removeFile(int index) {
      ensureFileIsMutable();
      file_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FileDescriptorSet prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * The protocol compiler can output a FileDescriptorSet containing the .proto
     * files it parses.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.FileDescriptorSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.FileDescriptorSet, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FileDescriptorSet)
        com.google.protobuf.DescriptorProtos.FileDescriptorSetOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FileDescriptorSet.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FileDescriptorProto> getFileList() {
        return java.util.Collections.unmodifiableList(
            instance.getFileList());
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      @java.lang.Override
      public int getFileCount() {
        return instance.getFileCount();
      }/**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FileDescriptorProto getFile(int index) {
        return instance.getFile(index);
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder setFile(
          int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
        copyOnWrite();
        instance.setFile(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder setFile(
          int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setFile(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder addFile(com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
        copyOnWrite();
        instance.addFile(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder addFile(
          int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto value) {
        copyOnWrite();
        instance.addFile(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder addFile(
          com.google.protobuf.DescriptorProtos.FileDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addFile(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder addFile(
          int index, com.google.protobuf.DescriptorProtos.FileDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addFile(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder addAllFile(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FileDescriptorProto> values) {
        copyOnWrite();
        instance.addAllFile(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder clearFile() {
        copyOnWrite();
        instance.clearFile();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FileDescriptorProto file = 1;</code>
       */
      public Builder removeFile(int index) {
        copyOnWrite();
        instance.removeFile(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FileDescriptorSet)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FileDescriptorSet();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "file_",
              com.google.protobuf.DescriptorProtos.FileDescriptorProto.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0001\u0001\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FileDescriptorSet> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FileDescriptorSet.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FileDescriptorSet>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FileDescriptorSet)
    private static final com.google.protobuf.DescriptorProtos.FileDescriptorSet DEFAULT_INSTANCE;
    static {
      FileDescriptorSet defaultInstance = new FileDescriptorSet();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FileDescriptorSet.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FileDescriptorSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FileDescriptorSet> PARSER;

    public static com.google.protobuf.Parser<FileDescriptorSet> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FileDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.FileDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return Whether the package field is set.
     */
    boolean hasPackage();
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return The package.
     */
    java.lang.String getPackage();
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return The bytes for package.
     */
    com.google.protobuf.ByteString
        getPackageBytes();

    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @return A list containing the dependency.
     */
    java.util.List<java.lang.String>
        getDependencyList();
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @return The count of dependency.
     */
    int getDependencyCount();
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param index The index of the element to return.
     * @return The dependency at the given index.
     */
    java.lang.String getDependency(int index);
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param index The index of the element to return.
     * @return The dependency at the given index.
     */
    com.google.protobuf.ByteString
        getDependencyBytes(int index);

    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @return A list containing the publicDependency.
     */
    java.util.List<java.lang.Integer> getPublicDependencyList();
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @return The count of publicDependency.
     */
    int getPublicDependencyCount();
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @param index The index of the element to return.
     * @return The publicDependency at the given index.
     */
    int getPublicDependency(int index);

    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @return A list containing the weakDependency.
     */
    java.util.List<java.lang.Integer> getWeakDependencyList();
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @return The count of weakDependency.
     */
    int getWeakDependencyCount();
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @param index The index of the element to return.
     * @return The weakDependency at the given index.
     */
    int getWeakDependency(int index);

    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> 
        getMessageTypeList();
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    com.google.protobuf.DescriptorProtos.DescriptorProto getMessageType(int index);
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    int getMessageTypeCount();

    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> 
        getEnumTypeList();
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index);
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    int getEnumTypeCount();

    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> 
        getServiceList();
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    com.google.protobuf.DescriptorProtos.ServiceDescriptorProto getService(int index);
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    int getServiceCount();

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> 
        getExtensionList();
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index);
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    int getExtensionCount();

    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.FileOptions getOptions();

    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     * @return Whether the sourceCodeInfo field is set.
     */
    boolean hasSourceCodeInfo();
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     * @return The sourceCodeInfo.
     */
    com.google.protobuf.DescriptorProtos.SourceCodeInfo getSourceCodeInfo();

    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return Whether the syntax field is set.
     */
    boolean hasSyntax();
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return The syntax.
     */
    java.lang.String getSyntax();
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return The bytes for syntax.
     */
    com.google.protobuf.ByteString
        getSyntaxBytes();

    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return Whether the edition field is set.
     */
    boolean hasEdition();
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return The edition.
     */
    java.lang.String getEdition();
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return The bytes for edition.
     */
    com.google.protobuf.ByteString
        getEditionBytes();
  }
  /**
   * <pre>
   * Describes a complete .proto file.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.FileDescriptorProto}
   */
  public  static final class FileDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          FileDescriptorProto, FileDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FileDescriptorProto)
      FileDescriptorProtoOrBuilder {
    private FileDescriptorProto() {
      name_ = "";
      package_ = "";
      dependency_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      publicDependency_ = emptyIntList();
      weakDependency_ = emptyIntList();
      messageType_ = emptyProtobufList();
      enumType_ = emptyProtobufList();
      service_ = emptyProtobufList();
      extension_ = emptyProtobufList();
      syntax_ = "";
      edition_ = "";
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <pre>
     * file name, relative to root of source tree
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int PACKAGE_FIELD_NUMBER = 2;
    private java.lang.String package_;
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return Whether the package field is set.
     */
    @java.lang.Override
    public boolean hasPackage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return The package.
     */
    @java.lang.Override
    public java.lang.String getPackage() {
      return package_;
    }
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @return The bytes for package.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPackageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(package_);
    }
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @param value The package to set.
     */
    private void setPackage(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      package_ = value;
    }
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     */
    private void clearPackage() {
      bitField0_ = (bitField0_ & ~0x00000002);
      package_ = getDefaultInstance().getPackage();
    }
    /**
     * <pre>
     * e.g. "foo", "foo.bar", etc.
     * </pre>
     *
     * <code>optional string package = 2;</code>
     * @param value The bytes for package to set.
     */
    private void setPackageBytes(
        com.google.protobuf.ByteString value) {
      package_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int DEPENDENCY_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> dependency_;
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @return A list containing the dependency.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getDependencyList() {
      return dependency_;
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @return The count of dependency.
     */
    @java.lang.Override
    public int getDependencyCount() {
      return dependency_.size();
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param index The index of the element to return.
     * @return The dependency at the given index.
     */
    @java.lang.Override
    public java.lang.String getDependency(int index) {
      return dependency_.get(index);
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the dependency at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDependencyBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          dependency_.get(index));
    }
    private void ensureDependencyIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          dependency_;  if (!tmp.isModifiable()) {
        dependency_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param index The index to set the value at.
     * @param value The dependency to set.
     */
    private void setDependency(
        int index, java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureDependencyIsMutable();
      dependency_.set(index, value);
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param value The dependency to add.
     */
    private void addDependency(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureDependencyIsMutable();
      dependency_.add(value);
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param values The dependency to add.
     */
    private void addAllDependency(
        java.lang.Iterable<java.lang.String> values) {
      ensureDependencyIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, dependency_);
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     */
    private void clearDependency() {
      dependency_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Names of files imported by this file.
     * </pre>
     *
     * <code>repeated string dependency = 3;</code>
     * @param value The bytes of the dependency to add.
     */
    private void addDependencyBytes(
        com.google.protobuf.ByteString value) {
      ensureDependencyIsMutable();
      dependency_.add(value.toStringUtf8());
    }

    public static final int PUBLIC_DEPENDENCY_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.IntList publicDependency_;
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @return A list containing the publicDependency.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getPublicDependencyList() {
      return publicDependency_;
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @return The count of publicDependency.
     */
    @java.lang.Override
    public int getPublicDependencyCount() {
      return publicDependency_.size();
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @param index The index of the element to return.
     * @return The publicDependency at the given index.
     */
    @java.lang.Override
    public int getPublicDependency(int index) {
      return publicDependency_.getInt(index);
    }
    private void ensurePublicDependencyIsMutable() {
      com.google.protobuf.Internal.IntList tmp = publicDependency_;
      if (!tmp.isModifiable()) {
        publicDependency_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @param index The index to set the value at.
     * @param value The publicDependency to set.
     */
    private void setPublicDependency(
        int index, int value) {
      ensurePublicDependencyIsMutable();
      publicDependency_.setInt(index, value);
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @param value The publicDependency to add.
     */
    private void addPublicDependency(int value) {
      ensurePublicDependencyIsMutable();
      publicDependency_.addInt(value);
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     * @param values The publicDependency to add.
     */
    private void addAllPublicDependency(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensurePublicDependencyIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, publicDependency_);
    }
    /**
     * <pre>
     * Indexes of the public imported files in the dependency list above.
     * </pre>
     *
     * <code>repeated int32 public_dependency = 10;</code>
     */
    private void clearPublicDependency() {
      publicDependency_ = emptyIntList();
    }

    public static final int WEAK_DEPENDENCY_FIELD_NUMBER = 11;
    private com.google.protobuf.Internal.IntList weakDependency_;
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @return A list containing the weakDependency.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getWeakDependencyList() {
      return weakDependency_;
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @return The count of weakDependency.
     */
    @java.lang.Override
    public int getWeakDependencyCount() {
      return weakDependency_.size();
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @param index The index of the element to return.
     * @return The weakDependency at the given index.
     */
    @java.lang.Override
    public int getWeakDependency(int index) {
      return weakDependency_.getInt(index);
    }
    private void ensureWeakDependencyIsMutable() {
      com.google.protobuf.Internal.IntList tmp = weakDependency_;
      if (!tmp.isModifiable()) {
        weakDependency_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @param index The index to set the value at.
     * @param value The weakDependency to set.
     */
    private void setWeakDependency(
        int index, int value) {
      ensureWeakDependencyIsMutable();
      weakDependency_.setInt(index, value);
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @param value The weakDependency to add.
     */
    private void addWeakDependency(int value) {
      ensureWeakDependencyIsMutable();
      weakDependency_.addInt(value);
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     * @param values The weakDependency to add.
     */
    private void addAllWeakDependency(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureWeakDependencyIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, weakDependency_);
    }
    /**
     * <pre>
     * Indexes of the weak imported files in the dependency list.
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>repeated int32 weak_dependency = 11;</code>
     */
    private void clearWeakDependency() {
      weakDependency_ = emptyIntList();
    }

    public static final int MESSAGE_TYPE_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto> messageType_;
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> getMessageTypeList() {
      return messageType_;
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.DescriptorProtoOrBuilder> 
        getMessageTypeOrBuilderList() {
      return messageType_;
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    @java.lang.Override
    public int getMessageTypeCount() {
      return messageType_.size();
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.DescriptorProto getMessageType(int index) {
      return messageType_.get(index);
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    public com.google.protobuf.DescriptorProtos.DescriptorProtoOrBuilder getMessageTypeOrBuilder(
        int index) {
      return messageType_.get(index);
    }
    private void ensureMessageTypeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto> tmp = messageType_;
      if (!tmp.isModifiable()) {
        messageType_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void setMessageType(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureMessageTypeIsMutable();
      messageType_.set(index, value);
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void addMessageType(com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureMessageTypeIsMutable();
      messageType_.add(value);
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void addMessageType(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureMessageTypeIsMutable();
      messageType_.add(index, value);
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void addAllMessageType(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto> values) {
      ensureMessageTypeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, messageType_);
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void clearMessageType() {
      messageType_ = emptyProtobufList();
    }
    /**
     * <pre>
     * All top-level definitions in this file.
     * </pre>
     *
     * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
     */
    private void removeMessageType(int index) {
      ensureMessageTypeIsMutable();
      messageType_.remove(index);
    }

    public static final int ENUM_TYPE_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> enumType_;
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> getEnumTypeList() {
      return enumType_;
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProtoOrBuilder> 
        getEnumTypeOrBuilderList() {
      return enumType_;
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    @java.lang.Override
    public int getEnumTypeCount() {
      return enumType_.size();
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index) {
      return enumType_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProtoOrBuilder getEnumTypeOrBuilder(
        int index) {
      return enumType_.get(index);
    }
    private void ensureEnumTypeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> tmp = enumType_;
      if (!tmp.isModifiable()) {
        enumType_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void setEnumType(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void addEnumType(com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void addEnumType(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void addAllEnumType(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto> values) {
      ensureEnumTypeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, enumType_);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void clearEnumType() {
      enumType_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
     */
    private void removeEnumType(int index) {
      ensureEnumTypeIsMutable();
      enumType_.remove(index);
    }

    public static final int SERVICE_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> service_;
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> getServiceList() {
      return service_;
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.ServiceDescriptorProtoOrBuilder> 
        getServiceOrBuilderList() {
      return service_;
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    @java.lang.Override
    public int getServiceCount() {
      return service_.size();
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.ServiceDescriptorProto getService(int index) {
      return service_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    public com.google.protobuf.DescriptorProtos.ServiceDescriptorProtoOrBuilder getServiceOrBuilder(
        int index) {
      return service_.get(index);
    }
    private void ensureServiceIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> tmp = service_;
      if (!tmp.isModifiable()) {
        service_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void setService(
        int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
      value.getClass();
  ensureServiceIsMutable();
      service_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void addService(com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
      value.getClass();
  ensureServiceIsMutable();
      service_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void addService(
        int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
      value.getClass();
  ensureServiceIsMutable();
      service_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void addAllService(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> values) {
      ensureServiceIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, service_);
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void clearService() {
      service_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
     */
    private void removeService(int index) {
      ensureServiceIsMutable();
      service_.remove(index);
    }

    public static final int EXTENSION_FIELD_NUMBER = 7;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> extension_;
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getExtensionList() {
      return extension_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder> 
        getExtensionOrBuilderList() {
      return extension_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    @java.lang.Override
    public int getExtensionCount() {
      return extension_.size();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index) {
      return extension_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder getExtensionOrBuilder(
        int index) {
      return extension_.get(index);
    }
    private void ensureExtensionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> tmp = extension_;
      if (!tmp.isModifiable()) {
        extension_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void setExtension(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void addExtension(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void addExtension(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void addAllExtension(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
      ensureExtensionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, extension_);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void clearExtension() {
      extension_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
     */
    private void removeExtension(int index) {
      ensureExtensionIsMutable();
      extension_.remove(index);
    }

    public static final int OPTIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.DescriptorProtos.FileOptions options_;
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FileOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.FileOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.FileOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.FileOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.FileOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.FileOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .google.protobuf.FileOptions options = 8;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int SOURCE_CODE_INFO_FIELD_NUMBER = 9;
    private com.google.protobuf.DescriptorProtos.SourceCodeInfo sourceCodeInfo_;
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     */
    @java.lang.Override
    public boolean hasSourceCodeInfo() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.SourceCodeInfo getSourceCodeInfo() {
      return sourceCodeInfo_ == null ? com.google.protobuf.DescriptorProtos.SourceCodeInfo.getDefaultInstance() : sourceCodeInfo_;
    }
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     */
    private void setSourceCodeInfo(com.google.protobuf.DescriptorProtos.SourceCodeInfo value) {
      value.getClass();
  sourceCodeInfo_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeSourceCodeInfo(com.google.protobuf.DescriptorProtos.SourceCodeInfo value) {
      value.getClass();
  if (sourceCodeInfo_ != null &&
          sourceCodeInfo_ != com.google.protobuf.DescriptorProtos.SourceCodeInfo.getDefaultInstance()) {
        sourceCodeInfo_ =
          com.google.protobuf.DescriptorProtos.SourceCodeInfo.newBuilder(sourceCodeInfo_).mergeFrom(value).buildPartial();
      } else {
        sourceCodeInfo_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * This field contains optional information about the original source code.
     * You may safely remove this entire field without harming runtime
     * functionality of the descriptors -- the information is needed only by
     * development tools.
     * </pre>
     *
     * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
     */
    private void clearSourceCodeInfo() {  sourceCodeInfo_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int SYNTAX_FIELD_NUMBER = 12;
    private java.lang.String syntax_;
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return Whether the syntax field is set.
     */
    @java.lang.Override
    public boolean hasSyntax() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return The syntax.
     */
    @java.lang.Override
    public java.lang.String getSyntax() {
      return syntax_;
    }
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @return The bytes for syntax.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSyntaxBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(syntax_);
    }
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @param value The syntax to set.
     */
    private void setSyntax(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      syntax_ = value;
    }
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     */
    private void clearSyntax() {
      bitField0_ = (bitField0_ & ~0x00000010);
      syntax_ = getDefaultInstance().getSyntax();
    }
    /**
     * <pre>
     * The syntax of the proto file.
     * The supported values are "proto2", "proto3", and "editions".
     * If `edition` is present, this value must be "editions".
     * </pre>
     *
     * <code>optional string syntax = 12;</code>
     * @param value The bytes for syntax to set.
     */
    private void setSyntaxBytes(
        com.google.protobuf.ByteString value) {
      syntax_ = value.toStringUtf8();
      bitField0_ |= 0x00000010;
    }

    public static final int EDITION_FIELD_NUMBER = 13;
    private java.lang.String edition_;
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return Whether the edition field is set.
     */
    @java.lang.Override
    public boolean hasEdition() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return The edition.
     */
    @java.lang.Override
    public java.lang.String getEdition() {
      return edition_;
    }
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @return The bytes for edition.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEditionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(edition_);
    }
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @param value The edition to set.
     */
    private void setEdition(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000020;
      edition_ = value;
    }
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     */
    private void clearEdition() {
      bitField0_ = (bitField0_ & ~0x00000020);
      edition_ = getDefaultInstance().getEdition();
    }
    /**
     * <pre>
     * The edition of the proto file, which is an opaque string.
     * </pre>
     *
     * <code>optional string edition = 13;</code>
     * @param value The bytes for edition to set.
     */
    private void setEditionBytes(
        com.google.protobuf.ByteString value) {
      edition_ = value.toStringUtf8();
      bitField0_ |= 0x00000020;
    }

    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FileDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a complete .proto file.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.FileDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.FileDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FileDescriptorProto)
        com.google.protobuf.DescriptorProtos.FileDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FileDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <pre>
       * file name, relative to root of source tree
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @return Whether the package field is set.
       */
      @java.lang.Override
      public boolean hasPackage() {
        return instance.hasPackage();
      }
      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @return The package.
       */
      @java.lang.Override
      public java.lang.String getPackage() {
        return instance.getPackage();
      }
      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @return The bytes for package.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPackageBytes() {
        return instance.getPackageBytes();
      }
      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @param value The package to set.
       * @return This builder for chaining.
       */
      public Builder setPackage(
          java.lang.String value) {
        copyOnWrite();
        instance.setPackage(value);
        return this;
      }
      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPackage() {
        copyOnWrite();
        instance.clearPackage();
        return this;
      }
      /**
       * <pre>
       * e.g. "foo", "foo.bar", etc.
       * </pre>
       *
       * <code>optional string package = 2;</code>
       * @param value The bytes for package to set.
       * @return This builder for chaining.
       */
      public Builder setPackageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPackageBytes(value);
        return this;
      }

      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @return A list containing the dependency.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getDependencyList() {
        return java.util.Collections.unmodifiableList(
            instance.getDependencyList());
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @return The count of dependency.
       */
      @java.lang.Override
      public int getDependencyCount() {
        return instance.getDependencyCount();
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param index The index of the element to return.
       * @return The dependency at the given index.
       */
      @java.lang.Override
      public java.lang.String getDependency(int index) {
        return instance.getDependency(index);
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the dependency at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDependencyBytes(int index) {
        return instance.getDependencyBytes(index);
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param index The index to set the value at.
       * @param value The dependency to set.
       * @return This builder for chaining.
       */
      public Builder setDependency(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setDependency(index, value);
        return this;
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param value The dependency to add.
       * @return This builder for chaining.
       */
      public Builder addDependency(
          java.lang.String value) {
        copyOnWrite();
        instance.addDependency(value);
        return this;
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param values The dependency to add.
       * @return This builder for chaining.
       */
      public Builder addAllDependency(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllDependency(values);
        return this;
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDependency() {
        copyOnWrite();
        instance.clearDependency();
        return this;
      }
      /**
       * <pre>
       * Names of files imported by this file.
       * </pre>
       *
       * <code>repeated string dependency = 3;</code>
       * @param value The bytes of the dependency to add.
       * @return This builder for chaining.
       */
      public Builder addDependencyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addDependencyBytes(value);
        return this;
      }

      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @return A list containing the publicDependency.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getPublicDependencyList() {
        return java.util.Collections.unmodifiableList(
            instance.getPublicDependencyList());
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @return The count of publicDependency.
       */
      @java.lang.Override
      public int getPublicDependencyCount() {
        return instance.getPublicDependencyCount();
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @param index The index of the element to return.
       * @return The publicDependency at the given index.
       */
      @java.lang.Override
      public int getPublicDependency(int index) {
        return instance.getPublicDependency(index);
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @param value The publicDependency to set.
       * @return This builder for chaining.
       */
      public Builder setPublicDependency(
          int index, int value) {
        copyOnWrite();
        instance.setPublicDependency(index, value);
        return this;
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @param value The publicDependency to add.
       * @return This builder for chaining.
       */
      public Builder addPublicDependency(int value) {
        copyOnWrite();
        instance.addPublicDependency(value);
        return this;
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @param values The publicDependency to add.
       * @return This builder for chaining.
       */
      public Builder addAllPublicDependency(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllPublicDependency(values);
        return this;
      }
      /**
       * <pre>
       * Indexes of the public imported files in the dependency list above.
       * </pre>
       *
       * <code>repeated int32 public_dependency = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicDependency() {
        copyOnWrite();
        instance.clearPublicDependency();
        return this;
      }

      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @return A list containing the weakDependency.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getWeakDependencyList() {
        return java.util.Collections.unmodifiableList(
            instance.getWeakDependencyList());
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @return The count of weakDependency.
       */
      @java.lang.Override
      public int getWeakDependencyCount() {
        return instance.getWeakDependencyCount();
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @param index The index of the element to return.
       * @return The weakDependency at the given index.
       */
      @java.lang.Override
      public int getWeakDependency(int index) {
        return instance.getWeakDependency(index);
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @param value The weakDependency to set.
       * @return This builder for chaining.
       */
      public Builder setWeakDependency(
          int index, int value) {
        copyOnWrite();
        instance.setWeakDependency(index, value);
        return this;
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @param value The weakDependency to add.
       * @return This builder for chaining.
       */
      public Builder addWeakDependency(int value) {
        copyOnWrite();
        instance.addWeakDependency(value);
        return this;
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @param values The weakDependency to add.
       * @return This builder for chaining.
       */
      public Builder addAllWeakDependency(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllWeakDependency(values);
        return this;
      }
      /**
       * <pre>
       * Indexes of the weak imported files in the dependency list.
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>repeated int32 weak_dependency = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearWeakDependency() {
        copyOnWrite();
        instance.clearWeakDependency();
        return this;
      }

      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> getMessageTypeList() {
        return java.util.Collections.unmodifiableList(
            instance.getMessageTypeList());
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      @java.lang.Override
      public int getMessageTypeCount() {
        return instance.getMessageTypeCount();
      }/**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.DescriptorProto getMessageType(int index) {
        return instance.getMessageType(index);
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder setMessageType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.setMessageType(index, value);
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder setMessageType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setMessageType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder addMessageType(com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.addMessageType(value);
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder addMessageType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.addMessageType(index, value);
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder addMessageType(
          com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addMessageType(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder addMessageType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addMessageType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder addAllMessageType(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto> values) {
        copyOnWrite();
        instance.addAllMessageType(values);
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder clearMessageType() {
        copyOnWrite();
        instance.clearMessageType();
        return this;
      }
      /**
       * <pre>
       * All top-level definitions in this file.
       * </pre>
       *
       * <code>repeated .google.protobuf.DescriptorProto message_type = 4;</code>
       */
      public Builder removeMessageType(int index) {
        copyOnWrite();
        instance.removeMessageType(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> getEnumTypeList() {
        return java.util.Collections.unmodifiableList(
            instance.getEnumTypeList());
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      @java.lang.Override
      public int getEnumTypeCount() {
        return instance.getEnumTypeCount();
      }/**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index) {
        return instance.getEnumType(index);
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder setEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.setEnumType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder setEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setEnumType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder addEnumType(com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.addEnumType(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder addEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.addEnumType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder addEnumType(
          com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addEnumType(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder addEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addEnumType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder addAllEnumType(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto> values) {
        copyOnWrite();
        instance.addAllEnumType(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder clearEnumType() {
        copyOnWrite();
        instance.clearEnumType();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 5;</code>
       */
      public Builder removeEnumType(int index) {
        copyOnWrite();
        instance.removeEnumType(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> getServiceList() {
        return java.util.Collections.unmodifiableList(
            instance.getServiceList());
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      @java.lang.Override
      public int getServiceCount() {
        return instance.getServiceCount();
      }/**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.ServiceDescriptorProto getService(int index) {
        return instance.getService(index);
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder setService(
          int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
        copyOnWrite();
        instance.setService(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder setService(
          int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setService(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder addService(com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
        copyOnWrite();
        instance.addService(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder addService(
          int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto value) {
        copyOnWrite();
        instance.addService(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder addService(
          com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addService(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder addService(
          int index, com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addService(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder addAllService(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> values) {
        copyOnWrite();
        instance.addAllService(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder clearService() {
        copyOnWrite();
        instance.clearService();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.ServiceDescriptorProto service = 6;</code>
       */
      public Builder removeService(int index) {
        copyOnWrite();
        instance.removeService(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getExtensionList() {
        return java.util.Collections.unmodifiableList(
            instance.getExtensionList());
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      @java.lang.Override
      public int getExtensionCount() {
        return instance.getExtensionCount();
      }/**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index) {
        return instance.getExtension(index);
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder setExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.setExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder setExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder addExtension(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addExtension(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder addExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder addExtension(
          com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder addExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder addAllExtension(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
        copyOnWrite();
        instance.addAllExtension(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder clearExtension() {
        copyOnWrite();
        instance.clearExtension();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 7;</code>
       */
      public Builder removeExtension(int index) {
        copyOnWrite();
        instance.removeExtension(index);
        return this;
      }

      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FileOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.FileOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.FileOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.FileOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FileOptions options = 8;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      @java.lang.Override
      public boolean hasSourceCodeInfo() {
        return instance.hasSourceCodeInfo();
      }
      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.SourceCodeInfo getSourceCodeInfo() {
        return instance.getSourceCodeInfo();
      }
      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      public Builder setSourceCodeInfo(com.google.protobuf.DescriptorProtos.SourceCodeInfo value) {
        copyOnWrite();
        instance.setSourceCodeInfo(value);
        return this;
        }
      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      public Builder setSourceCodeInfo(
          com.google.protobuf.DescriptorProtos.SourceCodeInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setSourceCodeInfo(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      public Builder mergeSourceCodeInfo(com.google.protobuf.DescriptorProtos.SourceCodeInfo value) {
        copyOnWrite();
        instance.mergeSourceCodeInfo(value);
        return this;
      }
      /**
       * <pre>
       * This field contains optional information about the original source code.
       * You may safely remove this entire field without harming runtime
       * functionality of the descriptors -- the information is needed only by
       * development tools.
       * </pre>
       *
       * <code>optional .google.protobuf.SourceCodeInfo source_code_info = 9;</code>
       */
      public Builder clearSourceCodeInfo() {  copyOnWrite();
        instance.clearSourceCodeInfo();
        return this;
      }

      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @return Whether the syntax field is set.
       */
      @java.lang.Override
      public boolean hasSyntax() {
        return instance.hasSyntax();
      }
      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @return The syntax.
       */
      @java.lang.Override
      public java.lang.String getSyntax() {
        return instance.getSyntax();
      }
      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @return The bytes for syntax.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSyntaxBytes() {
        return instance.getSyntaxBytes();
      }
      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @param value The syntax to set.
       * @return This builder for chaining.
       */
      public Builder setSyntax(
          java.lang.String value) {
        copyOnWrite();
        instance.setSyntax(value);
        return this;
      }
      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearSyntax() {
        copyOnWrite();
        instance.clearSyntax();
        return this;
      }
      /**
       * <pre>
       * The syntax of the proto file.
       * The supported values are "proto2", "proto3", and "editions".
       * If `edition` is present, this value must be "editions".
       * </pre>
       *
       * <code>optional string syntax = 12;</code>
       * @param value The bytes for syntax to set.
       * @return This builder for chaining.
       */
      public Builder setSyntaxBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSyntaxBytes(value);
        return this;
      }

      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @return Whether the edition field is set.
       */
      @java.lang.Override
      public boolean hasEdition() {
        return instance.hasEdition();
      }
      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @return The edition.
       */
      @java.lang.Override
      public java.lang.String getEdition() {
        return instance.getEdition();
      }
      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @return The bytes for edition.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getEditionBytes() {
        return instance.getEditionBytes();
      }
      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @param value The edition to set.
       * @return This builder for chaining.
       */
      public Builder setEdition(
          java.lang.String value) {
        copyOnWrite();
        instance.setEdition(value);
        return this;
      }
      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearEdition() {
        copyOnWrite();
        instance.clearEdition();
        return this;
      }
      /**
       * <pre>
       * The edition of the proto file, which is an opaque string.
       * </pre>
       *
       * <code>optional string edition = 13;</code>
       * @param value The bytes for edition to set.
       * @return This builder for chaining.
       */
      public Builder setEditionBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setEditionBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FileDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FileDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "package_",
              "dependency_",
              "messageType_",
              com.google.protobuf.DescriptorProtos.DescriptorProto.class,
              "enumType_",
              com.google.protobuf.DescriptorProtos.EnumDescriptorProto.class,
              "service_",
              com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.class,
              "extension_",
              com.google.protobuf.DescriptorProtos.FieldDescriptorProto.class,
              "options_",
              "sourceCodeInfo_",
              "publicDependency_",
              "weakDependency_",
              "syntax_",
              "edition_",
            };
            java.lang.String info =
                "\u0001\r\u0000\u0001\u0001\r\r\u0000\u0007\u0005\u0001\u1008\u0000\u0002\u1008\u0001" +
                "\u0003\u001a\u0004\u041b\u0005\u041b\u0006\u041b\u0007\u041b\b\u1409\u0002\t\u1009" +
                "\u0003\n\u0016\u000b\u0016\f\u1008\u0004\r\u1008\u0005";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FileDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FileDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FileDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FileDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.FileDescriptorProto DEFAULT_INSTANCE;
    static {
      FileDescriptorProto defaultInstance = new FileDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FileDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FileDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FileDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<FileDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface DescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.DescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> 
        getFieldList();
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    com.google.protobuf.DescriptorProtos.FieldDescriptorProto getField(int index);
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    int getFieldCount();

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> 
        getExtensionList();
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index);
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    int getExtensionCount();

    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> 
        getNestedTypeList();
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    com.google.protobuf.DescriptorProtos.DescriptorProto getNestedType(int index);
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    int getNestedTypeCount();

    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> 
        getEnumTypeList();
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index);
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    int getEnumTypeCount();

    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> 
        getExtensionRangeList();
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange getExtensionRange(int index);
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    int getExtensionRangeCount();

    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> 
        getOneofDeclList();
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    com.google.protobuf.DescriptorProtos.OneofDescriptorProto getOneofDecl(int index);
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    int getOneofDeclCount();

    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.MessageOptions getOptions();

    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> 
        getReservedRangeList();
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange getReservedRange(int index);
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    int getReservedRangeCount();

    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @return A list containing the reservedName.
     */
    java.util.List<java.lang.String>
        getReservedNameList();
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @return The count of reservedName.
     */
    int getReservedNameCount();
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    java.lang.String getReservedName(int index);
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    com.google.protobuf.ByteString
        getReservedNameBytes(int index);
  }
  /**
   * <pre>
   * Describes a message type.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.DescriptorProto}
   */
  public  static final class DescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          DescriptorProto, DescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.DescriptorProto)
      DescriptorProtoOrBuilder {
    private DescriptorProto() {
      name_ = "";
      field_ = emptyProtobufList();
      extension_ = emptyProtobufList();
      nestedType_ = emptyProtobufList();
      enumType_ = emptyProtobufList();
      extensionRange_ = emptyProtobufList();
      oneofDecl_ = emptyProtobufList();
      reservedRange_ = emptyProtobufList();
      reservedName_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    public interface ExtensionRangeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.DescriptorProto.ExtensionRange)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      boolean hasStart();
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      int getStart();

      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      boolean hasEnd();
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      int getEnd();

      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       * @return Whether the options field is set.
       */
      boolean hasOptions();
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       * @return The options.
       */
      com.google.protobuf.DescriptorProtos.ExtensionRangeOptions getOptions();
    }
    /**
     * Protobuf type {@code google.protobuf.DescriptorProto.ExtensionRange}
     */
    public  static final class ExtensionRange extends
        com.google.protobuf.GeneratedMessageLite<
            ExtensionRange, ExtensionRange.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.DescriptorProto.ExtensionRange)
        ExtensionRangeOrBuilder {
      private ExtensionRange() {
      }
      private int bitField0_;
      public static final int START_FIELD_NUMBER = 1;
      private int start_;
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public int getStart() {
        return start_;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @param value The start to set.
       */
      private void setStart(int value) {
        bitField0_ |= 0x00000001;
        start_ = value;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       */
      private void clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0;
      }

      public static final int END_FIELD_NUMBER = 2;
      private int end_;
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public int getEnd() {
        return end_;
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @param value The end to set.
       */
      private void setEnd(int value) {
        bitField0_ |= 0x00000002;
        end_ = value;
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       */
      private void clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000002);
        end_ = 0;
      }

      public static final int OPTIONS_FIELD_NUMBER = 3;
      private com.google.protobuf.DescriptorProtos.ExtensionRangeOptions options_;
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions getOptions() {
        return options_ == null ? com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.getDefaultInstance() : options_;
      }
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       */
      private void setOptions(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions value) {
        value.getClass();
  options_ = value;
        bitField0_ |= 0x00000004;
        }
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       */
      @java.lang.SuppressWarnings({"ReferenceEquality"})
      private void mergeOptions(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions value) {
        value.getClass();
  if (options_ != null &&
            options_ != com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.getDefaultInstance()) {
          options_ =
            com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.newBuilder(options_).mergeFrom(value).buildPartial();
        } else {
          options_ = value;
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
       */
      private void clearOptions() {  options_ = null;
        bitField0_ = (bitField0_ & ~0x00000004);
      }

      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code google.protobuf.DescriptorProto.ExtensionRange}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.DescriptorProto.ExtensionRange)
          com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRangeOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return Whether the start field is set.
         */
        @java.lang.Override
        public boolean hasStart() {
          return instance.hasStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return The start.
         */
        @java.lang.Override
        public int getStart() {
          return instance.getStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @param value The start to set.
         * @return This builder for chaining.
         */
        public Builder setStart(int value) {
          copyOnWrite();
          instance.setStart(value);
          return this;
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearStart() {
          copyOnWrite();
          instance.clearStart();
          return this;
        }

        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return Whether the end field is set.
         */
        @java.lang.Override
        public boolean hasEnd() {
          return instance.hasEnd();
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return The end.
         */
        @java.lang.Override
        public int getEnd() {
          return instance.getEnd();
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @param value The end to set.
         * @return This builder for chaining.
         */
        public Builder setEnd(int value) {
          copyOnWrite();
          instance.setEnd(value);
          return this;
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnd() {
          copyOnWrite();
          instance.clearEnd();
          return this;
        }

        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        @java.lang.Override
        public boolean hasOptions() {
          return instance.hasOptions();
        }
        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        @java.lang.Override
        public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions getOptions() {
          return instance.getOptions();
        }
        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        public Builder setOptions(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions value) {
          copyOnWrite();
          instance.setOptions(value);
          return this;
          }
        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        public Builder setOptions(
            com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Builder builderForValue) {
          copyOnWrite();
          instance.setOptions(builderForValue.build());
          return this;
        }
        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        public Builder mergeOptions(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions value) {
          copyOnWrite();
          instance.mergeOptions(value);
          return this;
        }
        /**
         * <code>optional .google.protobuf.ExtensionRangeOptions options = 3;</code>
         */
        public Builder clearOptions() {  copyOnWrite();
          instance.clearOptions();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.DescriptorProto.ExtensionRange)
      }
      private byte memoizedIsInitialized = 2;
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "start_",
                "end_",
                "options_",
              };
              java.lang.String info =
                  "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0001\u0001\u1004\u0000\u0002" +
                  "\u1004\u0001\u0003\u1409\u0002";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return memoizedIsInitialized;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.DescriptorProto.ExtensionRange)
      private static final com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange DEFAULT_INSTANCE;
      static {
        ExtensionRange defaultInstance = new ExtensionRange();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          ExtensionRange.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<ExtensionRange> PARSER;

      public static com.google.protobuf.Parser<ExtensionRange> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface ReservedRangeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.DescriptorProto.ReservedRange)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      boolean hasStart();
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      int getStart();

      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      boolean hasEnd();
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      int getEnd();
    }
    /**
     * <pre>
     * Range of reserved tag numbers. Reserved tag numbers may not be used by
     * fields or extension ranges in the same message. Reserved ranges may
     * not overlap.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.DescriptorProto.ReservedRange}
     */
    public  static final class ReservedRange extends
        com.google.protobuf.GeneratedMessageLite<
            ReservedRange, ReservedRange.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.DescriptorProto.ReservedRange)
        ReservedRangeOrBuilder {
      private ReservedRange() {
      }
      private int bitField0_;
      public static final int START_FIELD_NUMBER = 1;
      private int start_;
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public int getStart() {
        return start_;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @param value The start to set.
       */
      private void setStart(int value) {
        bitField0_ |= 0x00000001;
        start_ = value;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       */
      private void clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0;
      }

      public static final int END_FIELD_NUMBER = 2;
      private int end_;
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public int getEnd() {
        return end_;
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @param value The end to set.
       */
      private void setEnd(int value) {
        bitField0_ |= 0x00000002;
        end_ = value;
      }
      /**
       * <pre>
       * Exclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       */
      private void clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000002);
        end_ = 0;
      }

      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Range of reserved tag numbers. Reserved tag numbers may not be used by
       * fields or extension ranges in the same message. Reserved ranges may
       * not overlap.
       * </pre>
       *
       * Protobuf type {@code google.protobuf.DescriptorProto.ReservedRange}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.DescriptorProto.ReservedRange)
          com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRangeOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return Whether the start field is set.
         */
        @java.lang.Override
        public boolean hasStart() {
          return instance.hasStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return The start.
         */
        @java.lang.Override
        public int getStart() {
          return instance.getStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @param value The start to set.
         * @return This builder for chaining.
         */
        public Builder setStart(int value) {
          copyOnWrite();
          instance.setStart(value);
          return this;
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearStart() {
          copyOnWrite();
          instance.clearStart();
          return this;
        }

        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return Whether the end field is set.
         */
        @java.lang.Override
        public boolean hasEnd() {
          return instance.hasEnd();
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return The end.
         */
        @java.lang.Override
        public int getEnd() {
          return instance.getEnd();
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @param value The end to set.
         * @return This builder for chaining.
         */
        public Builder setEnd(int value) {
          copyOnWrite();
          instance.setEnd(value);
          return this;
        }
        /**
         * <pre>
         * Exclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnd() {
          copyOnWrite();
          instance.clearEnd();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.DescriptorProto.ReservedRange)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "start_",
                "end_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                  "\u1004\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.DescriptorProto.ReservedRange)
      private static final com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange DEFAULT_INSTANCE;
      static {
        ReservedRange defaultInstance = new ReservedRange();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          ReservedRange.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<ReservedRange> PARSER;

      public static com.google.protobuf.Parser<ReservedRange> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int FIELD_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> field_;
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getFieldList() {
      return field_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder> 
        getFieldOrBuilderList() {
      return field_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    @java.lang.Override
    public int getFieldCount() {
      return field_.size();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getField(int index) {
      return field_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder getFieldOrBuilder(
        int index) {
      return field_.get(index);
    }
    private void ensureFieldIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> tmp = field_;
      if (!tmp.isModifiable()) {
        field_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void setField(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureFieldIsMutable();
      field_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void addField(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureFieldIsMutable();
      field_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void addField(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureFieldIsMutable();
      field_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void addAllField(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
      ensureFieldIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, field_);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void clearField() {
      field_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
     */
    private void removeField(int index) {
      ensureFieldIsMutable();
      field_.remove(index);
    }

    public static final int EXTENSION_FIELD_NUMBER = 6;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> extension_;
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getExtensionList() {
      return extension_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder> 
        getExtensionOrBuilderList() {
      return extension_;
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    @java.lang.Override
    public int getExtensionCount() {
      return extension_.size();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index) {
      return extension_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder getExtensionOrBuilder(
        int index) {
      return extension_.get(index);
    }
    private void ensureExtensionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> tmp = extension_;
      if (!tmp.isModifiable()) {
        extension_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void setExtension(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void addExtension(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void addExtension(
        int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
      value.getClass();
  ensureExtensionIsMutable();
      extension_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void addAllExtension(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
      ensureExtensionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, extension_);
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void clearExtension() {
      extension_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
     */
    private void removeExtension(int index) {
      ensureExtensionIsMutable();
      extension_.remove(index);
    }

    public static final int NESTED_TYPE_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto> nestedType_;
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> getNestedTypeList() {
      return nestedType_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.DescriptorProtoOrBuilder> 
        getNestedTypeOrBuilderList() {
      return nestedType_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    @java.lang.Override
    public int getNestedTypeCount() {
      return nestedType_.size();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.DescriptorProto getNestedType(int index) {
      return nestedType_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    public com.google.protobuf.DescriptorProtos.DescriptorProtoOrBuilder getNestedTypeOrBuilder(
        int index) {
      return nestedType_.get(index);
    }
    private void ensureNestedTypeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto> tmp = nestedType_;
      if (!tmp.isModifiable()) {
        nestedType_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void setNestedType(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureNestedTypeIsMutable();
      nestedType_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void addNestedType(com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureNestedTypeIsMutable();
      nestedType_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void addNestedType(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
      value.getClass();
  ensureNestedTypeIsMutable();
      nestedType_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void addAllNestedType(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto> values) {
      ensureNestedTypeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, nestedType_);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void clearNestedType() {
      nestedType_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
     */
    private void removeNestedType(int index) {
      ensureNestedTypeIsMutable();
      nestedType_.remove(index);
    }

    public static final int ENUM_TYPE_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> enumType_;
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> getEnumTypeList() {
      return enumType_;
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProtoOrBuilder> 
        getEnumTypeOrBuilderList() {
      return enumType_;
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    @java.lang.Override
    public int getEnumTypeCount() {
      return enumType_.size();
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index) {
      return enumType_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProtoOrBuilder getEnumTypeOrBuilder(
        int index) {
      return enumType_.get(index);
    }
    private void ensureEnumTypeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> tmp = enumType_;
      if (!tmp.isModifiable()) {
        enumType_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void setEnumType(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void addEnumType(com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void addEnumType(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
      value.getClass();
  ensureEnumTypeIsMutable();
      enumType_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void addAllEnumType(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto> values) {
      ensureEnumTypeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, enumType_);
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void clearEnumType() {
      enumType_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
     */
    private void removeEnumType(int index) {
      ensureEnumTypeIsMutable();
      enumType_.remove(index);
    }

    public static final int EXTENSION_RANGE_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> extensionRange_;
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> getExtensionRangeList() {
      return extensionRange_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRangeOrBuilder> 
        getExtensionRangeOrBuilderList() {
      return extensionRange_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    @java.lang.Override
    public int getExtensionRangeCount() {
      return extensionRange_.size();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange getExtensionRange(int index) {
      return extensionRange_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    public com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRangeOrBuilder getExtensionRangeOrBuilder(
        int index) {
      return extensionRange_.get(index);
    }
    private void ensureExtensionRangeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> tmp = extensionRange_;
      if (!tmp.isModifiable()) {
        extensionRange_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void setExtensionRange(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
      value.getClass();
  ensureExtensionRangeIsMutable();
      extensionRange_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void addExtensionRange(com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
      value.getClass();
  ensureExtensionRangeIsMutable();
      extensionRange_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void addExtensionRange(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
      value.getClass();
  ensureExtensionRangeIsMutable();
      extensionRange_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void addAllExtensionRange(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> values) {
      ensureExtensionRangeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, extensionRange_);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void clearExtensionRange() {
      extensionRange_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
     */
    private void removeExtensionRange(int index) {
      ensureExtensionRangeIsMutable();
      extensionRange_.remove(index);
    }

    public static final int ONEOF_DECL_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> oneofDecl_;
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> getOneofDeclList() {
      return oneofDecl_;
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.OneofDescriptorProtoOrBuilder> 
        getOneofDeclOrBuilderList() {
      return oneofDecl_;
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    @java.lang.Override
    public int getOneofDeclCount() {
      return oneofDecl_.size();
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.OneofDescriptorProto getOneofDecl(int index) {
      return oneofDecl_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    public com.google.protobuf.DescriptorProtos.OneofDescriptorProtoOrBuilder getOneofDeclOrBuilder(
        int index) {
      return oneofDecl_.get(index);
    }
    private void ensureOneofDeclIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> tmp = oneofDecl_;
      if (!tmp.isModifiable()) {
        oneofDecl_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void setOneofDecl(
        int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
      value.getClass();
  ensureOneofDeclIsMutable();
      oneofDecl_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void addOneofDecl(com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
      value.getClass();
  ensureOneofDeclIsMutable();
      oneofDecl_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void addOneofDecl(
        int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
      value.getClass();
  ensureOneofDeclIsMutable();
      oneofDecl_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void addAllOneofDecl(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.OneofDescriptorProto> values) {
      ensureOneofDeclIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, oneofDecl_);
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void clearOneofDecl() {
      oneofDecl_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
     */
    private void removeOneofDecl(int index) {
      ensureOneofDeclIsMutable();
      oneofDecl_.remove(index);
    }

    public static final int OPTIONS_FIELD_NUMBER = 7;
    private com.google.protobuf.DescriptorProtos.MessageOptions options_;
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.MessageOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.MessageOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.MessageOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.MessageOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.MessageOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.MessageOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.MessageOptions options = 7;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int RESERVED_RANGE_FIELD_NUMBER = 9;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> reservedRange_;
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> getReservedRangeList() {
      return reservedRange_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRangeOrBuilder> 
        getReservedRangeOrBuilderList() {
      return reservedRange_;
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    @java.lang.Override
    public int getReservedRangeCount() {
      return reservedRange_.size();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange getReservedRange(int index) {
      return reservedRange_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    public com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRangeOrBuilder getReservedRangeOrBuilder(
        int index) {
      return reservedRange_.get(index);
    }
    private void ensureReservedRangeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> tmp = reservedRange_;
      if (!tmp.isModifiable()) {
        reservedRange_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void setReservedRange(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void addReservedRange(com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void addReservedRange(
        int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void addAllReservedRange(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> values) {
      ensureReservedRangeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, reservedRange_);
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void clearReservedRange() {
      reservedRange_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
     */
    private void removeReservedRange(int index) {
      ensureReservedRangeIsMutable();
      reservedRange_.remove(index);
    }

    public static final int RESERVED_NAME_FIELD_NUMBER = 10;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> reservedName_;
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @return A list containing the reservedName.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getReservedNameList() {
      return reservedName_;
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @return The count of reservedName.
     */
    @java.lang.Override
    public int getReservedNameCount() {
      return reservedName_.size();
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    @java.lang.Override
    public java.lang.String getReservedName(int index) {
      return reservedName_.get(index);
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param index The index of the value to return.
     * @return The bytes of the reservedName at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReservedNameBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          reservedName_.get(index));
    }
    private void ensureReservedNameIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          reservedName_;  if (!tmp.isModifiable()) {
        reservedName_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param index The index to set the value at.
     * @param value The reservedName to set.
     */
    private void setReservedName(
        int index, java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureReservedNameIsMutable();
      reservedName_.set(index, value);
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param value The reservedName to add.
     */
    private void addReservedName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureReservedNameIsMutable();
      reservedName_.add(value);
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param values The reservedName to add.
     */
    private void addAllReservedName(
        java.lang.Iterable<java.lang.String> values) {
      ensureReservedNameIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, reservedName_);
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     */
    private void clearReservedName() {
      reservedName_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Reserved field names, which may not be used by fields in the same message.
     * A given name may only be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 10;</code>
     * @param value The bytes of the reservedName to add.
     */
    private void addReservedNameBytes(
        com.google.protobuf.ByteString value) {
      ensureReservedNameIsMutable();
      reservedName_.add(value.toStringUtf8());
    }

    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.DescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.DescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a message type.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.DescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.DescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.DescriptorProto)
        com.google.protobuf.DescriptorProtos.DescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.DescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getFieldList() {
        return java.util.Collections.unmodifiableList(
            instance.getFieldList());
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      @java.lang.Override
      public int getFieldCount() {
        return instance.getFieldCount();
      }/**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getField(int index) {
        return instance.getField(index);
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder setField(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.setField(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder setField(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setField(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder addField(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addField(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder addField(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addField(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder addField(
          com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addField(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder addField(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addField(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder addAllField(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
        copyOnWrite();
        instance.addAllField(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder clearField() {
        copyOnWrite();
        instance.clearField();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto field = 2;</code>
       */
      public Builder removeField(int index) {
        copyOnWrite();
        instance.removeField(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> getExtensionList() {
        return java.util.Collections.unmodifiableList(
            instance.getExtensionList());
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      @java.lang.Override
      public int getExtensionCount() {
        return instance.getExtensionCount();
      }/**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldDescriptorProto getExtension(int index) {
        return instance.getExtension(index);
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder setExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.setExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder setExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder addExtension(com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addExtension(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder addExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto value) {
        copyOnWrite();
        instance.addExtension(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder addExtension(
          com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder addExtension(
          int index, com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addExtension(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder addAllExtension(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldDescriptorProto> values) {
        copyOnWrite();
        instance.addAllExtension(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder clearExtension() {
        copyOnWrite();
        instance.clearExtension();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldDescriptorProto extension = 6;</code>
       */
      public Builder removeExtension(int index) {
        copyOnWrite();
        instance.removeExtension(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto> getNestedTypeList() {
        return java.util.Collections.unmodifiableList(
            instance.getNestedTypeList());
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      @java.lang.Override
      public int getNestedTypeCount() {
        return instance.getNestedTypeCount();
      }/**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.DescriptorProto getNestedType(int index) {
        return instance.getNestedType(index);
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder setNestedType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.setNestedType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder setNestedType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setNestedType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder addNestedType(com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.addNestedType(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder addNestedType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto value) {
        copyOnWrite();
        instance.addNestedType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder addNestedType(
          com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addNestedType(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder addNestedType(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addNestedType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder addAllNestedType(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto> values) {
        copyOnWrite();
        instance.addAllNestedType(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder clearNestedType() {
        copyOnWrite();
        instance.clearNestedType();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto nested_type = 3;</code>
       */
      public Builder removeNestedType(int index) {
        copyOnWrite();
        instance.removeNestedType(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> getEnumTypeList() {
        return java.util.Collections.unmodifiableList(
            instance.getEnumTypeList());
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      @java.lang.Override
      public int getEnumTypeCount() {
        return instance.getEnumTypeCount();
      }/**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumDescriptorProto getEnumType(int index) {
        return instance.getEnumType(index);
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder setEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.setEnumType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder setEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setEnumType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder addEnumType(com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.addEnumType(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder addEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto value) {
        copyOnWrite();
        instance.addEnumType(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder addEnumType(
          com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addEnumType(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder addEnumType(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addEnumType(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder addAllEnumType(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto> values) {
        copyOnWrite();
        instance.addAllEnumType(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder clearEnumType() {
        copyOnWrite();
        instance.clearEnumType();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumDescriptorProto enum_type = 4;</code>
       */
      public Builder removeEnumType(int index) {
        copyOnWrite();
        instance.removeEnumType(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> getExtensionRangeList() {
        return java.util.Collections.unmodifiableList(
            instance.getExtensionRangeList());
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      @java.lang.Override
      public int getExtensionRangeCount() {
        return instance.getExtensionRangeCount();
      }/**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange getExtensionRange(int index) {
        return instance.getExtensionRange(index);
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder setExtensionRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
        copyOnWrite();
        instance.setExtensionRange(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder setExtensionRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.Builder builderForValue) {
        copyOnWrite();
        instance.setExtensionRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder addExtensionRange(com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
        copyOnWrite();
        instance.addExtensionRange(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder addExtensionRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange value) {
        copyOnWrite();
        instance.addExtensionRange(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder addExtensionRange(
          com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.Builder builderForValue) {
        copyOnWrite();
        instance.addExtensionRange(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder addExtensionRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.Builder builderForValue) {
        copyOnWrite();
        instance.addExtensionRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder addAllExtensionRange(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange> values) {
        copyOnWrite();
        instance.addAllExtensionRange(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder clearExtensionRange() {
        copyOnWrite();
        instance.clearExtensionRange();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ExtensionRange extension_range = 5;</code>
       */
      public Builder removeExtensionRange(int index) {
        copyOnWrite();
        instance.removeExtensionRange(index);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> getOneofDeclList() {
        return java.util.Collections.unmodifiableList(
            instance.getOneofDeclList());
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      @java.lang.Override
      public int getOneofDeclCount() {
        return instance.getOneofDeclCount();
      }/**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.OneofDescriptorProto getOneofDecl(int index) {
        return instance.getOneofDecl(index);
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder setOneofDecl(
          int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
        copyOnWrite();
        instance.setOneofDecl(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder setOneofDecl(
          int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setOneofDecl(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder addOneofDecl(com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
        copyOnWrite();
        instance.addOneofDecl(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder addOneofDecl(
          int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto value) {
        copyOnWrite();
        instance.addOneofDecl(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder addOneofDecl(
          com.google.protobuf.DescriptorProtos.OneofDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addOneofDecl(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder addOneofDecl(
          int index, com.google.protobuf.DescriptorProtos.OneofDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addOneofDecl(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder addAllOneofDecl(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.OneofDescriptorProto> values) {
        copyOnWrite();
        instance.addAllOneofDecl(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder clearOneofDecl() {
        copyOnWrite();
        instance.clearOneofDecl();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.OneofDescriptorProto oneof_decl = 8;</code>
       */
      public Builder removeOneofDecl(int index) {
        copyOnWrite();
        instance.removeOneofDecl(index);
        return this;
      }

      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.MessageOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.MessageOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.MessageOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.MessageOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.MessageOptions options = 7;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> getReservedRangeList() {
        return java.util.Collections.unmodifiableList(
            instance.getReservedRangeList());
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      @java.lang.Override
      public int getReservedRangeCount() {
        return instance.getReservedRangeCount();
      }/**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange getReservedRange(int index) {
        return instance.getReservedRange(index);
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder setReservedRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
        copyOnWrite();
        instance.setReservedRange(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder setReservedRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.setReservedRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder addReservedRange(com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
        copyOnWrite();
        instance.addReservedRange(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder addReservedRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange value) {
        copyOnWrite();
        instance.addReservedRange(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder addReservedRange(
          com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.addReservedRange(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder addReservedRange(
          int index, com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.addReservedRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder addAllReservedRange(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange> values) {
        copyOnWrite();
        instance.addAllReservedRange(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder clearReservedRange() {
        copyOnWrite();
        instance.clearReservedRange();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.DescriptorProto.ReservedRange reserved_range = 9;</code>
       */
      public Builder removeReservedRange(int index) {
        copyOnWrite();
        instance.removeReservedRange(index);
        return this;
      }

      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @return A list containing the reservedName.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getReservedNameList() {
        return java.util.Collections.unmodifiableList(
            instance.getReservedNameList());
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @return The count of reservedName.
       */
      @java.lang.Override
      public int getReservedNameCount() {
        return instance.getReservedNameCount();
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param index The index of the element to return.
       * @return The reservedName at the given index.
       */
      @java.lang.Override
      public java.lang.String getReservedName(int index) {
        return instance.getReservedName(index);
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param index The index of the value to return.
       * @return The bytes of the reservedName at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getReservedNameBytes(int index) {
        return instance.getReservedNameBytes(index);
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param index The index to set the value at.
       * @param value The reservedName to set.
       * @return This builder for chaining.
       */
      public Builder setReservedName(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setReservedName(index, value);
        return this;
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param value The reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addReservedName(
          java.lang.String value) {
        copyOnWrite();
        instance.addReservedName(value);
        return this;
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param values The reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addAllReservedName(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllReservedName(values);
        return this;
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearReservedName() {
        copyOnWrite();
        instance.clearReservedName();
        return this;
      }
      /**
       * <pre>
       * Reserved field names, which may not be used by fields in the same message.
       * A given name may only be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 10;</code>
       * @param value The bytes of the reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addReservedNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addReservedNameBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.DescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.DescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "field_",
              com.google.protobuf.DescriptorProtos.FieldDescriptorProto.class,
              "nestedType_",
              com.google.protobuf.DescriptorProtos.DescriptorProto.class,
              "enumType_",
              com.google.protobuf.DescriptorProtos.EnumDescriptorProto.class,
              "extensionRange_",
              com.google.protobuf.DescriptorProtos.DescriptorProto.ExtensionRange.class,
              "extension_",
              com.google.protobuf.DescriptorProtos.FieldDescriptorProto.class,
              "options_",
              "oneofDecl_",
              com.google.protobuf.DescriptorProtos.OneofDescriptorProto.class,
              "reservedRange_",
              com.google.protobuf.DescriptorProtos.DescriptorProto.ReservedRange.class,
              "reservedName_",
            };
            java.lang.String info =
                "\u0001\n\u0000\u0001\u0001\n\n\u0000\b\u0007\u0001\u1008\u0000\u0002\u041b\u0003" +
                "\u041b\u0004\u041b\u0005\u041b\u0006\u041b\u0007\u1409\u0001\b\u041b\t\u001b\n\u001a" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.DescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.DescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.DescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.DescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.DescriptorProto DEFAULT_INSTANCE;
    static {
      DescriptorProto defaultInstance = new DescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        DescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.DescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<DescriptorProto> PARSER;

    public static com.google.protobuf.Parser<DescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExtensionRangeOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.ExtensionRangeOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                ExtensionRangeOptions, ExtensionRangeOptions.Builder> {

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();

    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> 
        getDeclarationList();
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration getDeclaration(int index);
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    int getDeclarationCount();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     * @return Whether the verification field is set.
     */
    boolean hasVerification();
    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     * @return The verification.
     */
    com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState getVerification();
  }
  /**
   * Protobuf type {@code google.protobuf.ExtensionRangeOptions}
   */
  public  static final class ExtensionRangeOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        ExtensionRangeOptions, ExtensionRangeOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.ExtensionRangeOptions)
      ExtensionRangeOptionsOrBuilder {
    private ExtensionRangeOptions() {
      uninterpretedOption_ = emptyProtobufList();
      declaration_ = emptyProtobufList();
      verification_ = 1;
    }
    /**
     * <pre>
     * The verification state of the extension range.
     * </pre>
     *
     * Protobuf enum {@code google.protobuf.ExtensionRangeOptions.VerificationState}
     */
    public enum VerificationState
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * All the extensions of the range must be declared.
       * </pre>
       *
       * <code>DECLARATION = 0;</code>
       */
      DECLARATION(0),
      /**
       * <code>UNVERIFIED = 1;</code>
       */
      UNVERIFIED(1),
      ;

      /**
       * <pre>
       * All the extensions of the range must be declared.
       * </pre>
       *
       * <code>DECLARATION = 0;</code>
       */
      public static final int DECLARATION_VALUE = 0;
      /**
       * <code>UNVERIFIED = 1;</code>
       */
      public static final int UNVERIFIED_VALUE = 1;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static VerificationState valueOf(int value) {
        return forNumber(value);
      }

      public static VerificationState forNumber(int value) {
        switch (value) {
          case 0: return DECLARATION;
          case 1: return UNVERIFIED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VerificationState>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          VerificationState> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<VerificationState>() {
              @java.lang.Override
              public VerificationState findValueByNumber(int number) {
                return VerificationState.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return VerificationStateVerifier.INSTANCE;
      }

      private static final class VerificationStateVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new VerificationStateVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return VerificationState.forNumber(number) != null;
              }
            };

      private final int value;

      private VerificationState(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.ExtensionRangeOptions.VerificationState)
    }

    public interface DeclarationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.ExtensionRangeOptions.Declaration)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       * @return Whether the number field is set.
       */
      boolean hasNumber();
      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       * @return The number.
       */
      int getNumber();

      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return Whether the fullName field is set.
       */
      boolean hasFullName();
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return The fullName.
       */
      java.lang.String getFullName();
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return The bytes for fullName.
       */
      com.google.protobuf.ByteString
          getFullNameBytes();

      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return Whether the type field is set.
       */
      boolean hasType();
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return The type.
       */
      java.lang.String getType();
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return The bytes for type.
       */
      com.google.protobuf.ByteString
          getTypeBytes();

      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       * @return Whether the reserved field is set.
       */
      boolean hasReserved();
      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       * @return The reserved.
       */
      boolean getReserved();

      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       * @return Whether the repeated field is set.
       */
      boolean hasRepeated();
      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       * @return The repeated.
       */
      boolean getRepeated();
    }
    /**
     * Protobuf type {@code google.protobuf.ExtensionRangeOptions.Declaration}
     */
    public  static final class Declaration extends
        com.google.protobuf.GeneratedMessageLite<
            Declaration, Declaration.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.ExtensionRangeOptions.Declaration)
        DeclarationOrBuilder {
      private Declaration() {
        fullName_ = "";
        type_ = "";
      }
      private int bitField0_;
      public static final int NUMBER_FIELD_NUMBER = 1;
      private int number_;
      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       * @return Whether the number field is set.
       */
      @java.lang.Override
      public boolean hasNumber() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       * @return The number.
       */
      @java.lang.Override
      public int getNumber() {
        return number_;
      }
      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       * @param value The number to set.
       */
      private void setNumber(int value) {
        bitField0_ |= 0x00000001;
        number_ = value;
      }
      /**
       * <pre>
       * The extension number declared within the extension range.
       * </pre>
       *
       * <code>optional int32 number = 1;</code>
       */
      private void clearNumber() {
        bitField0_ = (bitField0_ & ~0x00000001);
        number_ = 0;
      }

      public static final int FULL_NAME_FIELD_NUMBER = 2;
      private java.lang.String fullName_;
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return Whether the fullName field is set.
       */
      @java.lang.Override
      public boolean hasFullName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return The fullName.
       */
      @java.lang.Override
      public java.lang.String getFullName() {
        return fullName_;
      }
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @return The bytes for fullName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getFullNameBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(fullName_);
      }
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @param value The fullName to set.
       */
      private void setFullName(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
        fullName_ = value;
      }
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       */
      private void clearFullName() {
        bitField0_ = (bitField0_ & ~0x00000002);
        fullName_ = getDefaultInstance().getFullName();
      }
      /**
       * <pre>
       * The fully-qualified name of the extension field. There must be a leading
       * dot in front of the full name.
       * </pre>
       *
       * <code>optional string full_name = 2;</code>
       * @param value The bytes for fullName to set.
       */
      private void setFullNameBytes(
          com.google.protobuf.ByteString value) {
        fullName_ = value.toStringUtf8();
        bitField0_ |= 0x00000002;
      }

      public static final int TYPE_FIELD_NUMBER = 3;
      private java.lang.String type_;
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return The type.
       */
      @java.lang.Override
      public java.lang.String getType() {
        return type_;
      }
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @return The bytes for type.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTypeBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(type_);
      }
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @param value The type to set.
       */
      private void setType(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
        type_ = value;
      }
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       */
      private void clearType() {
        bitField0_ = (bitField0_ & ~0x00000004);
        type_ = getDefaultInstance().getType();
      }
      /**
       * <pre>
       * The fully-qualified type name of the extension field. Unlike
       * Metadata.type, Declaration.type must have a leading dot for messages
       * and enums.
       * </pre>
       *
       * <code>optional string type = 3;</code>
       * @param value The bytes for type to set.
       */
      private void setTypeBytes(
          com.google.protobuf.ByteString value) {
        type_ = value.toStringUtf8();
        bitField0_ |= 0x00000004;
      }

      public static final int RESERVED_FIELD_NUMBER = 5;
      private boolean reserved_;
      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       * @return Whether the reserved field is set.
       */
      @java.lang.Override
      public boolean hasReserved() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       * @return The reserved.
       */
      @java.lang.Override
      public boolean getReserved() {
        return reserved_;
      }
      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       * @param value The reserved to set.
       */
      private void setReserved(boolean value) {
        bitField0_ |= 0x00000008;
        reserved_ = value;
      }
      /**
       * <pre>
       * If true, indicates that the number is reserved in the extension range,
       * and any extension field with the number will fail to compile. Set this
       * when a declared extension field is deleted.
       * </pre>
       *
       * <code>optional bool reserved = 5;</code>
       */
      private void clearReserved() {
        bitField0_ = (bitField0_ & ~0x00000008);
        reserved_ = false;
      }

      public static final int REPEATED_FIELD_NUMBER = 6;
      private boolean repeated_;
      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       * @return Whether the repeated field is set.
       */
      @java.lang.Override
      public boolean hasRepeated() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       * @return The repeated.
       */
      @java.lang.Override
      public boolean getRepeated() {
        return repeated_;
      }
      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       * @param value The repeated to set.
       */
      private void setRepeated(boolean value) {
        bitField0_ |= 0x00000010;
        repeated_ = value;
      }
      /**
       * <pre>
       * If true, indicates that the extension must be defined as repeated.
       * Otherwise the extension must be defined as optional.
       * </pre>
       *
       * <code>optional bool repeated = 6;</code>
       */
      private void clearRepeated() {
        bitField0_ = (bitField0_ & ~0x00000010);
        repeated_ = false;
      }

      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code google.protobuf.ExtensionRangeOptions.Declaration}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.ExtensionRangeOptions.Declaration)
          com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.DeclarationOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * The extension number declared within the extension range.
         * </pre>
         *
         * <code>optional int32 number = 1;</code>
         * @return Whether the number field is set.
         */
        @java.lang.Override
        public boolean hasNumber() {
          return instance.hasNumber();
        }
        /**
         * <pre>
         * The extension number declared within the extension range.
         * </pre>
         *
         * <code>optional int32 number = 1;</code>
         * @return The number.
         */
        @java.lang.Override
        public int getNumber() {
          return instance.getNumber();
        }
        /**
         * <pre>
         * The extension number declared within the extension range.
         * </pre>
         *
         * <code>optional int32 number = 1;</code>
         * @param value The number to set.
         * @return This builder for chaining.
         */
        public Builder setNumber(int value) {
          copyOnWrite();
          instance.setNumber(value);
          return this;
        }
        /**
         * <pre>
         * The extension number declared within the extension range.
         * </pre>
         *
         * <code>optional int32 number = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearNumber() {
          copyOnWrite();
          instance.clearNumber();
          return this;
        }

        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @return Whether the fullName field is set.
         */
        @java.lang.Override
        public boolean hasFullName() {
          return instance.hasFullName();
        }
        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @return The fullName.
         */
        @java.lang.Override
        public java.lang.String getFullName() {
          return instance.getFullName();
        }
        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @return The bytes for fullName.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getFullNameBytes() {
          return instance.getFullNameBytes();
        }
        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @param value The fullName to set.
         * @return This builder for chaining.
         */
        public Builder setFullName(
            java.lang.String value) {
          copyOnWrite();
          instance.setFullName(value);
          return this;
        }
        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearFullName() {
          copyOnWrite();
          instance.clearFullName();
          return this;
        }
        /**
         * <pre>
         * The fully-qualified name of the extension field. There must be a leading
         * dot in front of the full name.
         * </pre>
         *
         * <code>optional string full_name = 2;</code>
         * @param value The bytes for fullName to set.
         * @return This builder for chaining.
         */
        public Builder setFullNameBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setFullNameBytes(value);
          return this;
        }

        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @return Whether the type field is set.
         */
        @java.lang.Override
        public boolean hasType() {
          return instance.hasType();
        }
        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @return The type.
         */
        @java.lang.Override
        public java.lang.String getType() {
          return instance.getType();
        }
        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @return The bytes for type.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getTypeBytes() {
          return instance.getTypeBytes();
        }
        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @param value The type to set.
         * @return This builder for chaining.
         */
        public Builder setType(
            java.lang.String value) {
          copyOnWrite();
          instance.setType(value);
          return this;
        }
        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearType() {
          copyOnWrite();
          instance.clearType();
          return this;
        }
        /**
         * <pre>
         * The fully-qualified type name of the extension field. Unlike
         * Metadata.type, Declaration.type must have a leading dot for messages
         * and enums.
         * </pre>
         *
         * <code>optional string type = 3;</code>
         * @param value The bytes for type to set.
         * @return This builder for chaining.
         */
        public Builder setTypeBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setTypeBytes(value);
          return this;
        }

        /**
         * <pre>
         * If true, indicates that the number is reserved in the extension range,
         * and any extension field with the number will fail to compile. Set this
         * when a declared extension field is deleted.
         * </pre>
         *
         * <code>optional bool reserved = 5;</code>
         * @return Whether the reserved field is set.
         */
        @java.lang.Override
        public boolean hasReserved() {
          return instance.hasReserved();
        }
        /**
         * <pre>
         * If true, indicates that the number is reserved in the extension range,
         * and any extension field with the number will fail to compile. Set this
         * when a declared extension field is deleted.
         * </pre>
         *
         * <code>optional bool reserved = 5;</code>
         * @return The reserved.
         */
        @java.lang.Override
        public boolean getReserved() {
          return instance.getReserved();
        }
        /**
         * <pre>
         * If true, indicates that the number is reserved in the extension range,
         * and any extension field with the number will fail to compile. Set this
         * when a declared extension field is deleted.
         * </pre>
         *
         * <code>optional bool reserved = 5;</code>
         * @param value The reserved to set.
         * @return This builder for chaining.
         */
        public Builder setReserved(boolean value) {
          copyOnWrite();
          instance.setReserved(value);
          return this;
        }
        /**
         * <pre>
         * If true, indicates that the number is reserved in the extension range,
         * and any extension field with the number will fail to compile. Set this
         * when a declared extension field is deleted.
         * </pre>
         *
         * <code>optional bool reserved = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearReserved() {
          copyOnWrite();
          instance.clearReserved();
          return this;
        }

        /**
         * <pre>
         * If true, indicates that the extension must be defined as repeated.
         * Otherwise the extension must be defined as optional.
         * </pre>
         *
         * <code>optional bool repeated = 6;</code>
         * @return Whether the repeated field is set.
         */
        @java.lang.Override
        public boolean hasRepeated() {
          return instance.hasRepeated();
        }
        /**
         * <pre>
         * If true, indicates that the extension must be defined as repeated.
         * Otherwise the extension must be defined as optional.
         * </pre>
         *
         * <code>optional bool repeated = 6;</code>
         * @return The repeated.
         */
        @java.lang.Override
        public boolean getRepeated() {
          return instance.getRepeated();
        }
        /**
         * <pre>
         * If true, indicates that the extension must be defined as repeated.
         * Otherwise the extension must be defined as optional.
         * </pre>
         *
         * <code>optional bool repeated = 6;</code>
         * @param value The repeated to set.
         * @return This builder for chaining.
         */
        public Builder setRepeated(boolean value) {
          copyOnWrite();
          instance.setRepeated(value);
          return this;
        }
        /**
         * <pre>
         * If true, indicates that the extension must be defined as repeated.
         * Otherwise the extension must be defined as optional.
         * </pre>
         *
         * <code>optional bool repeated = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearRepeated() {
          copyOnWrite();
          instance.clearRepeated();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.ExtensionRangeOptions.Declaration)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "number_",
                "fullName_",
                "type_",
                "reserved_",
                "repeated_",
              };
              java.lang.String info =
                  "\u0001\u0005\u0000\u0001\u0001\u0006\u0005\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                  "\u1008\u0001\u0003\u1008\u0002\u0005\u1007\u0003\u0006\u1007\u0004";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.ExtensionRangeOptions.Declaration)
      private static final com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration DEFAULT_INSTANCE;
      static {
        Declaration defaultInstance = new Declaration();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Declaration.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Declaration> PARSER;

      public static com.google.protobuf.Parser<Declaration> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static final int DECLARATION_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> declaration_;
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> getDeclarationList() {
      return declaration_;
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.DeclarationOrBuilder> 
        getDeclarationOrBuilderList() {
      return declaration_;
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    @java.lang.Override
    public int getDeclarationCount() {
      return declaration_.size();
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration getDeclaration(int index) {
      return declaration_.get(index);
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.DeclarationOrBuilder getDeclarationOrBuilder(
        int index) {
      return declaration_.get(index);
    }
    private void ensureDeclarationIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> tmp = declaration_;
      if (!tmp.isModifiable()) {
        declaration_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void setDeclaration(
        int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
      value.getClass();
  ensureDeclarationIsMutable();
      declaration_.set(index, value);
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void addDeclaration(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
      value.getClass();
  ensureDeclarationIsMutable();
      declaration_.add(value);
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void addDeclaration(
        int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
      value.getClass();
  ensureDeclarationIsMutable();
      declaration_.add(index, value);
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void addAllDeclaration(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> values) {
      ensureDeclarationIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, declaration_);
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void clearDeclaration() {
      declaration_ = emptyProtobufList();
    }
    /**
     * <pre>
     * For external users: DO NOT USE. We are in the process of open sourcing
     * extension declaration and executing internal cleanups before it can be
     * used externally.
     * </pre>
     *
     * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
     */
    private void removeDeclaration(int index) {
      ensureDeclarationIsMutable();
      declaration_.remove(index);
    }

    public static final int FEATURES_FIELD_NUMBER = 50;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int VERIFICATION_FIELD_NUMBER = 3;
    private int verification_;
    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     * @return Whether the verification field is set.
     */
    @java.lang.Override
    public boolean hasVerification() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     * @return The verification.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState getVerification() {
      com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState result = com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState.forNumber(verification_);
      return result == null ? com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState.UNVERIFIED : result;
    }
    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     * @param value The verification to set.
     */
    private void setVerification(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState value) {
      verification_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * The verification state of the range.
     * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
     * are marked as UNVERIFIED.
     * </pre>
     *
     * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
     */
    private void clearVerification() {
      bitField0_ = (bitField0_ & ~0x00000002);
      verification_ = 1;
    }

    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.ExtensionRangeOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.ExtensionRangeOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.ExtensionRangeOptions)
        com.google.protobuf.DescriptorProtos.ExtensionRangeOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> getDeclarationList() {
        return java.util.Collections.unmodifiableList(
            instance.getDeclarationList());
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      @java.lang.Override
      public int getDeclarationCount() {
        return instance.getDeclarationCount();
      }/**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration getDeclaration(int index) {
        return instance.getDeclaration(index);
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder setDeclaration(
          int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
        copyOnWrite();
        instance.setDeclaration(index, value);
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder setDeclaration(
          int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.Builder builderForValue) {
        copyOnWrite();
        instance.setDeclaration(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder addDeclaration(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
        copyOnWrite();
        instance.addDeclaration(value);
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder addDeclaration(
          int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration value) {
        copyOnWrite();
        instance.addDeclaration(index, value);
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder addDeclaration(
          com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.Builder builderForValue) {
        copyOnWrite();
        instance.addDeclaration(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder addDeclaration(
          int index, com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.Builder builderForValue) {
        copyOnWrite();
        instance.addDeclaration(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder addAllDeclaration(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration> values) {
        copyOnWrite();
        instance.addAllDeclaration(values);
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder clearDeclaration() {
        copyOnWrite();
        instance.clearDeclaration();
        return this;
      }
      /**
       * <pre>
       * For external users: DO NOT USE. We are in the process of open sourcing
       * extension declaration and executing internal cleanups before it can be
       * used externally.
       * </pre>
       *
       * <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
       */
      public Builder removeDeclaration(int index) {
        copyOnWrite();
        instance.removeDeclaration(index);
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The verification state of the range.
       * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
       * are marked as UNVERIFIED.
       * </pre>
       *
       * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
       * @return Whether the verification field is set.
       */
      @java.lang.Override
      public boolean hasVerification() {
        return instance.hasVerification();
      }
      /**
       * <pre>
       * The verification state of the range.
       * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
       * are marked as UNVERIFIED.
       * </pre>
       *
       * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
       * @return The verification.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState getVerification() {
        return instance.getVerification();
      }
      /**
       * <pre>
       * The verification state of the range.
       * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
       * are marked as UNVERIFIED.
       * </pre>
       *
       * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
       * @param value The enum numeric value on the wire for verification to set.
       * @return This builder for chaining.
       */
      public Builder setVerification(com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState value) {
        copyOnWrite();
        instance.setVerification(value);
        return this;
      }
      /**
       * <pre>
       * The verification state of the range.
       * TODO(b/278783756): flip the default to DECLARATION once all empty ranges
       * are marked as UNVERIFIED.
       * </pre>
       *
       * <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
       * @return This builder for chaining.
       */
      public Builder clearVerification() {
        copyOnWrite();
        instance.clearVerification();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.ExtensionRangeOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.ExtensionRangeOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "declaration_",
              com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.Declaration.class,
              "verification_",
              com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.VerificationState.internalGetVerifier(),
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0002\u03e7\u0004\u0000\u0002\u0002\u0002\u001b\u0003\u100c" +
                "\u00012\u1409\u0000\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.ExtensionRangeOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.ExtensionRangeOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.ExtensionRangeOptions)
    private static final com.google.protobuf.DescriptorProtos.ExtensionRangeOptions DEFAULT_INSTANCE;
    static {
      ExtensionRangeOptions defaultInstance = new ExtensionRangeOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ExtensionRangeOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.ExtensionRangeOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExtensionRangeOptions> PARSER;

    public static com.google.protobuf.Parser<ExtensionRangeOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FieldDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.FieldDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>optional int32 number = 3;</code>
     * @return Whether the number field is set.
     */
    boolean hasNumber();
    /**
     * <code>optional int32 number = 3;</code>
     * @return The number.
     */
    int getNumber();

    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @return Whether the label field is set.
     */
    boolean hasLabel();
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @return The label.
     */
    com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label getLabel();

    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @return The type.
     */
    com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type getType();

    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return Whether the typeName field is set.
     */
    boolean hasTypeName();
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return The typeName.
     */
    java.lang.String getTypeName();
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return The bytes for typeName.
     */
    com.google.protobuf.ByteString
        getTypeNameBytes();

    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return Whether the extendee field is set.
     */
    boolean hasExtendee();
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return The extendee.
     */
    java.lang.String getExtendee();
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return The bytes for extendee.
     */
    com.google.protobuf.ByteString
        getExtendeeBytes();

    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return Whether the defaultValue field is set.
     */
    boolean hasDefaultValue();
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return The defaultValue.
     */
    java.lang.String getDefaultValue();
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return The bytes for defaultValue.
     */
    com.google.protobuf.ByteString
        getDefaultValueBytes();

    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @return Whether the oneofIndex field is set.
     */
    boolean hasOneofIndex();
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @return The oneofIndex.
     */
    int getOneofIndex();

    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return Whether the jsonName field is set.
     */
    boolean hasJsonName();
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return The jsonName.
     */
    java.lang.String getJsonName();
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return The bytes for jsonName.
     */
    com.google.protobuf.ByteString
        getJsonNameBytes();

    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.FieldOptions getOptions();

    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @return Whether the proto3Optional field is set.
     */
    boolean hasProto3Optional();
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @return The proto3Optional.
     */
    boolean getProto3Optional();
  }
  /**
   * <pre>
   * Describes a field within a message.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.FieldDescriptorProto}
   */
  public  static final class FieldDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          FieldDescriptorProto, FieldDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FieldDescriptorProto)
      FieldDescriptorProtoOrBuilder {
    private FieldDescriptorProto() {
      name_ = "";
      label_ = 1;
      type_ = 1;
      typeName_ = "";
      extendee_ = "";
      defaultValue_ = "";
      jsonName_ = "";
    }
    /**
     * Protobuf enum {@code google.protobuf.FieldDescriptorProto.Type}
     */
    public enum Type
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * 0 is reserved for errors.
       * Order is weird for historical reasons.
       * </pre>
       *
       * <code>TYPE_DOUBLE = 1;</code>
       */
      TYPE_DOUBLE(1),
      /**
       * <code>TYPE_FLOAT = 2;</code>
       */
      TYPE_FLOAT(2),
      /**
       * <pre>
       * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
       * negative values are likely.
       * </pre>
       *
       * <code>TYPE_INT64 = 3;</code>
       */
      TYPE_INT64(3),
      /**
       * <code>TYPE_UINT64 = 4;</code>
       */
      TYPE_UINT64(4),
      /**
       * <pre>
       * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
       * negative values are likely.
       * </pre>
       *
       * <code>TYPE_INT32 = 5;</code>
       */
      TYPE_INT32(5),
      /**
       * <code>TYPE_FIXED64 = 6;</code>
       */
      TYPE_FIXED64(6),
      /**
       * <code>TYPE_FIXED32 = 7;</code>
       */
      TYPE_FIXED32(7),
      /**
       * <code>TYPE_BOOL = 8;</code>
       */
      TYPE_BOOL(8),
      /**
       * <code>TYPE_STRING = 9;</code>
       */
      TYPE_STRING(9),
      /**
       * <pre>
       * Tag-delimited aggregate.
       * Group type is deprecated and not supported in proto3. However, Proto3
       * implementations should still be able to parse the group wire format and
       * treat group fields as unknown fields.
       * </pre>
       *
       * <code>TYPE_GROUP = 10;</code>
       */
      TYPE_GROUP(10),
      /**
       * <pre>
       * Length-delimited aggregate.
       * </pre>
       *
       * <code>TYPE_MESSAGE = 11;</code>
       */
      TYPE_MESSAGE(11),
      /**
       * <pre>
       * New in version 2.
       * </pre>
       *
       * <code>TYPE_BYTES = 12;</code>
       */
      TYPE_BYTES(12),
      /**
       * <code>TYPE_UINT32 = 13;</code>
       */
      TYPE_UINT32(13),
      /**
       * <code>TYPE_ENUM = 14;</code>
       */
      TYPE_ENUM(14),
      /**
       * <code>TYPE_SFIXED32 = 15;</code>
       */
      TYPE_SFIXED32(15),
      /**
       * <code>TYPE_SFIXED64 = 16;</code>
       */
      TYPE_SFIXED64(16),
      /**
       * <pre>
       * Uses ZigZag encoding.
       * </pre>
       *
       * <code>TYPE_SINT32 = 17;</code>
       */
      TYPE_SINT32(17),
      /**
       * <pre>
       * Uses ZigZag encoding.
       * </pre>
       *
       * <code>TYPE_SINT64 = 18;</code>
       */
      TYPE_SINT64(18),
      ;

      /**
       * <pre>
       * 0 is reserved for errors.
       * Order is weird for historical reasons.
       * </pre>
       *
       * <code>TYPE_DOUBLE = 1;</code>
       */
      public static final int TYPE_DOUBLE_VALUE = 1;
      /**
       * <code>TYPE_FLOAT = 2;</code>
       */
      public static final int TYPE_FLOAT_VALUE = 2;
      /**
       * <pre>
       * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
       * negative values are likely.
       * </pre>
       *
       * <code>TYPE_INT64 = 3;</code>
       */
      public static final int TYPE_INT64_VALUE = 3;
      /**
       * <code>TYPE_UINT64 = 4;</code>
       */
      public static final int TYPE_UINT64_VALUE = 4;
      /**
       * <pre>
       * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
       * negative values are likely.
       * </pre>
       *
       * <code>TYPE_INT32 = 5;</code>
       */
      public static final int TYPE_INT32_VALUE = 5;
      /**
       * <code>TYPE_FIXED64 = 6;</code>
       */
      public static final int TYPE_FIXED64_VALUE = 6;
      /**
       * <code>TYPE_FIXED32 = 7;</code>
       */
      public static final int TYPE_FIXED32_VALUE = 7;
      /**
       * <code>TYPE_BOOL = 8;</code>
       */
      public static final int TYPE_BOOL_VALUE = 8;
      /**
       * <code>TYPE_STRING = 9;</code>
       */
      public static final int TYPE_STRING_VALUE = 9;
      /**
       * <pre>
       * Tag-delimited aggregate.
       * Group type is deprecated and not supported in proto3. However, Proto3
       * implementations should still be able to parse the group wire format and
       * treat group fields as unknown fields.
       * </pre>
       *
       * <code>TYPE_GROUP = 10;</code>
       */
      public static final int TYPE_GROUP_VALUE = 10;
      /**
       * <pre>
       * Length-delimited aggregate.
       * </pre>
       *
       * <code>TYPE_MESSAGE = 11;</code>
       */
      public static final int TYPE_MESSAGE_VALUE = 11;
      /**
       * <pre>
       * New in version 2.
       * </pre>
       *
       * <code>TYPE_BYTES = 12;</code>
       */
      public static final int TYPE_BYTES_VALUE = 12;
      /**
       * <code>TYPE_UINT32 = 13;</code>
       */
      public static final int TYPE_UINT32_VALUE = 13;
      /**
       * <code>TYPE_ENUM = 14;</code>
       */
      public static final int TYPE_ENUM_VALUE = 14;
      /**
       * <code>TYPE_SFIXED32 = 15;</code>
       */
      public static final int TYPE_SFIXED32_VALUE = 15;
      /**
       * <code>TYPE_SFIXED64 = 16;</code>
       */
      public static final int TYPE_SFIXED64_VALUE = 16;
      /**
       * <pre>
       * Uses ZigZag encoding.
       * </pre>
       *
       * <code>TYPE_SINT32 = 17;</code>
       */
      public static final int TYPE_SINT32_VALUE = 17;
      /**
       * <pre>
       * Uses ZigZag encoding.
       * </pre>
       *
       * <code>TYPE_SINT64 = 18;</code>
       */
      public static final int TYPE_SINT64_VALUE = 18;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      public static Type forNumber(int value) {
        switch (value) {
          case 1: return TYPE_DOUBLE;
          case 2: return TYPE_FLOAT;
          case 3: return TYPE_INT64;
          case 4: return TYPE_UINT64;
          case 5: return TYPE_INT32;
          case 6: return TYPE_FIXED64;
          case 7: return TYPE_FIXED32;
          case 8: return TYPE_BOOL;
          case 9: return TYPE_STRING;
          case 10: return TYPE_GROUP;
          case 11: return TYPE_MESSAGE;
          case 12: return TYPE_BYTES;
          case 13: return TYPE_UINT32;
          case 14: return TYPE_ENUM;
          case 15: return TYPE_SFIXED32;
          case 16: return TYPE_SFIXED64;
          case 17: return TYPE_SINT32;
          case 18: return TYPE_SINT64;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              @java.lang.Override
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TypeVerifier.INSTANCE;
      }

      private static final class TypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Type.forNumber(number) != null;
              }
            };

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldDescriptorProto.Type)
    }

    /**
     * Protobuf enum {@code google.protobuf.FieldDescriptorProto.Label}
     */
    public enum Label
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * 0 is reserved for errors
       * </pre>
       *
       * <code>LABEL_OPTIONAL = 1;</code>
       */
      LABEL_OPTIONAL(1),
      /**
       * <code>LABEL_REQUIRED = 2;</code>
       */
      LABEL_REQUIRED(2),
      /**
       * <code>LABEL_REPEATED = 3;</code>
       */
      LABEL_REPEATED(3),
      ;

      /**
       * <pre>
       * 0 is reserved for errors
       * </pre>
       *
       * <code>LABEL_OPTIONAL = 1;</code>
       */
      public static final int LABEL_OPTIONAL_VALUE = 1;
      /**
       * <code>LABEL_REQUIRED = 2;</code>
       */
      public static final int LABEL_REQUIRED_VALUE = 2;
      /**
       * <code>LABEL_REPEATED = 3;</code>
       */
      public static final int LABEL_REPEATED_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Label valueOf(int value) {
        return forNumber(value);
      }

      public static Label forNumber(int value) {
        switch (value) {
          case 1: return LABEL_OPTIONAL;
          case 2: return LABEL_REQUIRED;
          case 3: return LABEL_REPEATED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Label>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Label> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Label>() {
              @java.lang.Override
              public Label findValueByNumber(int number) {
                return Label.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return LabelVerifier.INSTANCE;
      }

      private static final class LabelVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new LabelVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return Label.forNumber(number) != null;
              }
            };

      private final int value;

      private Label(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldDescriptorProto.Label)
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int NUMBER_FIELD_NUMBER = 3;
    private int number_;
    /**
     * <code>optional int32 number = 3;</code>
     * @return Whether the number field is set.
     */
    @java.lang.Override
    public boolean hasNumber() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 number = 3;</code>
     * @return The number.
     */
    @java.lang.Override
    public int getNumber() {
      return number_;
    }
    /**
     * <code>optional int32 number = 3;</code>
     * @param value The number to set.
     */
    private void setNumber(int value) {
      bitField0_ |= 0x00000002;
      number_ = value;
    }
    /**
     * <code>optional int32 number = 3;</code>
     */
    private void clearNumber() {
      bitField0_ = (bitField0_ & ~0x00000002);
      number_ = 0;
    }

    public static final int LABEL_FIELD_NUMBER = 4;
    private int label_;
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @return Whether the label field is set.
     */
    @java.lang.Override
    public boolean hasLabel() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @return The label.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label getLabel() {
      com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label result = com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label.forNumber(label_);
      return result == null ? com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label.LABEL_OPTIONAL : result;
    }
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     * @param value The label to set.
     */
    private void setLabel(com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label value) {
      label_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
     */
    private void clearLabel() {
      bitField0_ = (bitField0_ & ~0x00000004);
      label_ = 1;
    }

    public static final int TYPE_FIELD_NUMBER = 5;
    private int type_;
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @return The type.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type getType() {
      com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type result = com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type.forNumber(type_);
      return result == null ? com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type.TYPE_DOUBLE : result;
    }
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     * @param value The type to set.
     */
    private void setType(com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * If type_name is set, this need not be set.  If both this and type_name
     * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000008);
      type_ = 1;
    }

    public static final int TYPE_NAME_FIELD_NUMBER = 6;
    private java.lang.String typeName_;
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return Whether the typeName field is set.
     */
    @java.lang.Override
    public boolean hasTypeName() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return The typeName.
     */
    @java.lang.Override
    public java.lang.String getTypeName() {
      return typeName_;
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @return The bytes for typeName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(typeName_);
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @param value The typeName to set.
     */
    private void setTypeName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      typeName_ = value;
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     */
    private void clearTypeName() {
      bitField0_ = (bitField0_ & ~0x00000010);
      typeName_ = getDefaultInstance().getTypeName();
    }
    /**
     * <pre>
     * For message and enum types, this is the name of the type.  If the name
     * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
     * rules are used to find the type (i.e. first the nested types within this
     * message are searched, then within the parent, on up to the root
     * namespace).
     * </pre>
     *
     * <code>optional string type_name = 6;</code>
     * @param value The bytes for typeName to set.
     */
    private void setTypeNameBytes(
        com.google.protobuf.ByteString value) {
      typeName_ = value.toStringUtf8();
      bitField0_ |= 0x00000010;
    }

    public static final int EXTENDEE_FIELD_NUMBER = 2;
    private java.lang.String extendee_;
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return Whether the extendee field is set.
     */
    @java.lang.Override
    public boolean hasExtendee() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return The extendee.
     */
    @java.lang.Override
    public java.lang.String getExtendee() {
      return extendee_;
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @return The bytes for extendee.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExtendeeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(extendee_);
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @param value The extendee to set.
     */
    private void setExtendee(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000020;
      extendee_ = value;
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     */
    private void clearExtendee() {
      bitField0_ = (bitField0_ & ~0x00000020);
      extendee_ = getDefaultInstance().getExtendee();
    }
    /**
     * <pre>
     * For extensions, this is the name of the type being extended.  It is
     * resolved in the same manner as type_name.
     * </pre>
     *
     * <code>optional string extendee = 2;</code>
     * @param value The bytes for extendee to set.
     */
    private void setExtendeeBytes(
        com.google.protobuf.ByteString value) {
      extendee_ = value.toStringUtf8();
      bitField0_ |= 0x00000020;
    }

    public static final int DEFAULT_VALUE_FIELD_NUMBER = 7;
    private java.lang.String defaultValue_;
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return Whether the defaultValue field is set.
     */
    @java.lang.Override
    public boolean hasDefaultValue() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return The defaultValue.
     */
    @java.lang.Override
    public java.lang.String getDefaultValue() {
      return defaultValue_;
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @return The bytes for defaultValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDefaultValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(defaultValue_);
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @param value The defaultValue to set.
     */
    private void setDefaultValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000040;
      defaultValue_ = value;
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     */
    private void clearDefaultValue() {
      bitField0_ = (bitField0_ & ~0x00000040);
      defaultValue_ = getDefaultInstance().getDefaultValue();
    }
    /**
     * <pre>
     * For numeric types, contains the original text representation of the value.
     * For booleans, "true" or "false".
     * For strings, contains the default text contents (not escaped in any way).
     * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
     * </pre>
     *
     * <code>optional string default_value = 7;</code>
     * @param value The bytes for defaultValue to set.
     */
    private void setDefaultValueBytes(
        com.google.protobuf.ByteString value) {
      defaultValue_ = value.toStringUtf8();
      bitField0_ |= 0x00000040;
    }

    public static final int ONEOF_INDEX_FIELD_NUMBER = 9;
    private int oneofIndex_;
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @return Whether the oneofIndex field is set.
     */
    @java.lang.Override
    public boolean hasOneofIndex() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @return The oneofIndex.
     */
    @java.lang.Override
    public int getOneofIndex() {
      return oneofIndex_;
    }
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     * @param value The oneofIndex to set.
     */
    private void setOneofIndex(int value) {
      bitField0_ |= 0x00000080;
      oneofIndex_ = value;
    }
    /**
     * <pre>
     * If set, gives the index of a oneof in the containing type's oneof_decl
     * list.  This field is a member of that oneof.
     * </pre>
     *
     * <code>optional int32 oneof_index = 9;</code>
     */
    private void clearOneofIndex() {
      bitField0_ = (bitField0_ & ~0x00000080);
      oneofIndex_ = 0;
    }

    public static final int JSON_NAME_FIELD_NUMBER = 10;
    private java.lang.String jsonName_;
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return Whether the jsonName field is set.
     */
    @java.lang.Override
    public boolean hasJsonName() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return The jsonName.
     */
    @java.lang.Override
    public java.lang.String getJsonName() {
      return jsonName_;
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @return The bytes for jsonName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getJsonNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(jsonName_);
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @param value The jsonName to set.
     */
    private void setJsonName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000100;
      jsonName_ = value;
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     */
    private void clearJsonName() {
      bitField0_ = (bitField0_ & ~0x00000100);
      jsonName_ = getDefaultInstance().getJsonName();
    }
    /**
     * <pre>
     * JSON name of this field. The value is set by protocol compiler. If the
     * user has set a "json_name" option on this field, that option's value
     * will be used. Otherwise, it's deduced from the field's name by converting
     * it to camelCase.
     * </pre>
     *
     * <code>optional string json_name = 10;</code>
     * @param value The bytes for jsonName to set.
     */
    private void setJsonNameBytes(
        com.google.protobuf.ByteString value) {
      jsonName_ = value.toStringUtf8();
      bitField0_ |= 0x00000100;
    }

    public static final int OPTIONS_FIELD_NUMBER = 8;
    private com.google.protobuf.DescriptorProtos.FieldOptions options_;
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.FieldOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.FieldOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.FieldOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.FieldOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.FieldOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .google.protobuf.FieldOptions options = 8;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int PROTO3_OPTIONAL_FIELD_NUMBER = 17;
    private boolean proto3Optional_;
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @return Whether the proto3Optional field is set.
     */
    @java.lang.Override
    public boolean hasProto3Optional() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @return The proto3Optional.
     */
    @java.lang.Override
    public boolean getProto3Optional() {
      return proto3Optional_;
    }
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     * @param value The proto3Optional to set.
     */
    private void setProto3Optional(boolean value) {
      bitField0_ |= 0x00000400;
      proto3Optional_ = value;
    }
    /**
     * <pre>
     * If true, this is a proto3 "optional". When a proto3 field is optional, it
     * tracks presence regardless of field type.
     * When proto3_optional is true, this field must be belong to a oneof to
     * signal to old proto3 clients that presence is tracked for this field. This
     * oneof is known as a "synthetic" oneof, and this field must be its sole
     * member (each proto3 optional field gets its own synthetic oneof). Synthetic
     * oneofs exist in the descriptor only, and do not generate any API. Synthetic
     * oneofs must be ordered after all "real" oneofs.
     * For message fields, proto3_optional doesn't create any semantic change,
     * since non-repeated message fields always track presence. However it still
     * indicates the semantic detail of whether the user wrote "optional" or not.
     * This can be useful for round-tripping the .proto file. For consistency we
     * give message fields a synthetic oneof also, even though it is not required
     * to track presence. This is especially important because the parser can't
     * tell if a field is a message or an enum, so it must always create a
     * synthetic oneof.
     * Proto2 optional fields do not set this flag, because they already indicate
     * optional with `LABEL_OPTIONAL`.
     * </pre>
     *
     * <code>optional bool proto3_optional = 17;</code>
     */
    private void clearProto3Optional() {
      bitField0_ = (bitField0_ & ~0x00000400);
      proto3Optional_ = false;
    }

    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FieldDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a field within a message.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.FieldDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.FieldDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FieldDescriptorProto)
        com.google.protobuf.DescriptorProtos.FieldDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FieldDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>optional int32 number = 3;</code>
       * @return Whether the number field is set.
       */
      @java.lang.Override
      public boolean hasNumber() {
        return instance.hasNumber();
      }
      /**
       * <code>optional int32 number = 3;</code>
       * @return The number.
       */
      @java.lang.Override
      public int getNumber() {
        return instance.getNumber();
      }
      /**
       * <code>optional int32 number = 3;</code>
       * @param value The number to set.
       * @return This builder for chaining.
       */
      public Builder setNumber(int value) {
        copyOnWrite();
        instance.setNumber(value);
        return this;
      }
      /**
       * <code>optional int32 number = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumber() {
        copyOnWrite();
        instance.clearNumber();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
       * @return Whether the label field is set.
       */
      @java.lang.Override
      public boolean hasLabel() {
        return instance.hasLabel();
      }
      /**
       * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
       * @return The label.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label getLabel() {
        return instance.getLabel();
      }
      /**
       * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
       * @param value The enum numeric value on the wire for label to set.
       * @return This builder for chaining.
       */
      public Builder setLabel(com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FieldDescriptorProto.Label label = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }

      /**
       * <pre>
       * If type_name is set, this need not be set.  If both this and type_name
       * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <pre>
       * If type_name is set, this need not be set.  If both this and type_name
       * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
       * @return The type.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * If type_name is set, this need not be set.  If both this and type_name
       * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * If type_name is set, this need not be set.  If both this and type_name
       * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldDescriptorProto.Type type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @return Whether the typeName field is set.
       */
      @java.lang.Override
      public boolean hasTypeName() {
        return instance.hasTypeName();
      }
      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @return The typeName.
       */
      @java.lang.Override
      public java.lang.String getTypeName() {
        return instance.getTypeName();
      }
      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @return The bytes for typeName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTypeNameBytes() {
        return instance.getTypeNameBytes();
      }
      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @param value The typeName to set.
       * @return This builder for chaining.
       */
      public Builder setTypeName(
          java.lang.String value) {
        copyOnWrite();
        instance.setTypeName(value);
        return this;
      }
      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTypeName() {
        copyOnWrite();
        instance.clearTypeName();
        return this;
      }
      /**
       * <pre>
       * For message and enum types, this is the name of the type.  If the name
       * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
       * rules are used to find the type (i.e. first the nested types within this
       * message are searched, then within the parent, on up to the root
       * namespace).
       * </pre>
       *
       * <code>optional string type_name = 6;</code>
       * @param value The bytes for typeName to set.
       * @return This builder for chaining.
       */
      public Builder setTypeNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTypeNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @return Whether the extendee field is set.
       */
      @java.lang.Override
      public boolean hasExtendee() {
        return instance.hasExtendee();
      }
      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @return The extendee.
       */
      @java.lang.Override
      public java.lang.String getExtendee() {
        return instance.getExtendee();
      }
      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @return The bytes for extendee.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getExtendeeBytes() {
        return instance.getExtendeeBytes();
      }
      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @param value The extendee to set.
       * @return This builder for chaining.
       */
      public Builder setExtendee(
          java.lang.String value) {
        copyOnWrite();
        instance.setExtendee(value);
        return this;
      }
      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearExtendee() {
        copyOnWrite();
        instance.clearExtendee();
        return this;
      }
      /**
       * <pre>
       * For extensions, this is the name of the type being extended.  It is
       * resolved in the same manner as type_name.
       * </pre>
       *
       * <code>optional string extendee = 2;</code>
       * @param value The bytes for extendee to set.
       * @return This builder for chaining.
       */
      public Builder setExtendeeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setExtendeeBytes(value);
        return this;
      }

      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @return Whether the defaultValue field is set.
       */
      @java.lang.Override
      public boolean hasDefaultValue() {
        return instance.hasDefaultValue();
      }
      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @return The defaultValue.
       */
      @java.lang.Override
      public java.lang.String getDefaultValue() {
        return instance.getDefaultValue();
      }
      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @return The bytes for defaultValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDefaultValueBytes() {
        return instance.getDefaultValueBytes();
      }
      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @param value The defaultValue to set.
       * @return This builder for chaining.
       */
      public Builder setDefaultValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setDefaultValue(value);
        return this;
      }
      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDefaultValue() {
        copyOnWrite();
        instance.clearDefaultValue();
        return this;
      }
      /**
       * <pre>
       * For numeric types, contains the original text representation of the value.
       * For booleans, "true" or "false".
       * For strings, contains the default text contents (not escaped in any way).
       * For bytes, contains the C escaped value.  All bytes &gt;= 128 are escaped.
       * </pre>
       *
       * <code>optional string default_value = 7;</code>
       * @param value The bytes for defaultValue to set.
       * @return This builder for chaining.
       */
      public Builder setDefaultValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setDefaultValueBytes(value);
        return this;
      }

      /**
       * <pre>
       * If set, gives the index of a oneof in the containing type's oneof_decl
       * list.  This field is a member of that oneof.
       * </pre>
       *
       * <code>optional int32 oneof_index = 9;</code>
       * @return Whether the oneofIndex field is set.
       */
      @java.lang.Override
      public boolean hasOneofIndex() {
        return instance.hasOneofIndex();
      }
      /**
       * <pre>
       * If set, gives the index of a oneof in the containing type's oneof_decl
       * list.  This field is a member of that oneof.
       * </pre>
       *
       * <code>optional int32 oneof_index = 9;</code>
       * @return The oneofIndex.
       */
      @java.lang.Override
      public int getOneofIndex() {
        return instance.getOneofIndex();
      }
      /**
       * <pre>
       * If set, gives the index of a oneof in the containing type's oneof_decl
       * list.  This field is a member of that oneof.
       * </pre>
       *
       * <code>optional int32 oneof_index = 9;</code>
       * @param value The oneofIndex to set.
       * @return This builder for chaining.
       */
      public Builder setOneofIndex(int value) {
        copyOnWrite();
        instance.setOneofIndex(value);
        return this;
      }
      /**
       * <pre>
       * If set, gives the index of a oneof in the containing type's oneof_decl
       * list.  This field is a member of that oneof.
       * </pre>
       *
       * <code>optional int32 oneof_index = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearOneofIndex() {
        copyOnWrite();
        instance.clearOneofIndex();
        return this;
      }

      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @return Whether the jsonName field is set.
       */
      @java.lang.Override
      public boolean hasJsonName() {
        return instance.hasJsonName();
      }
      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @return The jsonName.
       */
      @java.lang.Override
      public java.lang.String getJsonName() {
        return instance.getJsonName();
      }
      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @return The bytes for jsonName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getJsonNameBytes() {
        return instance.getJsonNameBytes();
      }
      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @param value The jsonName to set.
       * @return This builder for chaining.
       */
      public Builder setJsonName(
          java.lang.String value) {
        copyOnWrite();
        instance.setJsonName(value);
        return this;
      }
      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearJsonName() {
        copyOnWrite();
        instance.clearJsonName();
        return this;
      }
      /**
       * <pre>
       * JSON name of this field. The value is set by protocol compiler. If the
       * user has set a "json_name" option on this field, that option's value
       * will be used. Otherwise, it's deduced from the field's name by converting
       * it to camelCase.
       * </pre>
       *
       * <code>optional string json_name = 10;</code>
       * @param value The bytes for jsonName to set.
       * @return This builder for chaining.
       */
      public Builder setJsonNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setJsonNameBytes(value);
        return this;
      }

      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.FieldOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.FieldOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.FieldOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FieldOptions options = 8;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      /**
       * <pre>
       * If true, this is a proto3 "optional". When a proto3 field is optional, it
       * tracks presence regardless of field type.
       * When proto3_optional is true, this field must be belong to a oneof to
       * signal to old proto3 clients that presence is tracked for this field. This
       * oneof is known as a "synthetic" oneof, and this field must be its sole
       * member (each proto3 optional field gets its own synthetic oneof). Synthetic
       * oneofs exist in the descriptor only, and do not generate any API. Synthetic
       * oneofs must be ordered after all "real" oneofs.
       * For message fields, proto3_optional doesn't create any semantic change,
       * since non-repeated message fields always track presence. However it still
       * indicates the semantic detail of whether the user wrote "optional" or not.
       * This can be useful for round-tripping the .proto file. For consistency we
       * give message fields a synthetic oneof also, even though it is not required
       * to track presence. This is especially important because the parser can't
       * tell if a field is a message or an enum, so it must always create a
       * synthetic oneof.
       * Proto2 optional fields do not set this flag, because they already indicate
       * optional with `LABEL_OPTIONAL`.
       * </pre>
       *
       * <code>optional bool proto3_optional = 17;</code>
       * @return Whether the proto3Optional field is set.
       */
      @java.lang.Override
      public boolean hasProto3Optional() {
        return instance.hasProto3Optional();
      }
      /**
       * <pre>
       * If true, this is a proto3 "optional". When a proto3 field is optional, it
       * tracks presence regardless of field type.
       * When proto3_optional is true, this field must be belong to a oneof to
       * signal to old proto3 clients that presence is tracked for this field. This
       * oneof is known as a "synthetic" oneof, and this field must be its sole
       * member (each proto3 optional field gets its own synthetic oneof). Synthetic
       * oneofs exist in the descriptor only, and do not generate any API. Synthetic
       * oneofs must be ordered after all "real" oneofs.
       * For message fields, proto3_optional doesn't create any semantic change,
       * since non-repeated message fields always track presence. However it still
       * indicates the semantic detail of whether the user wrote "optional" or not.
       * This can be useful for round-tripping the .proto file. For consistency we
       * give message fields a synthetic oneof also, even though it is not required
       * to track presence. This is especially important because the parser can't
       * tell if a field is a message or an enum, so it must always create a
       * synthetic oneof.
       * Proto2 optional fields do not set this flag, because they already indicate
       * optional with `LABEL_OPTIONAL`.
       * </pre>
       *
       * <code>optional bool proto3_optional = 17;</code>
       * @return The proto3Optional.
       */
      @java.lang.Override
      public boolean getProto3Optional() {
        return instance.getProto3Optional();
      }
      /**
       * <pre>
       * If true, this is a proto3 "optional". When a proto3 field is optional, it
       * tracks presence regardless of field type.
       * When proto3_optional is true, this field must be belong to a oneof to
       * signal to old proto3 clients that presence is tracked for this field. This
       * oneof is known as a "synthetic" oneof, and this field must be its sole
       * member (each proto3 optional field gets its own synthetic oneof). Synthetic
       * oneofs exist in the descriptor only, and do not generate any API. Synthetic
       * oneofs must be ordered after all "real" oneofs.
       * For message fields, proto3_optional doesn't create any semantic change,
       * since non-repeated message fields always track presence. However it still
       * indicates the semantic detail of whether the user wrote "optional" or not.
       * This can be useful for round-tripping the .proto file. For consistency we
       * give message fields a synthetic oneof also, even though it is not required
       * to track presence. This is especially important because the parser can't
       * tell if a field is a message or an enum, so it must always create a
       * synthetic oneof.
       * Proto2 optional fields do not set this flag, because they already indicate
       * optional with `LABEL_OPTIONAL`.
       * </pre>
       *
       * <code>optional bool proto3_optional = 17;</code>
       * @param value The proto3Optional to set.
       * @return This builder for chaining.
       */
      public Builder setProto3Optional(boolean value) {
        copyOnWrite();
        instance.setProto3Optional(value);
        return this;
      }
      /**
       * <pre>
       * If true, this is a proto3 "optional". When a proto3 field is optional, it
       * tracks presence regardless of field type.
       * When proto3_optional is true, this field must be belong to a oneof to
       * signal to old proto3 clients that presence is tracked for this field. This
       * oneof is known as a "synthetic" oneof, and this field must be its sole
       * member (each proto3 optional field gets its own synthetic oneof). Synthetic
       * oneofs exist in the descriptor only, and do not generate any API. Synthetic
       * oneofs must be ordered after all "real" oneofs.
       * For message fields, proto3_optional doesn't create any semantic change,
       * since non-repeated message fields always track presence. However it still
       * indicates the semantic detail of whether the user wrote "optional" or not.
       * This can be useful for round-tripping the .proto file. For consistency we
       * give message fields a synthetic oneof also, even though it is not required
       * to track presence. This is especially important because the parser can't
       * tell if a field is a message or an enum, so it must always create a
       * synthetic oneof.
       * Proto2 optional fields do not set this flag, because they already indicate
       * optional with `LABEL_OPTIONAL`.
       * </pre>
       *
       * <code>optional bool proto3_optional = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearProto3Optional() {
        copyOnWrite();
        instance.clearProto3Optional();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FieldDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FieldDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "extendee_",
              "number_",
              "label_",
              com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Label.internalGetVerifier(),
              "type_",
              com.google.protobuf.DescriptorProtos.FieldDescriptorProto.Type.internalGetVerifier(),
              "typeName_",
              "defaultValue_",
              "options_",
              "oneofIndex_",
              "jsonName_",
              "proto3Optional_",
            };
            java.lang.String info =
                "\u0001\u000b\u0000\u0001\u0001\u0011\u000b\u0000\u0000\u0001\u0001\u1008\u0000\u0002" +
                "\u1008\u0005\u0003\u1004\u0001\u0004\u100c\u0002\u0005\u100c\u0003\u0006\u1008\u0004" +
                "\u0007\u1008\u0006\b\u1409\t\t\u1004\u0007\n\u1008\b\u0011\u1007\n";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FieldDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FieldDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FieldDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FieldDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.FieldDescriptorProto DEFAULT_INSTANCE;
    static {
      FieldDescriptorProto defaultInstance = new FieldDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FieldDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FieldDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FieldDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<FieldDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OneofDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.OneofDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.OneofOptions getOptions();
  }
  /**
   * <pre>
   * Describes a oneof.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.OneofDescriptorProto}
   */
  public  static final class OneofDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          OneofDescriptorProto, OneofDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.OneofDescriptorProto)
      OneofDescriptorProtoOrBuilder {
    private OneofDescriptorProto() {
      name_ = "";
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int OPTIONS_FIELD_NUMBER = 2;
    private com.google.protobuf.DescriptorProtos.OneofOptions options_;
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.OneofOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.OneofOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.OneofOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.OneofOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.OneofOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.OneofOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.OneofOptions options = 2;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.OneofDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a oneof.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.OneofDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.OneofDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.OneofDescriptorProto)
        com.google.protobuf.DescriptorProtos.OneofDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.OneofDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.OneofOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.OneofOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.OneofOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.OneofOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.OneofOptions options = 2;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.OneofDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.OneofDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "options_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0001\u0001\u1008\u0000\u0002" +
                "\u1409\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.OneofDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.OneofDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.OneofDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.OneofDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.OneofDescriptorProto DEFAULT_INSTANCE;
    static {
      OneofDescriptorProto defaultInstance = new OneofDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OneofDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.OneofDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OneofDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<OneofDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EnumDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.EnumDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> 
        getValueList();
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto getValue(int index);
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    int getValueCount();

    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.EnumOptions getOptions();

    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> 
        getReservedRangeList();
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange getReservedRange(int index);
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    int getReservedRangeCount();

    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @return A list containing the reservedName.
     */
    java.util.List<java.lang.String>
        getReservedNameList();
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @return The count of reservedName.
     */
    int getReservedNameCount();
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    java.lang.String getReservedName(int index);
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    com.google.protobuf.ByteString
        getReservedNameBytes(int index);
  }
  /**
   * <pre>
   * Describes an enum type.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.EnumDescriptorProto}
   */
  public  static final class EnumDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          EnumDescriptorProto, EnumDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.EnumDescriptorProto)
      EnumDescriptorProtoOrBuilder {
    private EnumDescriptorProto() {
      name_ = "";
      value_ = emptyProtobufList();
      reservedRange_ = emptyProtobufList();
      reservedName_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    public interface EnumReservedRangeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.EnumDescriptorProto.EnumReservedRange)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      boolean hasStart();
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      int getStart();

      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      boolean hasEnd();
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      int getEnd();
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved values may not be used by
     * entries in the same enum. Reserved ranges may not overlap.
     * Note that this is distinct from DescriptorProto.ReservedRange in that it
     * is inclusive such that it can appropriately represent the entire int32
     * domain.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.EnumDescriptorProto.EnumReservedRange}
     */
    public  static final class EnumReservedRange extends
        com.google.protobuf.GeneratedMessageLite<
            EnumReservedRange, EnumReservedRange.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.EnumDescriptorProto.EnumReservedRange)
        EnumReservedRangeOrBuilder {
      private EnumReservedRange() {
      }
      private int bitField0_;
      public static final int START_FIELD_NUMBER = 1;
      private int start_;
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public int getStart() {
        return start_;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @param value The start to set.
       */
      private void setStart(int value) {
        bitField0_ |= 0x00000001;
        start_ = value;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       */
      private void clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0;
      }

      public static final int END_FIELD_NUMBER = 2;
      private int end_;
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public int getEnd() {
        return end_;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @param value The end to set.
       */
      private void setEnd(int value) {
        bitField0_ |= 0x00000002;
        end_ = value;
      }
      /**
       * <pre>
       * Inclusive.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       */
      private void clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000002);
        end_ = 0;
      }

      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * Range of reserved numeric values. Reserved values may not be used by
       * entries in the same enum. Reserved ranges may not overlap.
       * Note that this is distinct from DescriptorProto.ReservedRange in that it
       * is inclusive such that it can appropriately represent the entire int32
       * domain.
       * </pre>
       *
       * Protobuf type {@code google.protobuf.EnumDescriptorProto.EnumReservedRange}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.EnumDescriptorProto.EnumReservedRange)
          com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRangeOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return Whether the start field is set.
         */
        @java.lang.Override
        public boolean hasStart() {
          return instance.hasStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return The start.
         */
        @java.lang.Override
        public int getStart() {
          return instance.getStart();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @param value The start to set.
         * @return This builder for chaining.
         */
        public Builder setStart(int value) {
          copyOnWrite();
          instance.setStart(value);
          return this;
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 start = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearStart() {
          copyOnWrite();
          instance.clearStart();
          return this;
        }

        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return Whether the end field is set.
         */
        @java.lang.Override
        public boolean hasEnd() {
          return instance.hasEnd();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return The end.
         */
        @java.lang.Override
        public int getEnd() {
          return instance.getEnd();
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @param value The end to set.
         * @return This builder for chaining.
         */
        public Builder setEnd(int value) {
          copyOnWrite();
          instance.setEnd(value);
          return this;
        }
        /**
         * <pre>
         * Inclusive.
         * </pre>
         *
         * <code>optional int32 end = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnd() {
          copyOnWrite();
          instance.clearEnd();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.EnumDescriptorProto.EnumReservedRange)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "start_",
                "end_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                  "\u1004\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.EnumDescriptorProto.EnumReservedRange)
      private static final com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange DEFAULT_INSTANCE;
      static {
        EnumReservedRange defaultInstance = new EnumReservedRange();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          EnumReservedRange.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<EnumReservedRange> PARSER;

      public static com.google.protobuf.Parser<EnumReservedRange> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> value_;
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> getValueList() {
      return value_;
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.EnumValueDescriptorProtoOrBuilder> 
        getValueOrBuilderList() {
      return value_;
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    @java.lang.Override
    public int getValueCount() {
      return value_.size();
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto getValue(int index) {
      return value_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    public com.google.protobuf.DescriptorProtos.EnumValueDescriptorProtoOrBuilder getValueOrBuilder(
        int index) {
      return value_.get(index);
    }
    private void ensureValueIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> tmp = value_;
      if (!tmp.isModifiable()) {
        value_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void setValue(
        int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
      value.getClass();
  ensureValueIsMutable();
      value_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void addValue(com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
      value.getClass();
  ensureValueIsMutable();
      value_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void addValue(
        int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
      value.getClass();
  ensureValueIsMutable();
      value_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void addAllValue(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> values) {
      ensureValueIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, value_);
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void clearValue() {
      value_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
     */
    private void removeValue(int index) {
      ensureValueIsMutable();
      value_.remove(index);
    }

    public static final int OPTIONS_FIELD_NUMBER = 3;
    private com.google.protobuf.DescriptorProtos.EnumOptions options_;
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.EnumOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.EnumOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.EnumOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.EnumOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.EnumOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.EnumOptions options = 3;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int RESERVED_RANGE_FIELD_NUMBER = 4;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> reservedRange_;
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> getReservedRangeList() {
      return reservedRange_;
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRangeOrBuilder> 
        getReservedRangeOrBuilderList() {
      return reservedRange_;
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    @java.lang.Override
    public int getReservedRangeCount() {
      return reservedRange_.size();
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange getReservedRange(int index) {
      return reservedRange_.get(index);
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    public com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRangeOrBuilder getReservedRangeOrBuilder(
        int index) {
      return reservedRange_.get(index);
    }
    private void ensureReservedRangeIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> tmp = reservedRange_;
      if (!tmp.isModifiable()) {
        reservedRange_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void setReservedRange(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.set(index, value);
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void addReservedRange(com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.add(value);
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void addReservedRange(
        int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
      value.getClass();
  ensureReservedRangeIsMutable();
      reservedRange_.add(index, value);
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void addAllReservedRange(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> values) {
      ensureReservedRangeIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, reservedRange_);
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void clearReservedRange() {
      reservedRange_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Range of reserved numeric values. Reserved numeric values may not be used
     * by enum values in the same enum declaration. Reserved ranges may not
     * overlap.
     * </pre>
     *
     * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
     */
    private void removeReservedRange(int index) {
      ensureReservedRangeIsMutable();
      reservedRange_.remove(index);
    }

    public static final int RESERVED_NAME_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<java.lang.String> reservedName_;
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @return A list containing the reservedName.
     */
    @java.lang.Override
    public java.util.List<java.lang.String> getReservedNameList() {
      return reservedName_;
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @return The count of reservedName.
     */
    @java.lang.Override
    public int getReservedNameCount() {
      return reservedName_.size();
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param index The index of the element to return.
     * @return The reservedName at the given index.
     */
    @java.lang.Override
    public java.lang.String getReservedName(int index) {
      return reservedName_.get(index);
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the reservedName at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getReservedNameBytes(int index) {
      return com.google.protobuf.ByteString.copyFromUtf8(
          reservedName_.get(index));
    }
    private void ensureReservedNameIsMutable() {
      com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
          reservedName_;  if (!tmp.isModifiable()) {
        reservedName_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param index The index to set the value at.
     * @param value The reservedName to set.
     */
    private void setReservedName(
        int index, java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureReservedNameIsMutable();
      reservedName_.set(index, value);
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param value The reservedName to add.
     */
    private void addReservedName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  ensureReservedNameIsMutable();
      reservedName_.add(value);
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param values The reservedName to add.
     */
    private void addAllReservedName(
        java.lang.Iterable<java.lang.String> values) {
      ensureReservedNameIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, reservedName_);
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     */
    private void clearReservedName() {
      reservedName_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    }
    /**
     * <pre>
     * Reserved enum value names, which may not be reused. A given name may only
     * be reserved once.
     * </pre>
     *
     * <code>repeated string reserved_name = 5;</code>
     * @param value The bytes of the reservedName to add.
     */
    private void addReservedNameBytes(
        com.google.protobuf.ByteString value) {
      ensureReservedNameIsMutable();
      reservedName_.add(value.toStringUtf8());
    }

    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.EnumDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes an enum type.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.EnumDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.EnumDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.EnumDescriptorProto)
        com.google.protobuf.DescriptorProtos.EnumDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.EnumDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> getValueList() {
        return java.util.Collections.unmodifiableList(
            instance.getValueList());
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      @java.lang.Override
      public int getValueCount() {
        return instance.getValueCount();
      }/**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto getValue(int index) {
        return instance.getValue(index);
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder setValue(
          int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
        copyOnWrite();
        instance.setValue(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder setValue(
          int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setValue(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder addValue(com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
        copyOnWrite();
        instance.addValue(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder addValue(
          int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto value) {
        copyOnWrite();
        instance.addValue(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder addValue(
          com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addValue(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder addValue(
          int index, com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addValue(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder addAllValue(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> values) {
        copyOnWrite();
        instance.addAllValue(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.EnumValueDescriptorProto value = 2;</code>
       */
      public Builder removeValue(int index) {
        copyOnWrite();
        instance.removeValue(index);
        return this;
      }

      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.EnumOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.EnumOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.EnumOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.EnumOptions options = 3;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> getReservedRangeList() {
        return java.util.Collections.unmodifiableList(
            instance.getReservedRangeList());
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      @java.lang.Override
      public int getReservedRangeCount() {
        return instance.getReservedRangeCount();
      }/**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange getReservedRange(int index) {
        return instance.getReservedRange(index);
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder setReservedRange(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
        copyOnWrite();
        instance.setReservedRange(index, value);
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder setReservedRange(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.setReservedRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder addReservedRange(com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
        copyOnWrite();
        instance.addReservedRange(value);
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder addReservedRange(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange value) {
        copyOnWrite();
        instance.addReservedRange(index, value);
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder addReservedRange(
          com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.addReservedRange(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder addReservedRange(
          int index, com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.Builder builderForValue) {
        copyOnWrite();
        instance.addReservedRange(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder addAllReservedRange(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange> values) {
        copyOnWrite();
        instance.addAllReservedRange(values);
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder clearReservedRange() {
        copyOnWrite();
        instance.clearReservedRange();
        return this;
      }
      /**
       * <pre>
       * Range of reserved numeric values. Reserved numeric values may not be used
       * by enum values in the same enum declaration. Reserved ranges may not
       * overlap.
       * </pre>
       *
       * <code>repeated .google.protobuf.EnumDescriptorProto.EnumReservedRange reserved_range = 4;</code>
       */
      public Builder removeReservedRange(int index) {
        copyOnWrite();
        instance.removeReservedRange(index);
        return this;
      }

      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @return A list containing the reservedName.
       */
      @java.lang.Override
      public java.util.List<java.lang.String>
          getReservedNameList() {
        return java.util.Collections.unmodifiableList(
            instance.getReservedNameList());
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @return The count of reservedName.
       */
      @java.lang.Override
      public int getReservedNameCount() {
        return instance.getReservedNameCount();
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param index The index of the element to return.
       * @return The reservedName at the given index.
       */
      @java.lang.Override
      public java.lang.String getReservedName(int index) {
        return instance.getReservedName(index);
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the reservedName at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getReservedNameBytes(int index) {
        return instance.getReservedNameBytes(index);
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param index The index to set the value at.
       * @param value The reservedName to set.
       * @return This builder for chaining.
       */
      public Builder setReservedName(
          int index, java.lang.String value) {
        copyOnWrite();
        instance.setReservedName(index, value);
        return this;
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param value The reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addReservedName(
          java.lang.String value) {
        copyOnWrite();
        instance.addReservedName(value);
        return this;
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param values The reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addAllReservedName(
          java.lang.Iterable<java.lang.String> values) {
        copyOnWrite();
        instance.addAllReservedName(values);
        return this;
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearReservedName() {
        copyOnWrite();
        instance.clearReservedName();
        return this;
      }
      /**
       * <pre>
       * Reserved enum value names, which may not be reused. A given name may only
       * be reserved once.
       * </pre>
       *
       * <code>repeated string reserved_name = 5;</code>
       * @param value The bytes of the reservedName to add.
       * @return This builder for chaining.
       */
      public Builder addReservedNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.addReservedNameBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.EnumDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.EnumDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "value_",
              com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.class,
              "options_",
              "reservedRange_",
              com.google.protobuf.DescriptorProtos.EnumDescriptorProto.EnumReservedRange.class,
              "reservedName_",
            };
            java.lang.String info =
                "\u0001\u0005\u0000\u0001\u0001\u0005\u0005\u0000\u0003\u0002\u0001\u1008\u0000\u0002" +
                "\u041b\u0003\u1409\u0001\u0004\u001b\u0005\u001a";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.EnumDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.EnumDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.EnumDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.EnumDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.EnumDescriptorProto DEFAULT_INSTANCE;
    static {
      EnumDescriptorProto defaultInstance = new EnumDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EnumDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.EnumDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EnumDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<EnumDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EnumValueDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.EnumValueDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>optional int32 number = 2;</code>
     * @return Whether the number field is set.
     */
    boolean hasNumber();
    /**
     * <code>optional int32 number = 2;</code>
     * @return The number.
     */
    int getNumber();

    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.EnumValueOptions getOptions();
  }
  /**
   * <pre>
   * Describes a value within an enum.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.EnumValueDescriptorProto}
   */
  public  static final class EnumValueDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          EnumValueDescriptorProto, EnumValueDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.EnumValueDescriptorProto)
      EnumValueDescriptorProtoOrBuilder {
    private EnumValueDescriptorProto() {
      name_ = "";
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int NUMBER_FIELD_NUMBER = 2;
    private int number_;
    /**
     * <code>optional int32 number = 2;</code>
     * @return Whether the number field is set.
     */
    @java.lang.Override
    public boolean hasNumber() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 number = 2;</code>
     * @return The number.
     */
    @java.lang.Override
    public int getNumber() {
      return number_;
    }
    /**
     * <code>optional int32 number = 2;</code>
     * @param value The number to set.
     */
    private void setNumber(int value) {
      bitField0_ |= 0x00000002;
      number_ = value;
    }
    /**
     * <code>optional int32 number = 2;</code>
     */
    private void clearNumber() {
      bitField0_ = (bitField0_ & ~0x00000002);
      number_ = 0;
    }

    public static final int OPTIONS_FIELD_NUMBER = 3;
    private com.google.protobuf.DescriptorProtos.EnumValueOptions options_;
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.EnumValueOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.EnumValueOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.EnumValueOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.EnumValueOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.EnumValueOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.EnumValueOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a value within an enum.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.EnumValueDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.EnumValueDescriptorProto)
        com.google.protobuf.DescriptorProtos.EnumValueDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>optional int32 number = 2;</code>
       * @return Whether the number field is set.
       */
      @java.lang.Override
      public boolean hasNumber() {
        return instance.hasNumber();
      }
      /**
       * <code>optional int32 number = 2;</code>
       * @return The number.
       */
      @java.lang.Override
      public int getNumber() {
        return instance.getNumber();
      }
      /**
       * <code>optional int32 number = 2;</code>
       * @param value The number to set.
       * @return This builder for chaining.
       */
      public Builder setNumber(int value) {
        copyOnWrite();
        instance.setNumber(value);
        return this;
      }
      /**
       * <code>optional int32 number = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumber() {
        copyOnWrite();
        instance.clearNumber();
        return this;
      }

      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.EnumValueOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.EnumValueOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.EnumValueOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.EnumValueOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.EnumValueOptions options = 3;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.EnumValueDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "number_",
              "options_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0001\u0001\u1008\u0000\u0002" +
                "\u1004\u0001\u0003\u1409\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.EnumValueDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto DEFAULT_INSTANCE;
    static {
      EnumValueDescriptorProto defaultInstance = new EnumValueDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EnumValueDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.EnumValueDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EnumValueDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<EnumValueDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ServiceDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.ServiceDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> 
        getMethodList();
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    com.google.protobuf.DescriptorProtos.MethodDescriptorProto getMethod(int index);
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    int getMethodCount();

    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.ServiceOptions getOptions();
  }
  /**
   * <pre>
   * Describes a service.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.ServiceDescriptorProto}
   */
  public  static final class ServiceDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          ServiceDescriptorProto, ServiceDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.ServiceDescriptorProto)
      ServiceDescriptorProtoOrBuilder {
    private ServiceDescriptorProto() {
      name_ = "";
      method_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int METHOD_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> method_;
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> getMethodList() {
      return method_;
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.MethodDescriptorProtoOrBuilder> 
        getMethodOrBuilderList() {
      return method_;
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    @java.lang.Override
    public int getMethodCount() {
      return method_.size();
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.MethodDescriptorProto getMethod(int index) {
      return method_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    public com.google.protobuf.DescriptorProtos.MethodDescriptorProtoOrBuilder getMethodOrBuilder(
        int index) {
      return method_.get(index);
    }
    private void ensureMethodIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> tmp = method_;
      if (!tmp.isModifiable()) {
        method_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void setMethod(
        int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
      value.getClass();
  ensureMethodIsMutable();
      method_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void addMethod(com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
      value.getClass();
  ensureMethodIsMutable();
      method_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void addMethod(
        int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
      value.getClass();
  ensureMethodIsMutable();
      method_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void addAllMethod(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.MethodDescriptorProto> values) {
      ensureMethodIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, method_);
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void clearMethod() {
      method_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
     */
    private void removeMethod(int index) {
      ensureMethodIsMutable();
      method_.remove(index);
    }

    public static final int OPTIONS_FIELD_NUMBER = 3;
    private com.google.protobuf.DescriptorProtos.ServiceOptions options_;
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.ServiceOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.ServiceOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.ServiceOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.ServiceOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.ServiceOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.ServiceOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.ServiceDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a service.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.ServiceDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.ServiceDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.ServiceDescriptorProto)
        com.google.protobuf.DescriptorProtos.ServiceDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> getMethodList() {
        return java.util.Collections.unmodifiableList(
            instance.getMethodList());
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      @java.lang.Override
      public int getMethodCount() {
        return instance.getMethodCount();
      }/**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.MethodDescriptorProto getMethod(int index) {
        return instance.getMethod(index);
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder setMethod(
          int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
        copyOnWrite();
        instance.setMethod(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder setMethod(
          int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.setMethod(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder addMethod(com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
        copyOnWrite();
        instance.addMethod(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder addMethod(
          int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto value) {
        copyOnWrite();
        instance.addMethod(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder addMethod(
          com.google.protobuf.DescriptorProtos.MethodDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addMethod(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder addMethod(
          int index, com.google.protobuf.DescriptorProtos.MethodDescriptorProto.Builder builderForValue) {
        copyOnWrite();
        instance.addMethod(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder addAllMethod(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.MethodDescriptorProto> values) {
        copyOnWrite();
        instance.addAllMethod(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder clearMethod() {
        copyOnWrite();
        instance.clearMethod();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.MethodDescriptorProto method = 2;</code>
       */
      public Builder removeMethod(int index) {
        copyOnWrite();
        instance.removeMethod(index);
        return this;
      }

      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.ServiceOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.ServiceOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.ServiceOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.ServiceOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.ServiceOptions options = 3;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.ServiceDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.ServiceDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "method_",
              com.google.protobuf.DescriptorProtos.MethodDescriptorProto.class,
              "options_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0001\u0002\u0001\u1008\u0000\u0002" +
                "\u041b\u0003\u1409\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.ServiceDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.ServiceDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.ServiceDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.ServiceDescriptorProto DEFAULT_INSTANCE;
    static {
      ServiceDescriptorProto defaultInstance = new ServiceDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ServiceDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.ServiceDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ServiceDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<ServiceDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MethodDescriptorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.MethodDescriptorProto)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return Whether the inputType field is set.
     */
    boolean hasInputType();
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return The inputType.
     */
    java.lang.String getInputType();
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return The bytes for inputType.
     */
    com.google.protobuf.ByteString
        getInputTypeBytes();

    /**
     * <code>optional string output_type = 3;</code>
     * @return Whether the outputType field is set.
     */
    boolean hasOutputType();
    /**
     * <code>optional string output_type = 3;</code>
     * @return The outputType.
     */
    java.lang.String getOutputType();
    /**
     * <code>optional string output_type = 3;</code>
     * @return The bytes for outputType.
     */
    com.google.protobuf.ByteString
        getOutputTypeBytes();

    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     * @return Whether the options field is set.
     */
    boolean hasOptions();
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     * @return The options.
     */
    com.google.protobuf.DescriptorProtos.MethodOptions getOptions();

    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     * @return Whether the clientStreaming field is set.
     */
    boolean hasClientStreaming();
    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     * @return The clientStreaming.
     */
    boolean getClientStreaming();

    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     * @return Whether the serverStreaming field is set.
     */
    boolean hasServerStreaming();
    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     * @return The serverStreaming.
     */
    boolean getServerStreaming();
  }
  /**
   * <pre>
   * Describes a method of a service.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.MethodDescriptorProto}
   */
  public  static final class MethodDescriptorProto extends
      com.google.protobuf.GeneratedMessageLite<
          MethodDescriptorProto, MethodDescriptorProto.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.MethodDescriptorProto)
      MethodDescriptorProtoOrBuilder {
    private MethodDescriptorProto() {
      name_ = "";
      inputType_ = "";
      outputType_ = "";
    }
    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.String name_;
    /**
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      return name_;
    }
    /**
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The name to set.
     */
    private void setName(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      name_ = value;
    }
    /**
     * <code>optional string name = 1;</code>
     */
    private void clearName() {
      bitField0_ = (bitField0_ & ~0x00000001);
      name_ = getDefaultInstance().getName();
    }
    /**
     * <code>optional string name = 1;</code>
     * @param value The bytes for name to set.
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      name_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int INPUT_TYPE_FIELD_NUMBER = 2;
    private java.lang.String inputType_;
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return Whether the inputType field is set.
     */
    @java.lang.Override
    public boolean hasInputType() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return The inputType.
     */
    @java.lang.Override
    public java.lang.String getInputType() {
      return inputType_;
    }
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @return The bytes for inputType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInputTypeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(inputType_);
    }
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @param value The inputType to set.
     */
    private void setInputType(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      inputType_ = value;
    }
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     */
    private void clearInputType() {
      bitField0_ = (bitField0_ & ~0x00000002);
      inputType_ = getDefaultInstance().getInputType();
    }
    /**
     * <pre>
     * Input and output type names.  These are resolved in the same way as
     * FieldDescriptorProto.type_name, but must refer to a message type.
     * </pre>
     *
     * <code>optional string input_type = 2;</code>
     * @param value The bytes for inputType to set.
     */
    private void setInputTypeBytes(
        com.google.protobuf.ByteString value) {
      inputType_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int OUTPUT_TYPE_FIELD_NUMBER = 3;
    private java.lang.String outputType_;
    /**
     * <code>optional string output_type = 3;</code>
     * @return Whether the outputType field is set.
     */
    @java.lang.Override
    public boolean hasOutputType() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string output_type = 3;</code>
     * @return The outputType.
     */
    @java.lang.Override
    public java.lang.String getOutputType() {
      return outputType_;
    }
    /**
     * <code>optional string output_type = 3;</code>
     * @return The bytes for outputType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOutputTypeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(outputType_);
    }
    /**
     * <code>optional string output_type = 3;</code>
     * @param value The outputType to set.
     */
    private void setOutputType(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      outputType_ = value;
    }
    /**
     * <code>optional string output_type = 3;</code>
     */
    private void clearOutputType() {
      bitField0_ = (bitField0_ & ~0x00000004);
      outputType_ = getDefaultInstance().getOutputType();
    }
    /**
     * <code>optional string output_type = 3;</code>
     * @param value The bytes for outputType to set.
     */
    private void setOutputTypeBytes(
        com.google.protobuf.ByteString value) {
      outputType_ = value.toStringUtf8();
      bitField0_ |= 0x00000004;
    }

    public static final int OPTIONS_FIELD_NUMBER = 4;
    private com.google.protobuf.DescriptorProtos.MethodOptions options_;
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     */
    @java.lang.Override
    public boolean hasOptions() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.MethodOptions getOptions() {
      return options_ == null ? com.google.protobuf.DescriptorProtos.MethodOptions.getDefaultInstance() : options_;
    }
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     */
    private void setOptions(com.google.protobuf.DescriptorProtos.MethodOptions value) {
      value.getClass();
  options_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeOptions(com.google.protobuf.DescriptorProtos.MethodOptions value) {
      value.getClass();
  if (options_ != null &&
          options_ != com.google.protobuf.DescriptorProtos.MethodOptions.getDefaultInstance()) {
        options_ =
          com.google.protobuf.DescriptorProtos.MethodOptions.newBuilder(options_).mergeFrom(value).buildPartial();
      } else {
        options_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .google.protobuf.MethodOptions options = 4;</code>
     */
    private void clearOptions() {  options_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int CLIENT_STREAMING_FIELD_NUMBER = 5;
    private boolean clientStreaming_;
    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     * @return Whether the clientStreaming field is set.
     */
    @java.lang.Override
    public boolean hasClientStreaming() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     * @return The clientStreaming.
     */
    @java.lang.Override
    public boolean getClientStreaming() {
      return clientStreaming_;
    }
    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     * @param value The clientStreaming to set.
     */
    private void setClientStreaming(boolean value) {
      bitField0_ |= 0x00000010;
      clientStreaming_ = value;
    }
    /**
     * <pre>
     * Identifies if client streams multiple client messages
     * </pre>
     *
     * <code>optional bool client_streaming = 5 [default = false];</code>
     */
    private void clearClientStreaming() {
      bitField0_ = (bitField0_ & ~0x00000010);
      clientStreaming_ = false;
    }

    public static final int SERVER_STREAMING_FIELD_NUMBER = 6;
    private boolean serverStreaming_;
    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     * @return Whether the serverStreaming field is set.
     */
    @java.lang.Override
    public boolean hasServerStreaming() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     * @return The serverStreaming.
     */
    @java.lang.Override
    public boolean getServerStreaming() {
      return serverStreaming_;
    }
    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     * @param value The serverStreaming to set.
     */
    private void setServerStreaming(boolean value) {
      bitField0_ |= 0x00000020;
      serverStreaming_ = value;
    }
    /**
     * <pre>
     * Identifies if server streams multiple server messages
     * </pre>
     *
     * <code>optional bool server_streaming = 6 [default = false];</code>
     */
    private void clearServerStreaming() {
      bitField0_ = (bitField0_ & ~0x00000020);
      serverStreaming_ = false;
    }

    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.MethodDescriptorProto prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes a method of a service.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.MethodDescriptorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.MethodDescriptorProto, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.MethodDescriptorProto)
        com.google.protobuf.DescriptorProtos.MethodDescriptorProtoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.MethodDescriptorProto.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      @java.lang.Override
      public boolean hasName() {
        return instance.hasName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      @java.lang.Override
      public java.lang.String getName() {
        return instance.getName();
      }
      /**
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @return Whether the inputType field is set.
       */
      @java.lang.Override
      public boolean hasInputType() {
        return instance.hasInputType();
      }
      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @return The inputType.
       */
      @java.lang.Override
      public java.lang.String getInputType() {
        return instance.getInputType();
      }
      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @return The bytes for inputType.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getInputTypeBytes() {
        return instance.getInputTypeBytes();
      }
      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @param value The inputType to set.
       * @return This builder for chaining.
       */
      public Builder setInputType(
          java.lang.String value) {
        copyOnWrite();
        instance.setInputType(value);
        return this;
      }
      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearInputType() {
        copyOnWrite();
        instance.clearInputType();
        return this;
      }
      /**
       * <pre>
       * Input and output type names.  These are resolved in the same way as
       * FieldDescriptorProto.type_name, but must refer to a message type.
       * </pre>
       *
       * <code>optional string input_type = 2;</code>
       * @param value The bytes for inputType to set.
       * @return This builder for chaining.
       */
      public Builder setInputTypeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInputTypeBytes(value);
        return this;
      }

      /**
       * <code>optional string output_type = 3;</code>
       * @return Whether the outputType field is set.
       */
      @java.lang.Override
      public boolean hasOutputType() {
        return instance.hasOutputType();
      }
      /**
       * <code>optional string output_type = 3;</code>
       * @return The outputType.
       */
      @java.lang.Override
      public java.lang.String getOutputType() {
        return instance.getOutputType();
      }
      /**
       * <code>optional string output_type = 3;</code>
       * @return The bytes for outputType.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getOutputTypeBytes() {
        return instance.getOutputTypeBytes();
      }
      /**
       * <code>optional string output_type = 3;</code>
       * @param value The outputType to set.
       * @return This builder for chaining.
       */
      public Builder setOutputType(
          java.lang.String value) {
        copyOnWrite();
        instance.setOutputType(value);
        return this;
      }
      /**
       * <code>optional string output_type = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputType() {
        copyOnWrite();
        instance.clearOutputType();
        return this;
      }
      /**
       * <code>optional string output_type = 3;</code>
       * @param value The bytes for outputType to set.
       * @return This builder for chaining.
       */
      public Builder setOutputTypeBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setOutputTypeBytes(value);
        return this;
      }

      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      @java.lang.Override
      public boolean hasOptions() {
        return instance.hasOptions();
      }
      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.MethodOptions getOptions() {
        return instance.getOptions();
      }
      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      public Builder setOptions(com.google.protobuf.DescriptorProtos.MethodOptions value) {
        copyOnWrite();
        instance.setOptions(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      public Builder setOptions(
          com.google.protobuf.DescriptorProtos.MethodOptions.Builder builderForValue) {
        copyOnWrite();
        instance.setOptions(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      public Builder mergeOptions(com.google.protobuf.DescriptorProtos.MethodOptions value) {
        copyOnWrite();
        instance.mergeOptions(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.MethodOptions options = 4;</code>
       */
      public Builder clearOptions() {  copyOnWrite();
        instance.clearOptions();
        return this;
      }

      /**
       * <pre>
       * Identifies if client streams multiple client messages
       * </pre>
       *
       * <code>optional bool client_streaming = 5 [default = false];</code>
       * @return Whether the clientStreaming field is set.
       */
      @java.lang.Override
      public boolean hasClientStreaming() {
        return instance.hasClientStreaming();
      }
      /**
       * <pre>
       * Identifies if client streams multiple client messages
       * </pre>
       *
       * <code>optional bool client_streaming = 5 [default = false];</code>
       * @return The clientStreaming.
       */
      @java.lang.Override
      public boolean getClientStreaming() {
        return instance.getClientStreaming();
      }
      /**
       * <pre>
       * Identifies if client streams multiple client messages
       * </pre>
       *
       * <code>optional bool client_streaming = 5 [default = false];</code>
       * @param value The clientStreaming to set.
       * @return This builder for chaining.
       */
      public Builder setClientStreaming(boolean value) {
        copyOnWrite();
        instance.setClientStreaming(value);
        return this;
      }
      /**
       * <pre>
       * Identifies if client streams multiple client messages
       * </pre>
       *
       * <code>optional bool client_streaming = 5 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearClientStreaming() {
        copyOnWrite();
        instance.clearClientStreaming();
        return this;
      }

      /**
       * <pre>
       * Identifies if server streams multiple server messages
       * </pre>
       *
       * <code>optional bool server_streaming = 6 [default = false];</code>
       * @return Whether the serverStreaming field is set.
       */
      @java.lang.Override
      public boolean hasServerStreaming() {
        return instance.hasServerStreaming();
      }
      /**
       * <pre>
       * Identifies if server streams multiple server messages
       * </pre>
       *
       * <code>optional bool server_streaming = 6 [default = false];</code>
       * @return The serverStreaming.
       */
      @java.lang.Override
      public boolean getServerStreaming() {
        return instance.getServerStreaming();
      }
      /**
       * <pre>
       * Identifies if server streams multiple server messages
       * </pre>
       *
       * <code>optional bool server_streaming = 6 [default = false];</code>
       * @param value The serverStreaming to set.
       * @return This builder for chaining.
       */
      public Builder setServerStreaming(boolean value) {
        copyOnWrite();
        instance.setServerStreaming(value);
        return this;
      }
      /**
       * <pre>
       * Identifies if server streams multiple server messages
       * </pre>
       *
       * <code>optional bool server_streaming = 6 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearServerStreaming() {
        copyOnWrite();
        instance.clearServerStreaming();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.MethodDescriptorProto)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.MethodDescriptorProto();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              "inputType_",
              "outputType_",
              "options_",
              "clientStreaming_",
              "serverStreaming_",
            };
            java.lang.String info =
                "\u0001\u0006\u0000\u0001\u0001\u0006\u0006\u0000\u0000\u0001\u0001\u1008\u0000\u0002" +
                "\u1008\u0001\u0003\u1008\u0002\u0004\u1409\u0003\u0005\u1007\u0004\u0006\u1007\u0005" +
                "";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.MethodDescriptorProto> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.MethodDescriptorProto.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.MethodDescriptorProto>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.MethodDescriptorProto)
    private static final com.google.protobuf.DescriptorProtos.MethodDescriptorProto DEFAULT_INSTANCE;
    static {
      MethodDescriptorProto defaultInstance = new MethodDescriptorProto();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MethodDescriptorProto.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.MethodDescriptorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MethodDescriptorProto> PARSER;

    public static com.google.protobuf.Parser<MethodDescriptorProto> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FileOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.FileOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                FileOptions, FileOptions.Builder> {

    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return Whether the javaPackage field is set.
     */
    boolean hasJavaPackage();
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return The javaPackage.
     */
    java.lang.String getJavaPackage();
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return The bytes for javaPackage.
     */
    com.google.protobuf.ByteString
        getJavaPackageBytes();

    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return Whether the javaOuterClassname field is set.
     */
    boolean hasJavaOuterClassname();
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return The javaOuterClassname.
     */
    java.lang.String getJavaOuterClassname();
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return The bytes for javaOuterClassname.
     */
    com.google.protobuf.ByteString
        getJavaOuterClassnameBytes();

    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     * @return Whether the javaMultipleFiles field is set.
     */
    boolean hasJavaMultipleFiles();
    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     * @return The javaMultipleFiles.
     */
    boolean getJavaMultipleFiles();

    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     * @return Whether the javaGenerateEqualsAndHash field is set.
     */
    @java.lang.Deprecated boolean hasJavaGenerateEqualsAndHash();
    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     * @return The javaGenerateEqualsAndHash.
     */
    @java.lang.Deprecated boolean getJavaGenerateEqualsAndHash();

    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     * @return Whether the javaStringCheckUtf8 field is set.
     */
    boolean hasJavaStringCheckUtf8();
    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     * @return The javaStringCheckUtf8.
     */
    boolean getJavaStringCheckUtf8();

    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     * @return Whether the optimizeFor field is set.
     */
    boolean hasOptimizeFor();
    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     * @return The optimizeFor.
     */
    com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode getOptimizeFor();

    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return Whether the goPackage field is set.
     */
    boolean hasGoPackage();
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return The goPackage.
     */
    java.lang.String getGoPackage();
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return The bytes for goPackage.
     */
    com.google.protobuf.ByteString
        getGoPackageBytes();

    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     * @return Whether the ccGenericServices field is set.
     */
    boolean hasCcGenericServices();
    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     * @return The ccGenericServices.
     */
    boolean getCcGenericServices();

    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     * @return Whether the javaGenericServices field is set.
     */
    boolean hasJavaGenericServices();
    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     * @return The javaGenericServices.
     */
    boolean getJavaGenericServices();

    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     * @return Whether the pyGenericServices field is set.
     */
    boolean hasPyGenericServices();
    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     * @return The pyGenericServices.
     */
    boolean getPyGenericServices();

    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     * @return Whether the phpGenericServices field is set.
     */
    boolean hasPhpGenericServices();
    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     * @return The phpGenericServices.
     */
    boolean getPhpGenericServices();

    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     * @return Whether the ccEnableArenas field is set.
     */
    boolean hasCcEnableArenas();
    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     * @return The ccEnableArenas.
     */
    boolean getCcEnableArenas();

    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return Whether the objcClassPrefix field is set.
     */
    boolean hasObjcClassPrefix();
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return The objcClassPrefix.
     */
    java.lang.String getObjcClassPrefix();
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return The bytes for objcClassPrefix.
     */
    com.google.protobuf.ByteString
        getObjcClassPrefixBytes();

    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return Whether the csharpNamespace field is set.
     */
    boolean hasCsharpNamespace();
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return The csharpNamespace.
     */
    java.lang.String getCsharpNamespace();
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return The bytes for csharpNamespace.
     */
    com.google.protobuf.ByteString
        getCsharpNamespaceBytes();

    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return Whether the swiftPrefix field is set.
     */
    boolean hasSwiftPrefix();
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return The swiftPrefix.
     */
    java.lang.String getSwiftPrefix();
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return The bytes for swiftPrefix.
     */
    com.google.protobuf.ByteString
        getSwiftPrefixBytes();

    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return Whether the phpClassPrefix field is set.
     */
    boolean hasPhpClassPrefix();
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return The phpClassPrefix.
     */
    java.lang.String getPhpClassPrefix();
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return The bytes for phpClassPrefix.
     */
    com.google.protobuf.ByteString
        getPhpClassPrefixBytes();

    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return Whether the phpNamespace field is set.
     */
    boolean hasPhpNamespace();
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return The phpNamespace.
     */
    java.lang.String getPhpNamespace();
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return The bytes for phpNamespace.
     */
    com.google.protobuf.ByteString
        getPhpNamespaceBytes();

    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return Whether the phpMetadataNamespace field is set.
     */
    boolean hasPhpMetadataNamespace();
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return The phpMetadataNamespace.
     */
    java.lang.String getPhpMetadataNamespace();
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return The bytes for phpMetadataNamespace.
     */
    com.google.protobuf.ByteString
        getPhpMetadataNamespaceBytes();

    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return Whether the rubyPackage field is set.
     */
    boolean hasRubyPackage();
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return The rubyPackage.
     */
    java.lang.String getRubyPackage();
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return The bytes for rubyPackage.
     */
    com.google.protobuf.ByteString
        getRubyPackageBytes();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.FileOptions}
   */
  public  static final class FileOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        FileOptions, FileOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FileOptions)
      FileOptionsOrBuilder {
    private FileOptions() {
      javaPackage_ = "";
      javaOuterClassname_ = "";
      optimizeFor_ = 1;
      goPackage_ = "";
      ccEnableArenas_ = true;
      objcClassPrefix_ = "";
      csharpNamespace_ = "";
      swiftPrefix_ = "";
      phpClassPrefix_ = "";
      phpNamespace_ = "";
      phpMetadataNamespace_ = "";
      rubyPackage_ = "";
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Generated classes can be optimized for speed or code size.
     * </pre>
     *
     * Protobuf enum {@code google.protobuf.FileOptions.OptimizeMode}
     */
    public enum OptimizeMode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Generate complete code for parsing, serialization,
       * </pre>
       *
       * <code>SPEED = 1;</code>
       */
      SPEED(1),
      /**
       * <pre>
       * etc.
       * </pre>
       *
       * <code>CODE_SIZE = 2;</code>
       */
      CODE_SIZE(2),
      /**
       * <pre>
       * Generate code using MessageLite and the lite runtime.
       * </pre>
       *
       * <code>LITE_RUNTIME = 3;</code>
       */
      LITE_RUNTIME(3),
      ;

      /**
       * <pre>
       * Generate complete code for parsing, serialization,
       * </pre>
       *
       * <code>SPEED = 1;</code>
       */
      public static final int SPEED_VALUE = 1;
      /**
       * <pre>
       * etc.
       * </pre>
       *
       * <code>CODE_SIZE = 2;</code>
       */
      public static final int CODE_SIZE_VALUE = 2;
      /**
       * <pre>
       * Generate code using MessageLite and the lite runtime.
       * </pre>
       *
       * <code>LITE_RUNTIME = 3;</code>
       */
      public static final int LITE_RUNTIME_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OptimizeMode valueOf(int value) {
        return forNumber(value);
      }

      public static OptimizeMode forNumber(int value) {
        switch (value) {
          case 1: return SPEED;
          case 2: return CODE_SIZE;
          case 3: return LITE_RUNTIME;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OptimizeMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OptimizeMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OptimizeMode>() {
              @java.lang.Override
              public OptimizeMode findValueByNumber(int number) {
                return OptimizeMode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return OptimizeModeVerifier.INSTANCE;
      }

      private static final class OptimizeModeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new OptimizeModeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return OptimizeMode.forNumber(number) != null;
              }
            };

      private final int value;

      private OptimizeMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FileOptions.OptimizeMode)
    }

    private int bitField0_;
    public static final int JAVA_PACKAGE_FIELD_NUMBER = 1;
    private java.lang.String javaPackage_;
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return Whether the javaPackage field is set.
     */
    @java.lang.Override
    public boolean hasJavaPackage() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return The javaPackage.
     */
    @java.lang.Override
    public java.lang.String getJavaPackage() {
      return javaPackage_;
    }
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @return The bytes for javaPackage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getJavaPackageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(javaPackage_);
    }
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @param value The javaPackage to set.
     */
    private void setJavaPackage(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      javaPackage_ = value;
    }
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     */
    private void clearJavaPackage() {
      bitField0_ = (bitField0_ & ~0x00000001);
      javaPackage_ = getDefaultInstance().getJavaPackage();
    }
    /**
     * <pre>
     * Sets the Java package where classes generated from this .proto will be
     * placed.  By default, the proto package is used, but this is often
     * inappropriate because proto packages do not normally start with backwards
     * domain names.
     * </pre>
     *
     * <code>optional string java_package = 1;</code>
     * @param value The bytes for javaPackage to set.
     */
    private void setJavaPackageBytes(
        com.google.protobuf.ByteString value) {
      javaPackage_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int JAVA_OUTER_CLASSNAME_FIELD_NUMBER = 8;
    private java.lang.String javaOuterClassname_;
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return Whether the javaOuterClassname field is set.
     */
    @java.lang.Override
    public boolean hasJavaOuterClassname() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return The javaOuterClassname.
     */
    @java.lang.Override
    public java.lang.String getJavaOuterClassname() {
      return javaOuterClassname_;
    }
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @return The bytes for javaOuterClassname.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getJavaOuterClassnameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(javaOuterClassname_);
    }
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @param value The javaOuterClassname to set.
     */
    private void setJavaOuterClassname(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      javaOuterClassname_ = value;
    }
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     */
    private void clearJavaOuterClassname() {
      bitField0_ = (bitField0_ & ~0x00000002);
      javaOuterClassname_ = getDefaultInstance().getJavaOuterClassname();
    }
    /**
     * <pre>
     * Controls the name of the wrapper Java class generated for the .proto file.
     * That class will always contain the .proto file's getDescriptor() method as
     * well as any top-level extensions defined in the .proto file.
     * If java_multiple_files is disabled, then all the other classes from the
     * .proto file will be nested inside the single wrapper outer class.
     * </pre>
     *
     * <code>optional string java_outer_classname = 8;</code>
     * @param value The bytes for javaOuterClassname to set.
     */
    private void setJavaOuterClassnameBytes(
        com.google.protobuf.ByteString value) {
      javaOuterClassname_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int JAVA_MULTIPLE_FILES_FIELD_NUMBER = 10;
    private boolean javaMultipleFiles_;
    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     * @return Whether the javaMultipleFiles field is set.
     */
    @java.lang.Override
    public boolean hasJavaMultipleFiles() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     * @return The javaMultipleFiles.
     */
    @java.lang.Override
    public boolean getJavaMultipleFiles() {
      return javaMultipleFiles_;
    }
    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     * @param value The javaMultipleFiles to set.
     */
    private void setJavaMultipleFiles(boolean value) {
      bitField0_ |= 0x00000004;
      javaMultipleFiles_ = value;
    }
    /**
     * <pre>
     * If enabled, then the Java code generator will generate a separate .java
     * file for each top-level message, enum, and service defined in the .proto
     * file.  Thus, these types will *not* be nested inside the wrapper class
     * named by java_outer_classname.  However, the wrapper class will still be
     * generated to contain the file's getDescriptor() method as well as any
     * top-level extensions defined in the file.
     * </pre>
     *
     * <code>optional bool java_multiple_files = 10 [default = false];</code>
     */
    private void clearJavaMultipleFiles() {
      bitField0_ = (bitField0_ & ~0x00000004);
      javaMultipleFiles_ = false;
    }

    public static final int JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUMBER = 20;
    private boolean javaGenerateEqualsAndHash_;
    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     * @return Whether the javaGenerateEqualsAndHash field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasJavaGenerateEqualsAndHash() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     * @return The javaGenerateEqualsAndHash.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getJavaGenerateEqualsAndHash() {
      return javaGenerateEqualsAndHash_;
    }
    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     * @param value The javaGenerateEqualsAndHash to set.
     */
    private void setJavaGenerateEqualsAndHash(boolean value) {
      bitField0_ |= 0x00000008;
      javaGenerateEqualsAndHash_ = value;
    }
    /**
     * <pre>
     * This option does nothing.
     * </pre>
     *
     * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
     * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
     *     See google/protobuf/descriptor.proto;l=411
     */
    private void clearJavaGenerateEqualsAndHash() {
      bitField0_ = (bitField0_ & ~0x00000008);
      javaGenerateEqualsAndHash_ = false;
    }

    public static final int JAVA_STRING_CHECK_UTF8_FIELD_NUMBER = 27;
    private boolean javaStringCheckUtf8_;
    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     * @return Whether the javaStringCheckUtf8 field is set.
     */
    @java.lang.Override
    public boolean hasJavaStringCheckUtf8() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     * @return The javaStringCheckUtf8.
     */
    @java.lang.Override
    public boolean getJavaStringCheckUtf8() {
      return javaStringCheckUtf8_;
    }
    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     * @param value The javaStringCheckUtf8 to set.
     */
    private void setJavaStringCheckUtf8(boolean value) {
      bitField0_ |= 0x00000010;
      javaStringCheckUtf8_ = value;
    }
    /**
     * <pre>
     * If set true, then the Java2 code generator will generate code that
     * throws an exception whenever an attempt is made to assign a non-UTF-8
     * byte sequence to a string field.
     * Message reflection will do the same.
     * However, an extension field still accepts non-UTF-8 byte sequences.
     * This option has no effect on when used with the lite runtime.
     * </pre>
     *
     * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
     */
    private void clearJavaStringCheckUtf8() {
      bitField0_ = (bitField0_ & ~0x00000010);
      javaStringCheckUtf8_ = false;
    }

    public static final int OPTIMIZE_FOR_FIELD_NUMBER = 9;
    private int optimizeFor_;
    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     * @return Whether the optimizeFor field is set.
     */
    @java.lang.Override
    public boolean hasOptimizeFor() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     * @return The optimizeFor.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode getOptimizeFor() {
      com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode result = com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode.forNumber(optimizeFor_);
      return result == null ? com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode.SPEED : result;
    }
    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     * @param value The optimizeFor to set.
     */
    private void setOptimizeFor(com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode value) {
      optimizeFor_ = value.getNumber();
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
     */
    private void clearOptimizeFor() {
      bitField0_ = (bitField0_ & ~0x00000020);
      optimizeFor_ = 1;
    }

    public static final int GO_PACKAGE_FIELD_NUMBER = 11;
    private java.lang.String goPackage_;
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return Whether the goPackage field is set.
     */
    @java.lang.Override
    public boolean hasGoPackage() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return The goPackage.
     */
    @java.lang.Override
    public java.lang.String getGoPackage() {
      return goPackage_;
    }
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @return The bytes for goPackage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGoPackageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(goPackage_);
    }
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @param value The goPackage to set.
     */
    private void setGoPackage(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000040;
      goPackage_ = value;
    }
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     */
    private void clearGoPackage() {
      bitField0_ = (bitField0_ & ~0x00000040);
      goPackage_ = getDefaultInstance().getGoPackage();
    }
    /**
     * <pre>
     * Sets the Go package where structs generated from this .proto will be
     * placed. If omitted, the Go package will be derived from the following:
     *   - The basename of the package import path, if provided.
     *   - Otherwise, the package statement in the .proto file, if present.
     *   - Otherwise, the basename of the .proto file, without extension.
     * </pre>
     *
     * <code>optional string go_package = 11;</code>
     * @param value The bytes for goPackage to set.
     */
    private void setGoPackageBytes(
        com.google.protobuf.ByteString value) {
      goPackage_ = value.toStringUtf8();
      bitField0_ |= 0x00000040;
    }

    public static final int CC_GENERIC_SERVICES_FIELD_NUMBER = 16;
    private boolean ccGenericServices_;
    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     * @return Whether the ccGenericServices field is set.
     */
    @java.lang.Override
    public boolean hasCcGenericServices() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     * @return The ccGenericServices.
     */
    @java.lang.Override
    public boolean getCcGenericServices() {
      return ccGenericServices_;
    }
    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     * @param value The ccGenericServices to set.
     */
    private void setCcGenericServices(boolean value) {
      bitField0_ |= 0x00000080;
      ccGenericServices_ = value;
    }
    /**
     * <pre>
     * Should generic services be generated in each language?  "Generic" services
     * are not specific to any particular RPC system.  They are generated by the
     * main code generators in each language (without additional plugins).
     * Generic services were the only kind of service generation supported by
     * early versions of google.protobuf.
     * Generic services are now considered deprecated in favor of using plugins
     * that generate code specific to your particular RPC system.  Therefore,
     * these default to false.  Old code which depends on generic services should
     * explicitly set them to true.
     * </pre>
     *
     * <code>optional bool cc_generic_services = 16 [default = false];</code>
     */
    private void clearCcGenericServices() {
      bitField0_ = (bitField0_ & ~0x00000080);
      ccGenericServices_ = false;
    }

    public static final int JAVA_GENERIC_SERVICES_FIELD_NUMBER = 17;
    private boolean javaGenericServices_;
    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     * @return Whether the javaGenericServices field is set.
     */
    @java.lang.Override
    public boolean hasJavaGenericServices() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     * @return The javaGenericServices.
     */
    @java.lang.Override
    public boolean getJavaGenericServices() {
      return javaGenericServices_;
    }
    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     * @param value The javaGenericServices to set.
     */
    private void setJavaGenericServices(boolean value) {
      bitField0_ |= 0x00000100;
      javaGenericServices_ = value;
    }
    /**
     * <code>optional bool java_generic_services = 17 [default = false];</code>
     */
    private void clearJavaGenericServices() {
      bitField0_ = (bitField0_ & ~0x00000100);
      javaGenericServices_ = false;
    }

    public static final int PY_GENERIC_SERVICES_FIELD_NUMBER = 18;
    private boolean pyGenericServices_;
    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     * @return Whether the pyGenericServices field is set.
     */
    @java.lang.Override
    public boolean hasPyGenericServices() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     * @return The pyGenericServices.
     */
    @java.lang.Override
    public boolean getPyGenericServices() {
      return pyGenericServices_;
    }
    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     * @param value The pyGenericServices to set.
     */
    private void setPyGenericServices(boolean value) {
      bitField0_ |= 0x00000200;
      pyGenericServices_ = value;
    }
    /**
     * <code>optional bool py_generic_services = 18 [default = false];</code>
     */
    private void clearPyGenericServices() {
      bitField0_ = (bitField0_ & ~0x00000200);
      pyGenericServices_ = false;
    }

    public static final int PHP_GENERIC_SERVICES_FIELD_NUMBER = 42;
    private boolean phpGenericServices_;
    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     * @return Whether the phpGenericServices field is set.
     */
    @java.lang.Override
    public boolean hasPhpGenericServices() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     * @return The phpGenericServices.
     */
    @java.lang.Override
    public boolean getPhpGenericServices() {
      return phpGenericServices_;
    }
    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     * @param value The phpGenericServices to set.
     */
    private void setPhpGenericServices(boolean value) {
      bitField0_ |= 0x00000400;
      phpGenericServices_ = value;
    }
    /**
     * <code>optional bool php_generic_services = 42 [default = false];</code>
     */
    private void clearPhpGenericServices() {
      bitField0_ = (bitField0_ & ~0x00000400);
      phpGenericServices_ = false;
    }

    public static final int DEPRECATED_FIELD_NUMBER = 23;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000800;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this file deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for everything in the file, or it will be completely ignored; in the very
     * least, this is a formalization for deprecating files.
     * </pre>
     *
     * <code>optional bool deprecated = 23 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000800);
      deprecated_ = false;
    }

    public static final int CC_ENABLE_ARENAS_FIELD_NUMBER = 31;
    private boolean ccEnableArenas_;
    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     * @return Whether the ccEnableArenas field is set.
     */
    @java.lang.Override
    public boolean hasCcEnableArenas() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     * @return The ccEnableArenas.
     */
    @java.lang.Override
    public boolean getCcEnableArenas() {
      return ccEnableArenas_;
    }
    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     * @param value The ccEnableArenas to set.
     */
    private void setCcEnableArenas(boolean value) {
      bitField0_ |= 0x00001000;
      ccEnableArenas_ = value;
    }
    /**
     * <pre>
     * Enables the use of arenas for the proto messages in this file. This applies
     * only to generated classes for C++.
     * </pre>
     *
     * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
     */
    private void clearCcEnableArenas() {
      bitField0_ = (bitField0_ & ~0x00001000);
      ccEnableArenas_ = true;
    }

    public static final int OBJC_CLASS_PREFIX_FIELD_NUMBER = 36;
    private java.lang.String objcClassPrefix_;
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return Whether the objcClassPrefix field is set.
     */
    @java.lang.Override
    public boolean hasObjcClassPrefix() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return The objcClassPrefix.
     */
    @java.lang.Override
    public java.lang.String getObjcClassPrefix() {
      return objcClassPrefix_;
    }
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @return The bytes for objcClassPrefix.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getObjcClassPrefixBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(objcClassPrefix_);
    }
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @param value The objcClassPrefix to set.
     */
    private void setObjcClassPrefix(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00002000;
      objcClassPrefix_ = value;
    }
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     */
    private void clearObjcClassPrefix() {
      bitField0_ = (bitField0_ & ~0x00002000);
      objcClassPrefix_ = getDefaultInstance().getObjcClassPrefix();
    }
    /**
     * <pre>
     * Sets the objective c class prefix which is prepended to all objective c
     * generated classes from this .proto. There is no default.
     * </pre>
     *
     * <code>optional string objc_class_prefix = 36;</code>
     * @param value The bytes for objcClassPrefix to set.
     */
    private void setObjcClassPrefixBytes(
        com.google.protobuf.ByteString value) {
      objcClassPrefix_ = value.toStringUtf8();
      bitField0_ |= 0x00002000;
    }

    public static final int CSHARP_NAMESPACE_FIELD_NUMBER = 37;
    private java.lang.String csharpNamespace_;
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return Whether the csharpNamespace field is set.
     */
    @java.lang.Override
    public boolean hasCsharpNamespace() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return The csharpNamespace.
     */
    @java.lang.Override
    public java.lang.String getCsharpNamespace() {
      return csharpNamespace_;
    }
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @return The bytes for csharpNamespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCsharpNamespaceBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(csharpNamespace_);
    }
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @param value The csharpNamespace to set.
     */
    private void setCsharpNamespace(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00004000;
      csharpNamespace_ = value;
    }
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     */
    private void clearCsharpNamespace() {
      bitField0_ = (bitField0_ & ~0x00004000);
      csharpNamespace_ = getDefaultInstance().getCsharpNamespace();
    }
    /**
     * <pre>
     * Namespace for generated classes; defaults to the package.
     * </pre>
     *
     * <code>optional string csharp_namespace = 37;</code>
     * @param value The bytes for csharpNamespace to set.
     */
    private void setCsharpNamespaceBytes(
        com.google.protobuf.ByteString value) {
      csharpNamespace_ = value.toStringUtf8();
      bitField0_ |= 0x00004000;
    }

    public static final int SWIFT_PREFIX_FIELD_NUMBER = 39;
    private java.lang.String swiftPrefix_;
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return Whether the swiftPrefix field is set.
     */
    @java.lang.Override
    public boolean hasSwiftPrefix() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return The swiftPrefix.
     */
    @java.lang.Override
    public java.lang.String getSwiftPrefix() {
      return swiftPrefix_;
    }
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @return The bytes for swiftPrefix.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSwiftPrefixBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(swiftPrefix_);
    }
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @param value The swiftPrefix to set.
     */
    private void setSwiftPrefix(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00008000;
      swiftPrefix_ = value;
    }
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     */
    private void clearSwiftPrefix() {
      bitField0_ = (bitField0_ & ~0x00008000);
      swiftPrefix_ = getDefaultInstance().getSwiftPrefix();
    }
    /**
     * <pre>
     * By default Swift generators will take the proto package and CamelCase it
     * replacing '.' with underscore and use that to prefix the types/symbols
     * defined. When this options is provided, they will use this value instead
     * to prefix the types/symbols defined.
     * </pre>
     *
     * <code>optional string swift_prefix = 39;</code>
     * @param value The bytes for swiftPrefix to set.
     */
    private void setSwiftPrefixBytes(
        com.google.protobuf.ByteString value) {
      swiftPrefix_ = value.toStringUtf8();
      bitField0_ |= 0x00008000;
    }

    public static final int PHP_CLASS_PREFIX_FIELD_NUMBER = 40;
    private java.lang.String phpClassPrefix_;
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return Whether the phpClassPrefix field is set.
     */
    @java.lang.Override
    public boolean hasPhpClassPrefix() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return The phpClassPrefix.
     */
    @java.lang.Override
    public java.lang.String getPhpClassPrefix() {
      return phpClassPrefix_;
    }
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @return The bytes for phpClassPrefix.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPhpClassPrefixBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(phpClassPrefix_);
    }
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @param value The phpClassPrefix to set.
     */
    private void setPhpClassPrefix(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00010000;
      phpClassPrefix_ = value;
    }
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     */
    private void clearPhpClassPrefix() {
      bitField0_ = (bitField0_ & ~0x00010000);
      phpClassPrefix_ = getDefaultInstance().getPhpClassPrefix();
    }
    /**
     * <pre>
     * Sets the php class prefix which is prepended to all php generated classes
     * from this .proto. Default is empty.
     * </pre>
     *
     * <code>optional string php_class_prefix = 40;</code>
     * @param value The bytes for phpClassPrefix to set.
     */
    private void setPhpClassPrefixBytes(
        com.google.protobuf.ByteString value) {
      phpClassPrefix_ = value.toStringUtf8();
      bitField0_ |= 0x00010000;
    }

    public static final int PHP_NAMESPACE_FIELD_NUMBER = 41;
    private java.lang.String phpNamespace_;
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return Whether the phpNamespace field is set.
     */
    @java.lang.Override
    public boolean hasPhpNamespace() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return The phpNamespace.
     */
    @java.lang.Override
    public java.lang.String getPhpNamespace() {
      return phpNamespace_;
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @return The bytes for phpNamespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPhpNamespaceBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(phpNamespace_);
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @param value The phpNamespace to set.
     */
    private void setPhpNamespace(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00020000;
      phpNamespace_ = value;
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     */
    private void clearPhpNamespace() {
      bitField0_ = (bitField0_ & ~0x00020000);
      phpNamespace_ = getDefaultInstance().getPhpNamespace();
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated classes. Default
     * is empty. When this option is empty, the package name will be used for
     * determining the namespace.
     * </pre>
     *
     * <code>optional string php_namespace = 41;</code>
     * @param value The bytes for phpNamespace to set.
     */
    private void setPhpNamespaceBytes(
        com.google.protobuf.ByteString value) {
      phpNamespace_ = value.toStringUtf8();
      bitField0_ |= 0x00020000;
    }

    public static final int PHP_METADATA_NAMESPACE_FIELD_NUMBER = 44;
    private java.lang.String phpMetadataNamespace_;
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return Whether the phpMetadataNamespace field is set.
     */
    @java.lang.Override
    public boolean hasPhpMetadataNamespace() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return The phpMetadataNamespace.
     */
    @java.lang.Override
    public java.lang.String getPhpMetadataNamespace() {
      return phpMetadataNamespace_;
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @return The bytes for phpMetadataNamespace.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPhpMetadataNamespaceBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(phpMetadataNamespace_);
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @param value The phpMetadataNamespace to set.
     */
    private void setPhpMetadataNamespace(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00040000;
      phpMetadataNamespace_ = value;
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     */
    private void clearPhpMetadataNamespace() {
      bitField0_ = (bitField0_ & ~0x00040000);
      phpMetadataNamespace_ = getDefaultInstance().getPhpMetadataNamespace();
    }
    /**
     * <pre>
     * Use this option to change the namespace of php generated metadata classes.
     * Default is empty. When this option is empty, the proto file name will be
     * used for determining the namespace.
     * </pre>
     *
     * <code>optional string php_metadata_namespace = 44;</code>
     * @param value The bytes for phpMetadataNamespace to set.
     */
    private void setPhpMetadataNamespaceBytes(
        com.google.protobuf.ByteString value) {
      phpMetadataNamespace_ = value.toStringUtf8();
      bitField0_ |= 0x00040000;
    }

    public static final int RUBY_PACKAGE_FIELD_NUMBER = 45;
    private java.lang.String rubyPackage_;
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return Whether the rubyPackage field is set.
     */
    @java.lang.Override
    public boolean hasRubyPackage() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return The rubyPackage.
     */
    @java.lang.Override
    public java.lang.String getRubyPackage() {
      return rubyPackage_;
    }
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @return The bytes for rubyPackage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRubyPackageBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(rubyPackage_);
    }
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @param value The rubyPackage to set.
     */
    private void setRubyPackage(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00080000;
      rubyPackage_ = value;
    }
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     */
    private void clearRubyPackage() {
      bitField0_ = (bitField0_ & ~0x00080000);
      rubyPackage_ = getDefaultInstance().getRubyPackage();
    }
    /**
     * <pre>
     * Use this option to change the package of ruby generated classes. Default
     * is empty. When this option is not set, the package name will be used for
     * determining the ruby package.
     * </pre>
     *
     * <code>optional string ruby_package = 45;</code>
     * @param value The bytes for rubyPackage to set.
     */
    private void setRubyPackageBytes(
        com.google.protobuf.ByteString value) {
      rubyPackage_ = value.toStringUtf8();
      bitField0_ |= 0x00080000;
    }

    public static final int FEATURES_FIELD_NUMBER = 50;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00100000;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00100000;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 50;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00100000);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here.
     * See the documentation for the "Options" section above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FileOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FileOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.FileOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.FileOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FileOptions)
        com.google.protobuf.DescriptorProtos.FileOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FileOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @return Whether the javaPackage field is set.
       */
      @java.lang.Override
      public boolean hasJavaPackage() {
        return instance.hasJavaPackage();
      }
      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @return The javaPackage.
       */
      @java.lang.Override
      public java.lang.String getJavaPackage() {
        return instance.getJavaPackage();
      }
      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @return The bytes for javaPackage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getJavaPackageBytes() {
        return instance.getJavaPackageBytes();
      }
      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @param value The javaPackage to set.
       * @return This builder for chaining.
       */
      public Builder setJavaPackage(
          java.lang.String value) {
        copyOnWrite();
        instance.setJavaPackage(value);
        return this;
      }
      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearJavaPackage() {
        copyOnWrite();
        instance.clearJavaPackage();
        return this;
      }
      /**
       * <pre>
       * Sets the Java package where classes generated from this .proto will be
       * placed.  By default, the proto package is used, but this is often
       * inappropriate because proto packages do not normally start with backwards
       * domain names.
       * </pre>
       *
       * <code>optional string java_package = 1;</code>
       * @param value The bytes for javaPackage to set.
       * @return This builder for chaining.
       */
      public Builder setJavaPackageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setJavaPackageBytes(value);
        return this;
      }

      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @return Whether the javaOuterClassname field is set.
       */
      @java.lang.Override
      public boolean hasJavaOuterClassname() {
        return instance.hasJavaOuterClassname();
      }
      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @return The javaOuterClassname.
       */
      @java.lang.Override
      public java.lang.String getJavaOuterClassname() {
        return instance.getJavaOuterClassname();
      }
      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @return The bytes for javaOuterClassname.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getJavaOuterClassnameBytes() {
        return instance.getJavaOuterClassnameBytes();
      }
      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @param value The javaOuterClassname to set.
       * @return This builder for chaining.
       */
      public Builder setJavaOuterClassname(
          java.lang.String value) {
        copyOnWrite();
        instance.setJavaOuterClassname(value);
        return this;
      }
      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearJavaOuterClassname() {
        copyOnWrite();
        instance.clearJavaOuterClassname();
        return this;
      }
      /**
       * <pre>
       * Controls the name of the wrapper Java class generated for the .proto file.
       * That class will always contain the .proto file's getDescriptor() method as
       * well as any top-level extensions defined in the .proto file.
       * If java_multiple_files is disabled, then all the other classes from the
       * .proto file will be nested inside the single wrapper outer class.
       * </pre>
       *
       * <code>optional string java_outer_classname = 8;</code>
       * @param value The bytes for javaOuterClassname to set.
       * @return This builder for chaining.
       */
      public Builder setJavaOuterClassnameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setJavaOuterClassnameBytes(value);
        return this;
      }

      /**
       * <pre>
       * If enabled, then the Java code generator will generate a separate .java
       * file for each top-level message, enum, and service defined in the .proto
       * file.  Thus, these types will *not* be nested inside the wrapper class
       * named by java_outer_classname.  However, the wrapper class will still be
       * generated to contain the file's getDescriptor() method as well as any
       * top-level extensions defined in the file.
       * </pre>
       *
       * <code>optional bool java_multiple_files = 10 [default = false];</code>
       * @return Whether the javaMultipleFiles field is set.
       */
      @java.lang.Override
      public boolean hasJavaMultipleFiles() {
        return instance.hasJavaMultipleFiles();
      }
      /**
       * <pre>
       * If enabled, then the Java code generator will generate a separate .java
       * file for each top-level message, enum, and service defined in the .proto
       * file.  Thus, these types will *not* be nested inside the wrapper class
       * named by java_outer_classname.  However, the wrapper class will still be
       * generated to contain the file's getDescriptor() method as well as any
       * top-level extensions defined in the file.
       * </pre>
       *
       * <code>optional bool java_multiple_files = 10 [default = false];</code>
       * @return The javaMultipleFiles.
       */
      @java.lang.Override
      public boolean getJavaMultipleFiles() {
        return instance.getJavaMultipleFiles();
      }
      /**
       * <pre>
       * If enabled, then the Java code generator will generate a separate .java
       * file for each top-level message, enum, and service defined in the .proto
       * file.  Thus, these types will *not* be nested inside the wrapper class
       * named by java_outer_classname.  However, the wrapper class will still be
       * generated to contain the file's getDescriptor() method as well as any
       * top-level extensions defined in the file.
       * </pre>
       *
       * <code>optional bool java_multiple_files = 10 [default = false];</code>
       * @param value The javaMultipleFiles to set.
       * @return This builder for chaining.
       */
      public Builder setJavaMultipleFiles(boolean value) {
        copyOnWrite();
        instance.setJavaMultipleFiles(value);
        return this;
      }
      /**
       * <pre>
       * If enabled, then the Java code generator will generate a separate .java
       * file for each top-level message, enum, and service defined in the .proto
       * file.  Thus, these types will *not* be nested inside the wrapper class
       * named by java_outer_classname.  However, the wrapper class will still be
       * generated to contain the file's getDescriptor() method as well as any
       * top-level extensions defined in the file.
       * </pre>
       *
       * <code>optional bool java_multiple_files = 10 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearJavaMultipleFiles() {
        copyOnWrite();
        instance.clearJavaMultipleFiles();
        return this;
      }

      /**
       * <pre>
       * This option does nothing.
       * </pre>
       *
       * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
       * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
       *     See google/protobuf/descriptor.proto;l=411
       * @return Whether the javaGenerateEqualsAndHash field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasJavaGenerateEqualsAndHash() {
        return instance.hasJavaGenerateEqualsAndHash();
      }
      /**
       * <pre>
       * This option does nothing.
       * </pre>
       *
       * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
       * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
       *     See google/protobuf/descriptor.proto;l=411
       * @return The javaGenerateEqualsAndHash.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getJavaGenerateEqualsAndHash() {
        return instance.getJavaGenerateEqualsAndHash();
      }
      /**
       * <pre>
       * This option does nothing.
       * </pre>
       *
       * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
       * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
       *     See google/protobuf/descriptor.proto;l=411
       * @param value The javaGenerateEqualsAndHash to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setJavaGenerateEqualsAndHash(boolean value) {
        copyOnWrite();
        instance.setJavaGenerateEqualsAndHash(value);
        return this;
      }
      /**
       * <pre>
       * This option does nothing.
       * </pre>
       *
       * <code>optional bool java_generate_equals_and_hash = 20 [deprecated = true];</code>
       * @deprecated google.protobuf.FileOptions.java_generate_equals_and_hash is deprecated.
       *     See google/protobuf/descriptor.proto;l=411
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearJavaGenerateEqualsAndHash() {
        copyOnWrite();
        instance.clearJavaGenerateEqualsAndHash();
        return this;
      }

      /**
       * <pre>
       * If set true, then the Java2 code generator will generate code that
       * throws an exception whenever an attempt is made to assign a non-UTF-8
       * byte sequence to a string field.
       * Message reflection will do the same.
       * However, an extension field still accepts non-UTF-8 byte sequences.
       * This option has no effect on when used with the lite runtime.
       * </pre>
       *
       * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
       * @return Whether the javaStringCheckUtf8 field is set.
       */
      @java.lang.Override
      public boolean hasJavaStringCheckUtf8() {
        return instance.hasJavaStringCheckUtf8();
      }
      /**
       * <pre>
       * If set true, then the Java2 code generator will generate code that
       * throws an exception whenever an attempt is made to assign a non-UTF-8
       * byte sequence to a string field.
       * Message reflection will do the same.
       * However, an extension field still accepts non-UTF-8 byte sequences.
       * This option has no effect on when used with the lite runtime.
       * </pre>
       *
       * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
       * @return The javaStringCheckUtf8.
       */
      @java.lang.Override
      public boolean getJavaStringCheckUtf8() {
        return instance.getJavaStringCheckUtf8();
      }
      /**
       * <pre>
       * If set true, then the Java2 code generator will generate code that
       * throws an exception whenever an attempt is made to assign a non-UTF-8
       * byte sequence to a string field.
       * Message reflection will do the same.
       * However, an extension field still accepts non-UTF-8 byte sequences.
       * This option has no effect on when used with the lite runtime.
       * </pre>
       *
       * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
       * @param value The javaStringCheckUtf8 to set.
       * @return This builder for chaining.
       */
      public Builder setJavaStringCheckUtf8(boolean value) {
        copyOnWrite();
        instance.setJavaStringCheckUtf8(value);
        return this;
      }
      /**
       * <pre>
       * If set true, then the Java2 code generator will generate code that
       * throws an exception whenever an attempt is made to assign a non-UTF-8
       * byte sequence to a string field.
       * Message reflection will do the same.
       * However, an extension field still accepts non-UTF-8 byte sequences.
       * This option has no effect on when used with the lite runtime.
       * </pre>
       *
       * <code>optional bool java_string_check_utf8 = 27 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearJavaStringCheckUtf8() {
        copyOnWrite();
        instance.clearJavaStringCheckUtf8();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
       * @return Whether the optimizeFor field is set.
       */
      @java.lang.Override
      public boolean hasOptimizeFor() {
        return instance.hasOptimizeFor();
      }
      /**
       * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
       * @return The optimizeFor.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode getOptimizeFor() {
        return instance.getOptimizeFor();
      }
      /**
       * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
       * @param value The enum numeric value on the wire for optimizeFor to set.
       * @return This builder for chaining.
       */
      public Builder setOptimizeFor(com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode value) {
        copyOnWrite();
        instance.setOptimizeFor(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];</code>
       * @return This builder for chaining.
       */
      public Builder clearOptimizeFor() {
        copyOnWrite();
        instance.clearOptimizeFor();
        return this;
      }

      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @return Whether the goPackage field is set.
       */
      @java.lang.Override
      public boolean hasGoPackage() {
        return instance.hasGoPackage();
      }
      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @return The goPackage.
       */
      @java.lang.Override
      public java.lang.String getGoPackage() {
        return instance.getGoPackage();
      }
      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @return The bytes for goPackage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getGoPackageBytes() {
        return instance.getGoPackageBytes();
      }
      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @param value The goPackage to set.
       * @return This builder for chaining.
       */
      public Builder setGoPackage(
          java.lang.String value) {
        copyOnWrite();
        instance.setGoPackage(value);
        return this;
      }
      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearGoPackage() {
        copyOnWrite();
        instance.clearGoPackage();
        return this;
      }
      /**
       * <pre>
       * Sets the Go package where structs generated from this .proto will be
       * placed. If omitted, the Go package will be derived from the following:
       *   - The basename of the package import path, if provided.
       *   - Otherwise, the package statement in the .proto file, if present.
       *   - Otherwise, the basename of the .proto file, without extension.
       * </pre>
       *
       * <code>optional string go_package = 11;</code>
       * @param value The bytes for goPackage to set.
       * @return This builder for chaining.
       */
      public Builder setGoPackageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setGoPackageBytes(value);
        return this;
      }

      /**
       * <pre>
       * Should generic services be generated in each language?  "Generic" services
       * are not specific to any particular RPC system.  They are generated by the
       * main code generators in each language (without additional plugins).
       * Generic services were the only kind of service generation supported by
       * early versions of google.protobuf.
       * Generic services are now considered deprecated in favor of using plugins
       * that generate code specific to your particular RPC system.  Therefore,
       * these default to false.  Old code which depends on generic services should
       * explicitly set them to true.
       * </pre>
       *
       * <code>optional bool cc_generic_services = 16 [default = false];</code>
       * @return Whether the ccGenericServices field is set.
       */
      @java.lang.Override
      public boolean hasCcGenericServices() {
        return instance.hasCcGenericServices();
      }
      /**
       * <pre>
       * Should generic services be generated in each language?  "Generic" services
       * are not specific to any particular RPC system.  They are generated by the
       * main code generators in each language (without additional plugins).
       * Generic services were the only kind of service generation supported by
       * early versions of google.protobuf.
       * Generic services are now considered deprecated in favor of using plugins
       * that generate code specific to your particular RPC system.  Therefore,
       * these default to false.  Old code which depends on generic services should
       * explicitly set them to true.
       * </pre>
       *
       * <code>optional bool cc_generic_services = 16 [default = false];</code>
       * @return The ccGenericServices.
       */
      @java.lang.Override
      public boolean getCcGenericServices() {
        return instance.getCcGenericServices();
      }
      /**
       * <pre>
       * Should generic services be generated in each language?  "Generic" services
       * are not specific to any particular RPC system.  They are generated by the
       * main code generators in each language (without additional plugins).
       * Generic services were the only kind of service generation supported by
       * early versions of google.protobuf.
       * Generic services are now considered deprecated in favor of using plugins
       * that generate code specific to your particular RPC system.  Therefore,
       * these default to false.  Old code which depends on generic services should
       * explicitly set them to true.
       * </pre>
       *
       * <code>optional bool cc_generic_services = 16 [default = false];</code>
       * @param value The ccGenericServices to set.
       * @return This builder for chaining.
       */
      public Builder setCcGenericServices(boolean value) {
        copyOnWrite();
        instance.setCcGenericServices(value);
        return this;
      }
      /**
       * <pre>
       * Should generic services be generated in each language?  "Generic" services
       * are not specific to any particular RPC system.  They are generated by the
       * main code generators in each language (without additional plugins).
       * Generic services were the only kind of service generation supported by
       * early versions of google.protobuf.
       * Generic services are now considered deprecated in favor of using plugins
       * that generate code specific to your particular RPC system.  Therefore,
       * these default to false.  Old code which depends on generic services should
       * explicitly set them to true.
       * </pre>
       *
       * <code>optional bool cc_generic_services = 16 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearCcGenericServices() {
        copyOnWrite();
        instance.clearCcGenericServices();
        return this;
      }

      /**
       * <code>optional bool java_generic_services = 17 [default = false];</code>
       * @return Whether the javaGenericServices field is set.
       */
      @java.lang.Override
      public boolean hasJavaGenericServices() {
        return instance.hasJavaGenericServices();
      }
      /**
       * <code>optional bool java_generic_services = 17 [default = false];</code>
       * @return The javaGenericServices.
       */
      @java.lang.Override
      public boolean getJavaGenericServices() {
        return instance.getJavaGenericServices();
      }
      /**
       * <code>optional bool java_generic_services = 17 [default = false];</code>
       * @param value The javaGenericServices to set.
       * @return This builder for chaining.
       */
      public Builder setJavaGenericServices(boolean value) {
        copyOnWrite();
        instance.setJavaGenericServices(value);
        return this;
      }
      /**
       * <code>optional bool java_generic_services = 17 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearJavaGenericServices() {
        copyOnWrite();
        instance.clearJavaGenericServices();
        return this;
      }

      /**
       * <code>optional bool py_generic_services = 18 [default = false];</code>
       * @return Whether the pyGenericServices field is set.
       */
      @java.lang.Override
      public boolean hasPyGenericServices() {
        return instance.hasPyGenericServices();
      }
      /**
       * <code>optional bool py_generic_services = 18 [default = false];</code>
       * @return The pyGenericServices.
       */
      @java.lang.Override
      public boolean getPyGenericServices() {
        return instance.getPyGenericServices();
      }
      /**
       * <code>optional bool py_generic_services = 18 [default = false];</code>
       * @param value The pyGenericServices to set.
       * @return This builder for chaining.
       */
      public Builder setPyGenericServices(boolean value) {
        copyOnWrite();
        instance.setPyGenericServices(value);
        return this;
      }
      /**
       * <code>optional bool py_generic_services = 18 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearPyGenericServices() {
        copyOnWrite();
        instance.clearPyGenericServices();
        return this;
      }

      /**
       * <code>optional bool php_generic_services = 42 [default = false];</code>
       * @return Whether the phpGenericServices field is set.
       */
      @java.lang.Override
      public boolean hasPhpGenericServices() {
        return instance.hasPhpGenericServices();
      }
      /**
       * <code>optional bool php_generic_services = 42 [default = false];</code>
       * @return The phpGenericServices.
       */
      @java.lang.Override
      public boolean getPhpGenericServices() {
        return instance.getPhpGenericServices();
      }
      /**
       * <code>optional bool php_generic_services = 42 [default = false];</code>
       * @param value The phpGenericServices to set.
       * @return This builder for chaining.
       */
      public Builder setPhpGenericServices(boolean value) {
        copyOnWrite();
        instance.setPhpGenericServices(value);
        return this;
      }
      /**
       * <code>optional bool php_generic_services = 42 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearPhpGenericServices() {
        copyOnWrite();
        instance.clearPhpGenericServices();
        return this;
      }

      /**
       * <pre>
       * Is this file deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for everything in the file, or it will be completely ignored; in the very
       * least, this is a formalization for deprecating files.
       * </pre>
       *
       * <code>optional bool deprecated = 23 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this file deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for everything in the file, or it will be completely ignored; in the very
       * least, this is a formalization for deprecating files.
       * </pre>
       *
       * <code>optional bool deprecated = 23 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this file deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for everything in the file, or it will be completely ignored; in the very
       * least, this is a formalization for deprecating files.
       * </pre>
       *
       * <code>optional bool deprecated = 23 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this file deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for everything in the file, or it will be completely ignored; in the very
       * least, this is a formalization for deprecating files.
       * </pre>
       *
       * <code>optional bool deprecated = 23 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * Enables the use of arenas for the proto messages in this file. This applies
       * only to generated classes for C++.
       * </pre>
       *
       * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
       * @return Whether the ccEnableArenas field is set.
       */
      @java.lang.Override
      public boolean hasCcEnableArenas() {
        return instance.hasCcEnableArenas();
      }
      /**
       * <pre>
       * Enables the use of arenas for the proto messages in this file. This applies
       * only to generated classes for C++.
       * </pre>
       *
       * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
       * @return The ccEnableArenas.
       */
      @java.lang.Override
      public boolean getCcEnableArenas() {
        return instance.getCcEnableArenas();
      }
      /**
       * <pre>
       * Enables the use of arenas for the proto messages in this file. This applies
       * only to generated classes for C++.
       * </pre>
       *
       * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
       * @param value The ccEnableArenas to set.
       * @return This builder for chaining.
       */
      public Builder setCcEnableArenas(boolean value) {
        copyOnWrite();
        instance.setCcEnableArenas(value);
        return this;
      }
      /**
       * <pre>
       * Enables the use of arenas for the proto messages in this file. This applies
       * only to generated classes for C++.
       * </pre>
       *
       * <code>optional bool cc_enable_arenas = 31 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearCcEnableArenas() {
        copyOnWrite();
        instance.clearCcEnableArenas();
        return this;
      }

      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @return Whether the objcClassPrefix field is set.
       */
      @java.lang.Override
      public boolean hasObjcClassPrefix() {
        return instance.hasObjcClassPrefix();
      }
      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @return The objcClassPrefix.
       */
      @java.lang.Override
      public java.lang.String getObjcClassPrefix() {
        return instance.getObjcClassPrefix();
      }
      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @return The bytes for objcClassPrefix.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getObjcClassPrefixBytes() {
        return instance.getObjcClassPrefixBytes();
      }
      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @param value The objcClassPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setObjcClassPrefix(
          java.lang.String value) {
        copyOnWrite();
        instance.setObjcClassPrefix(value);
        return this;
      }
      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @return This builder for chaining.
       */
      public Builder clearObjcClassPrefix() {
        copyOnWrite();
        instance.clearObjcClassPrefix();
        return this;
      }
      /**
       * <pre>
       * Sets the objective c class prefix which is prepended to all objective c
       * generated classes from this .proto. There is no default.
       * </pre>
       *
       * <code>optional string objc_class_prefix = 36;</code>
       * @param value The bytes for objcClassPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setObjcClassPrefixBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setObjcClassPrefixBytes(value);
        return this;
      }

      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @return Whether the csharpNamespace field is set.
       */
      @java.lang.Override
      public boolean hasCsharpNamespace() {
        return instance.hasCsharpNamespace();
      }
      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @return The csharpNamespace.
       */
      @java.lang.Override
      public java.lang.String getCsharpNamespace() {
        return instance.getCsharpNamespace();
      }
      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @return The bytes for csharpNamespace.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCsharpNamespaceBytes() {
        return instance.getCsharpNamespaceBytes();
      }
      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @param value The csharpNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setCsharpNamespace(
          java.lang.String value) {
        copyOnWrite();
        instance.setCsharpNamespace(value);
        return this;
      }
      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @return This builder for chaining.
       */
      public Builder clearCsharpNamespace() {
        copyOnWrite();
        instance.clearCsharpNamespace();
        return this;
      }
      /**
       * <pre>
       * Namespace for generated classes; defaults to the package.
       * </pre>
       *
       * <code>optional string csharp_namespace = 37;</code>
       * @param value The bytes for csharpNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setCsharpNamespaceBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCsharpNamespaceBytes(value);
        return this;
      }

      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @return Whether the swiftPrefix field is set.
       */
      @java.lang.Override
      public boolean hasSwiftPrefix() {
        return instance.hasSwiftPrefix();
      }
      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @return The swiftPrefix.
       */
      @java.lang.Override
      public java.lang.String getSwiftPrefix() {
        return instance.getSwiftPrefix();
      }
      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @return The bytes for swiftPrefix.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSwiftPrefixBytes() {
        return instance.getSwiftPrefixBytes();
      }
      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @param value The swiftPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setSwiftPrefix(
          java.lang.String value) {
        copyOnWrite();
        instance.setSwiftPrefix(value);
        return this;
      }
      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @return This builder for chaining.
       */
      public Builder clearSwiftPrefix() {
        copyOnWrite();
        instance.clearSwiftPrefix();
        return this;
      }
      /**
       * <pre>
       * By default Swift generators will take the proto package and CamelCase it
       * replacing '.' with underscore and use that to prefix the types/symbols
       * defined. When this options is provided, they will use this value instead
       * to prefix the types/symbols defined.
       * </pre>
       *
       * <code>optional string swift_prefix = 39;</code>
       * @param value The bytes for swiftPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setSwiftPrefixBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSwiftPrefixBytes(value);
        return this;
      }

      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @return Whether the phpClassPrefix field is set.
       */
      @java.lang.Override
      public boolean hasPhpClassPrefix() {
        return instance.hasPhpClassPrefix();
      }
      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @return The phpClassPrefix.
       */
      @java.lang.Override
      public java.lang.String getPhpClassPrefix() {
        return instance.getPhpClassPrefix();
      }
      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @return The bytes for phpClassPrefix.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPhpClassPrefixBytes() {
        return instance.getPhpClassPrefixBytes();
      }
      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @param value The phpClassPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setPhpClassPrefix(
          java.lang.String value) {
        copyOnWrite();
        instance.setPhpClassPrefix(value);
        return this;
      }
      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @return This builder for chaining.
       */
      public Builder clearPhpClassPrefix() {
        copyOnWrite();
        instance.clearPhpClassPrefix();
        return this;
      }
      /**
       * <pre>
       * Sets the php class prefix which is prepended to all php generated classes
       * from this .proto. Default is empty.
       * </pre>
       *
       * <code>optional string php_class_prefix = 40;</code>
       * @param value The bytes for phpClassPrefix to set.
       * @return This builder for chaining.
       */
      public Builder setPhpClassPrefixBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPhpClassPrefixBytes(value);
        return this;
      }

      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @return Whether the phpNamespace field is set.
       */
      @java.lang.Override
      public boolean hasPhpNamespace() {
        return instance.hasPhpNamespace();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @return The phpNamespace.
       */
      @java.lang.Override
      public java.lang.String getPhpNamespace() {
        return instance.getPhpNamespace();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @return The bytes for phpNamespace.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPhpNamespaceBytes() {
        return instance.getPhpNamespaceBytes();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @param value The phpNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setPhpNamespace(
          java.lang.String value) {
        copyOnWrite();
        instance.setPhpNamespace(value);
        return this;
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @return This builder for chaining.
       */
      public Builder clearPhpNamespace() {
        copyOnWrite();
        instance.clearPhpNamespace();
        return this;
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated classes. Default
       * is empty. When this option is empty, the package name will be used for
       * determining the namespace.
       * </pre>
       *
       * <code>optional string php_namespace = 41;</code>
       * @param value The bytes for phpNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setPhpNamespaceBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPhpNamespaceBytes(value);
        return this;
      }

      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @return Whether the phpMetadataNamespace field is set.
       */
      @java.lang.Override
      public boolean hasPhpMetadataNamespace() {
        return instance.hasPhpMetadataNamespace();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @return The phpMetadataNamespace.
       */
      @java.lang.Override
      public java.lang.String getPhpMetadataNamespace() {
        return instance.getPhpMetadataNamespace();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @return The bytes for phpMetadataNamespace.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPhpMetadataNamespaceBytes() {
        return instance.getPhpMetadataNamespaceBytes();
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @param value The phpMetadataNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setPhpMetadataNamespace(
          java.lang.String value) {
        copyOnWrite();
        instance.setPhpMetadataNamespace(value);
        return this;
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @return This builder for chaining.
       */
      public Builder clearPhpMetadataNamespace() {
        copyOnWrite();
        instance.clearPhpMetadataNamespace();
        return this;
      }
      /**
       * <pre>
       * Use this option to change the namespace of php generated metadata classes.
       * Default is empty. When this option is empty, the proto file name will be
       * used for determining the namespace.
       * </pre>
       *
       * <code>optional string php_metadata_namespace = 44;</code>
       * @param value The bytes for phpMetadataNamespace to set.
       * @return This builder for chaining.
       */
      public Builder setPhpMetadataNamespaceBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPhpMetadataNamespaceBytes(value);
        return this;
      }

      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @return Whether the rubyPackage field is set.
       */
      @java.lang.Override
      public boolean hasRubyPackage() {
        return instance.hasRubyPackage();
      }
      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @return The rubyPackage.
       */
      @java.lang.Override
      public java.lang.String getRubyPackage() {
        return instance.getRubyPackage();
      }
      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @return The bytes for rubyPackage.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getRubyPackageBytes() {
        return instance.getRubyPackageBytes();
      }
      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @param value The rubyPackage to set.
       * @return This builder for chaining.
       */
      public Builder setRubyPackage(
          java.lang.String value) {
        copyOnWrite();
        instance.setRubyPackage(value);
        return this;
      }
      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @return This builder for chaining.
       */
      public Builder clearRubyPackage() {
        copyOnWrite();
        instance.clearRubyPackage();
        return this;
      }
      /**
       * <pre>
       * Use this option to change the package of ruby generated classes. Default
       * is empty. When this option is not set, the package name will be used for
       * determining the ruby package.
       * </pre>
       *
       * <code>optional string ruby_package = 45;</code>
       * @param value The bytes for rubyPackage to set.
       * @return This builder for chaining.
       */
      public Builder setRubyPackageBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRubyPackageBytes(value);
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 50;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here.
       * See the documentation for the "Options" section above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FileOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FileOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "javaPackage_",
              "javaOuterClassname_",
              "optimizeFor_",
              com.google.protobuf.DescriptorProtos.FileOptions.OptimizeMode.internalGetVerifier(),
              "javaMultipleFiles_",
              "goPackage_",
              "ccGenericServices_",
              "javaGenericServices_",
              "pyGenericServices_",
              "javaGenerateEqualsAndHash_",
              "deprecated_",
              "javaStringCheckUtf8_",
              "ccEnableArenas_",
              "objcClassPrefix_",
              "csharpNamespace_",
              "swiftPrefix_",
              "phpClassPrefix_",
              "phpNamespace_",
              "phpGenericServices_",
              "phpMetadataNamespace_",
              "rubyPackage_",
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0016\u0000\u0001\u0001\u03e7\u0016\u0000\u0001\u0002\u0001\u1008\u0000\b" +
                "\u1008\u0001\t\u100c\u0005\n\u1007\u0002\u000b\u1008\u0006\u0010\u1007\u0007\u0011" +
                "\u1007\b\u0012\u1007\t\u0014\u1007\u0003\u0017\u1007\u000b\u001b\u1007\u0004\u001f" +
                "\u1007\f$\u1008\r%\u1008\u000e\'\u1008\u000f(\u1008\u0010)\u1008\u0011*\u1007\n," +
                "\u1008\u0012-\u1008\u00132\u1409\u0014\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FileOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FileOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FileOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FileOptions)
    private static final com.google.protobuf.DescriptorProtos.FileOptions DEFAULT_INSTANCE;
    static {
      FileOptions defaultInstance = new FileOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FileOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FileOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FileOptions> PARSER;

    public static com.google.protobuf.Parser<FileOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MessageOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.MessageOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                MessageOptions, MessageOptions.Builder> {

    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     * @return Whether the messageSetWireFormat field is set.
     */
    boolean hasMessageSetWireFormat();
    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     * @return The messageSetWireFormat.
     */
    boolean getMessageSetWireFormat();

    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     * @return Whether the noStandardDescriptorAccessor field is set.
     */
    boolean hasNoStandardDescriptorAccessor();
    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     * @return The noStandardDescriptorAccessor.
     */
    boolean getNoStandardDescriptorAccessor();

    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     * @return Whether the mapEntry field is set.
     */
    boolean hasMapEntry();
    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     * @return The mapEntry.
     */
    boolean getMapEntry();

    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
     */
    @java.lang.Deprecated boolean hasDeprecatedLegacyJsonFieldConflicts();
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     * @return The deprecatedLegacyJsonFieldConflicts.
     */
    @java.lang.Deprecated boolean getDeprecatedLegacyJsonFieldConflicts();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.MessageOptions}
   */
  public  static final class MessageOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        MessageOptions, MessageOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.MessageOptions)
      MessageOptionsOrBuilder {
    private MessageOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int MESSAGE_SET_WIRE_FORMAT_FIELD_NUMBER = 1;
    private boolean messageSetWireFormat_;
    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     * @return Whether the messageSetWireFormat field is set.
     */
    @java.lang.Override
    public boolean hasMessageSetWireFormat() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     * @return The messageSetWireFormat.
     */
    @java.lang.Override
    public boolean getMessageSetWireFormat() {
      return messageSetWireFormat_;
    }
    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     * @param value The messageSetWireFormat to set.
     */
    private void setMessageSetWireFormat(boolean value) {
      bitField0_ |= 0x00000001;
      messageSetWireFormat_ = value;
    }
    /**
     * <pre>
     * Set true to use the old proto1 MessageSet wire format for extensions.
     * This is provided for backwards-compatibility with the MessageSet wire
     * format.  You should not use this for any other reason:  It's less
     * efficient, has fewer features, and is more complicated.
     * The message must be defined exactly as follows:
     *   message Foo {
     *     option message_set_wire_format = true;
     *     extensions 4 to max;
     *   }
     * Note that the message cannot have any defined fields; MessageSets only
     * have extensions.
     * All extensions of your type must be singular messages; e.g. they cannot
     * be int32s, enums, or repeated messages.
     * Because this is an option, the above two restrictions are not enforced by
     * the protocol compiler.
     * </pre>
     *
     * <code>optional bool message_set_wire_format = 1 [default = false];</code>
     */
    private void clearMessageSetWireFormat() {
      bitField0_ = (bitField0_ & ~0x00000001);
      messageSetWireFormat_ = false;
    }

    public static final int NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUMBER = 2;
    private boolean noStandardDescriptorAccessor_;
    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     * @return Whether the noStandardDescriptorAccessor field is set.
     */
    @java.lang.Override
    public boolean hasNoStandardDescriptorAccessor() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     * @return The noStandardDescriptorAccessor.
     */
    @java.lang.Override
    public boolean getNoStandardDescriptorAccessor() {
      return noStandardDescriptorAccessor_;
    }
    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     * @param value The noStandardDescriptorAccessor to set.
     */
    private void setNoStandardDescriptorAccessor(boolean value) {
      bitField0_ |= 0x00000002;
      noStandardDescriptorAccessor_ = value;
    }
    /**
     * <pre>
     * Disables the generation of the standard "descriptor()" accessor, which can
     * conflict with a field of the same name.  This is meant to make migration
     * from proto1 easier; new code should avoid fields named "descriptor".
     * </pre>
     *
     * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
     */
    private void clearNoStandardDescriptorAccessor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      noStandardDescriptorAccessor_ = false;
    }

    public static final int DEPRECATED_FIELD_NUMBER = 3;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000004;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this message deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the message, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating messages.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000004);
      deprecated_ = false;
    }

    public static final int MAP_ENTRY_FIELD_NUMBER = 7;
    private boolean mapEntry_;
    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     * @return Whether the mapEntry field is set.
     */
    @java.lang.Override
    public boolean hasMapEntry() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     * @return The mapEntry.
     */
    @java.lang.Override
    public boolean getMapEntry() {
      return mapEntry_;
    }
    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     * @param value The mapEntry to set.
     */
    private void setMapEntry(boolean value) {
      bitField0_ |= 0x00000008;
      mapEntry_ = value;
    }
    /**
     * <pre>
     * NOTE: Do not set the option in .proto files. Always use the maps syntax
     * instead. The option should only be implicitly set by the proto compiler
     * parser.
     * Whether the message is an automatically generated map entry type for the
     * maps field.
     * For maps fields:
     *     map&lt;KeyType, ValueType&gt; map_field = 1;
     * The parsed descriptor looks like:
     *     message MapFieldEntry {
     *         option map_entry = true;
     *         optional KeyType key = 1;
     *         optional ValueType value = 2;
     *     }
     *     repeated MapFieldEntry map_field = 1;
     * Implementations may choose not to generate the map_entry=true message, but
     * use a native map in the target language to hold the keys and values.
     * The reflection APIs in such implementations still need to work as
     * if the field is a repeated message field.
     * </pre>
     *
     * <code>optional bool map_entry = 7;</code>
     */
    private void clearMapEntry() {
      bitField0_ = (bitField0_ & ~0x00000008);
      mapEntry_ = false;
    }

    public static final int DEPRECATED_LEGACY_JSON_FIELD_CONFLICTS_FIELD_NUMBER = 11;
    private boolean deprecatedLegacyJsonFieldConflicts_;
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasDeprecatedLegacyJsonFieldConflicts() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     * @return The deprecatedLegacyJsonFieldConflicts.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getDeprecatedLegacyJsonFieldConflicts() {
      return deprecatedLegacyJsonFieldConflicts_;
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     * @param value The deprecatedLegacyJsonFieldConflicts to set.
     */
    private void setDeprecatedLegacyJsonFieldConflicts(boolean value) {
      bitField0_ |= 0x00000010;
      deprecatedLegacyJsonFieldConflicts_ = value;
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * This should only be used as a temporary measure against broken builds due
     * to the change in behavior for JSON field name conflicts.
     * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
     * teams have had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
     * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=578
     */
    private void clearDeprecatedLegacyJsonFieldConflicts() {
      bitField0_ = (bitField0_ & ~0x00000010);
      deprecatedLegacyJsonFieldConflicts_ = false;
    }

    public static final int FEATURES_FIELD_NUMBER = 12;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 12;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MessageOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.MessageOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.MessageOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.MessageOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.MessageOptions)
        com.google.protobuf.DescriptorProtos.MessageOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.MessageOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Set true to use the old proto1 MessageSet wire format for extensions.
       * This is provided for backwards-compatibility with the MessageSet wire
       * format.  You should not use this for any other reason:  It's less
       * efficient, has fewer features, and is more complicated.
       * The message must be defined exactly as follows:
       *   message Foo {
       *     option message_set_wire_format = true;
       *     extensions 4 to max;
       *   }
       * Note that the message cannot have any defined fields; MessageSets only
       * have extensions.
       * All extensions of your type must be singular messages; e.g. they cannot
       * be int32s, enums, or repeated messages.
       * Because this is an option, the above two restrictions are not enforced by
       * the protocol compiler.
       * </pre>
       *
       * <code>optional bool message_set_wire_format = 1 [default = false];</code>
       * @return Whether the messageSetWireFormat field is set.
       */
      @java.lang.Override
      public boolean hasMessageSetWireFormat() {
        return instance.hasMessageSetWireFormat();
      }
      /**
       * <pre>
       * Set true to use the old proto1 MessageSet wire format for extensions.
       * This is provided for backwards-compatibility with the MessageSet wire
       * format.  You should not use this for any other reason:  It's less
       * efficient, has fewer features, and is more complicated.
       * The message must be defined exactly as follows:
       *   message Foo {
       *     option message_set_wire_format = true;
       *     extensions 4 to max;
       *   }
       * Note that the message cannot have any defined fields; MessageSets only
       * have extensions.
       * All extensions of your type must be singular messages; e.g. they cannot
       * be int32s, enums, or repeated messages.
       * Because this is an option, the above two restrictions are not enforced by
       * the protocol compiler.
       * </pre>
       *
       * <code>optional bool message_set_wire_format = 1 [default = false];</code>
       * @return The messageSetWireFormat.
       */
      @java.lang.Override
      public boolean getMessageSetWireFormat() {
        return instance.getMessageSetWireFormat();
      }
      /**
       * <pre>
       * Set true to use the old proto1 MessageSet wire format for extensions.
       * This is provided for backwards-compatibility with the MessageSet wire
       * format.  You should not use this for any other reason:  It's less
       * efficient, has fewer features, and is more complicated.
       * The message must be defined exactly as follows:
       *   message Foo {
       *     option message_set_wire_format = true;
       *     extensions 4 to max;
       *   }
       * Note that the message cannot have any defined fields; MessageSets only
       * have extensions.
       * All extensions of your type must be singular messages; e.g. they cannot
       * be int32s, enums, or repeated messages.
       * Because this is an option, the above two restrictions are not enforced by
       * the protocol compiler.
       * </pre>
       *
       * <code>optional bool message_set_wire_format = 1 [default = false];</code>
       * @param value The messageSetWireFormat to set.
       * @return This builder for chaining.
       */
      public Builder setMessageSetWireFormat(boolean value) {
        copyOnWrite();
        instance.setMessageSetWireFormat(value);
        return this;
      }
      /**
       * <pre>
       * Set true to use the old proto1 MessageSet wire format for extensions.
       * This is provided for backwards-compatibility with the MessageSet wire
       * format.  You should not use this for any other reason:  It's less
       * efficient, has fewer features, and is more complicated.
       * The message must be defined exactly as follows:
       *   message Foo {
       *     option message_set_wire_format = true;
       *     extensions 4 to max;
       *   }
       * Note that the message cannot have any defined fields; MessageSets only
       * have extensions.
       * All extensions of your type must be singular messages; e.g. they cannot
       * be int32s, enums, or repeated messages.
       * Because this is an option, the above two restrictions are not enforced by
       * the protocol compiler.
       * </pre>
       *
       * <code>optional bool message_set_wire_format = 1 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearMessageSetWireFormat() {
        copyOnWrite();
        instance.clearMessageSetWireFormat();
        return this;
      }

      /**
       * <pre>
       * Disables the generation of the standard "descriptor()" accessor, which can
       * conflict with a field of the same name.  This is meant to make migration
       * from proto1 easier; new code should avoid fields named "descriptor".
       * </pre>
       *
       * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
       * @return Whether the noStandardDescriptorAccessor field is set.
       */
      @java.lang.Override
      public boolean hasNoStandardDescriptorAccessor() {
        return instance.hasNoStandardDescriptorAccessor();
      }
      /**
       * <pre>
       * Disables the generation of the standard "descriptor()" accessor, which can
       * conflict with a field of the same name.  This is meant to make migration
       * from proto1 easier; new code should avoid fields named "descriptor".
       * </pre>
       *
       * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
       * @return The noStandardDescriptorAccessor.
       */
      @java.lang.Override
      public boolean getNoStandardDescriptorAccessor() {
        return instance.getNoStandardDescriptorAccessor();
      }
      /**
       * <pre>
       * Disables the generation of the standard "descriptor()" accessor, which can
       * conflict with a field of the same name.  This is meant to make migration
       * from proto1 easier; new code should avoid fields named "descriptor".
       * </pre>
       *
       * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
       * @param value The noStandardDescriptorAccessor to set.
       * @return This builder for chaining.
       */
      public Builder setNoStandardDescriptorAccessor(boolean value) {
        copyOnWrite();
        instance.setNoStandardDescriptorAccessor(value);
        return this;
      }
      /**
       * <pre>
       * Disables the generation of the standard "descriptor()" accessor, which can
       * conflict with a field of the same name.  This is meant to make migration
       * from proto1 easier; new code should avoid fields named "descriptor".
       * </pre>
       *
       * <code>optional bool no_standard_descriptor_accessor = 2 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearNoStandardDescriptorAccessor() {
        copyOnWrite();
        instance.clearNoStandardDescriptorAccessor();
        return this;
      }

      /**
       * <pre>
       * Is this message deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the message, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating messages.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this message deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the message, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating messages.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this message deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the message, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating messages.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this message deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the message, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating messages.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * NOTE: Do not set the option in .proto files. Always use the maps syntax
       * instead. The option should only be implicitly set by the proto compiler
       * parser.
       * Whether the message is an automatically generated map entry type for the
       * maps field.
       * For maps fields:
       *     map&lt;KeyType, ValueType&gt; map_field = 1;
       * The parsed descriptor looks like:
       *     message MapFieldEntry {
       *         option map_entry = true;
       *         optional KeyType key = 1;
       *         optional ValueType value = 2;
       *     }
       *     repeated MapFieldEntry map_field = 1;
       * Implementations may choose not to generate the map_entry=true message, but
       * use a native map in the target language to hold the keys and values.
       * The reflection APIs in such implementations still need to work as
       * if the field is a repeated message field.
       * </pre>
       *
       * <code>optional bool map_entry = 7;</code>
       * @return Whether the mapEntry field is set.
       */
      @java.lang.Override
      public boolean hasMapEntry() {
        return instance.hasMapEntry();
      }
      /**
       * <pre>
       * NOTE: Do not set the option in .proto files. Always use the maps syntax
       * instead. The option should only be implicitly set by the proto compiler
       * parser.
       * Whether the message is an automatically generated map entry type for the
       * maps field.
       * For maps fields:
       *     map&lt;KeyType, ValueType&gt; map_field = 1;
       * The parsed descriptor looks like:
       *     message MapFieldEntry {
       *         option map_entry = true;
       *         optional KeyType key = 1;
       *         optional ValueType value = 2;
       *     }
       *     repeated MapFieldEntry map_field = 1;
       * Implementations may choose not to generate the map_entry=true message, but
       * use a native map in the target language to hold the keys and values.
       * The reflection APIs in such implementations still need to work as
       * if the field is a repeated message field.
       * </pre>
       *
       * <code>optional bool map_entry = 7;</code>
       * @return The mapEntry.
       */
      @java.lang.Override
      public boolean getMapEntry() {
        return instance.getMapEntry();
      }
      /**
       * <pre>
       * NOTE: Do not set the option in .proto files. Always use the maps syntax
       * instead. The option should only be implicitly set by the proto compiler
       * parser.
       * Whether the message is an automatically generated map entry type for the
       * maps field.
       * For maps fields:
       *     map&lt;KeyType, ValueType&gt; map_field = 1;
       * The parsed descriptor looks like:
       *     message MapFieldEntry {
       *         option map_entry = true;
       *         optional KeyType key = 1;
       *         optional ValueType value = 2;
       *     }
       *     repeated MapFieldEntry map_field = 1;
       * Implementations may choose not to generate the map_entry=true message, but
       * use a native map in the target language to hold the keys and values.
       * The reflection APIs in such implementations still need to work as
       * if the field is a repeated message field.
       * </pre>
       *
       * <code>optional bool map_entry = 7;</code>
       * @param value The mapEntry to set.
       * @return This builder for chaining.
       */
      public Builder setMapEntry(boolean value) {
        copyOnWrite();
        instance.setMapEntry(value);
        return this;
      }
      /**
       * <pre>
       * NOTE: Do not set the option in .proto files. Always use the maps syntax
       * instead. The option should only be implicitly set by the proto compiler
       * parser.
       * Whether the message is an automatically generated map entry type for the
       * maps field.
       * For maps fields:
       *     map&lt;KeyType, ValueType&gt; map_field = 1;
       * The parsed descriptor looks like:
       *     message MapFieldEntry {
       *         option map_entry = true;
       *         optional KeyType key = 1;
       *         optional ValueType value = 2;
       *     }
       *     repeated MapFieldEntry map_field = 1;
       * Implementations may choose not to generate the map_entry=true message, but
       * use a native map in the target language to hold the keys and values.
       * The reflection APIs in such implementations still need to work as
       * if the field is a repeated message field.
       * </pre>
       *
       * <code>optional bool map_entry = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearMapEntry() {
        copyOnWrite();
        instance.clearMapEntry();
        return this;
      }

      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * This should only be used as a temporary measure against broken builds due
       * to the change in behavior for JSON field name conflicts.
       * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
       * teams have had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
       * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=578
       * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasDeprecatedLegacyJsonFieldConflicts() {
        return instance.hasDeprecatedLegacyJsonFieldConflicts();
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * This should only be used as a temporary measure against broken builds due
       * to the change in behavior for JSON field name conflicts.
       * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
       * teams have had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
       * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=578
       * @return The deprecatedLegacyJsonFieldConflicts.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getDeprecatedLegacyJsonFieldConflicts() {
        return instance.getDeprecatedLegacyJsonFieldConflicts();
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * This should only be used as a temporary measure against broken builds due
       * to the change in behavior for JSON field name conflicts.
       * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
       * teams have had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
       * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=578
       * @param value The deprecatedLegacyJsonFieldConflicts to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setDeprecatedLegacyJsonFieldConflicts(boolean value) {
        copyOnWrite();
        instance.setDeprecatedLegacyJsonFieldConflicts(value);
        return this;
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * This should only be used as a temporary measure against broken builds due
       * to the change in behavior for JSON field name conflicts.
       * TODO(b/261750190) This is legacy behavior we plan to remove once downstream
       * teams have had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];</code>
       * @deprecated google.protobuf.MessageOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=578
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearDeprecatedLegacyJsonFieldConflicts() {
        copyOnWrite();
        instance.clearDeprecatedLegacyJsonFieldConflicts();
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 12;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.MessageOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.MessageOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "messageSetWireFormat_",
              "noStandardDescriptorAccessor_",
              "deprecated_",
              "mapEntry_",
              "deprecatedLegacyJsonFieldConflicts_",
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0001\u0001\u03e7\u0007\u0000\u0001\u0002\u0001\u1007\u0000\u0002" +
                "\u1007\u0001\u0003\u1007\u0002\u0007\u1007\u0003\u000b\u1007\u0004\f\u1409\u0005" +
                "\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.MessageOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.MessageOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.MessageOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.MessageOptions)
    private static final com.google.protobuf.DescriptorProtos.MessageOptions DEFAULT_INSTANCE;
    static {
      MessageOptions defaultInstance = new MessageOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MessageOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.MessageOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MessageOptions> PARSER;

    public static com.google.protobuf.Parser<MessageOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FieldOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.FieldOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                FieldOptions, FieldOptions.Builder> {

    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     * @return Whether the ctype field is set.
     */
    boolean hasCtype();
    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     * @return The ctype.
     */
    com.google.protobuf.DescriptorProtos.FieldOptions.CType getCtype();

    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     * @return Whether the packed field is set.
     */
    boolean hasPacked();
    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     * @return The packed.
     */
    boolean getPacked();

    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     * @return Whether the jstype field is set.
     */
    boolean hasJstype();
    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     * @return The jstype.
     */
    com.google.protobuf.DescriptorProtos.FieldOptions.JSType getJstype();

    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     * @return Whether the lazy field is set.
     */
    boolean hasLazy();
    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     * @return The lazy.
     */
    boolean getLazy();

    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     * @return Whether the unverifiedLazy field is set.
     */
    boolean hasUnverifiedLazy();
    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     * @return The unverifiedLazy.
     */
    boolean getUnverifiedLazy();

    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     * @return Whether the weak field is set.
     */
    boolean hasWeak();
    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     * @return The weak.
     */
    boolean getWeak();

    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     * @return Whether the debugRedact field is set.
     */
    boolean hasDebugRedact();
    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     * @return The debugRedact.
     */
    boolean getDebugRedact();

    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     * @return Whether the retention field is set.
     */
    boolean hasRetention();
    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     * @return The retention.
     */
    com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention getRetention();

    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @return A list containing the targets.
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> getTargetsList();
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @return The count of targets.
     */
    int getTargetsCount();
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @param index The index of the element to return.
     * @return The targets at the given index.
     */
    com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType getTargets(int index);

    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> 
        getEditionDefaultsList();
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault getEditionDefaults(int index);
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    int getEditionDefaultsCount();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.FieldOptions}
   */
  public  static final class FieldOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        FieldOptions, FieldOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FieldOptions)
      FieldOptionsOrBuilder {
    private FieldOptions() {
      targets_ = emptyIntList();
      editionDefaults_ = emptyProtobufList();
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * Protobuf enum {@code google.protobuf.FieldOptions.CType}
     */
    public enum CType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Default mode.
       * </pre>
       *
       * <code>STRING = 0;</code>
       */
      STRING(0),
      /**
       * <pre>
       * The option [ctype=CORD] may be applied to a non-repeated field of type
       * "bytes". It indicates that in C++, the data should be stored in a Cord
       * instead of a string.  For very large strings, this may reduce memory
       * fragmentation. It may also allow better performance when parsing from a
       * Cord, or when parsing with aliasing enabled, as the parsed Cord may then
       * alias the original buffer.
       * </pre>
       *
       * <code>CORD = 1;</code>
       */
      CORD(1),
      /**
       * <code>STRING_PIECE = 2;</code>
       */
      STRING_PIECE(2),
      ;

      /**
       * <pre>
       * Default mode.
       * </pre>
       *
       * <code>STRING = 0;</code>
       */
      public static final int STRING_VALUE = 0;
      /**
       * <pre>
       * The option [ctype=CORD] may be applied to a non-repeated field of type
       * "bytes". It indicates that in C++, the data should be stored in a Cord
       * instead of a string.  For very large strings, this may reduce memory
       * fragmentation. It may also allow better performance when parsing from a
       * Cord, or when parsing with aliasing enabled, as the parsed Cord may then
       * alias the original buffer.
       * </pre>
       *
       * <code>CORD = 1;</code>
       */
      public static final int CORD_VALUE = 1;
      /**
       * <code>STRING_PIECE = 2;</code>
       */
      public static final int STRING_PIECE_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CType valueOf(int value) {
        return forNumber(value);
      }

      public static CType forNumber(int value) {
        switch (value) {
          case 0: return STRING;
          case 1: return CORD;
          case 2: return STRING_PIECE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          CType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CType>() {
              @java.lang.Override
              public CType findValueByNumber(int number) {
                return CType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return CTypeVerifier.INSTANCE;
      }

      private static final class CTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new CTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return CType.forNumber(number) != null;
              }
            };

      private final int value;

      private CType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldOptions.CType)
    }

    /**
     * Protobuf enum {@code google.protobuf.FieldOptions.JSType}
     */
    public enum JSType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Use the default type.
       * </pre>
       *
       * <code>JS_NORMAL = 0;</code>
       */
      JS_NORMAL(0),
      /**
       * <pre>
       * Use JavaScript strings.
       * </pre>
       *
       * <code>JS_STRING = 1;</code>
       */
      JS_STRING(1),
      /**
       * <pre>
       * Use JavaScript numbers.
       * </pre>
       *
       * <code>JS_NUMBER = 2;</code>
       */
      JS_NUMBER(2),
      ;

      /**
       * <pre>
       * Use the default type.
       * </pre>
       *
       * <code>JS_NORMAL = 0;</code>
       */
      public static final int JS_NORMAL_VALUE = 0;
      /**
       * <pre>
       * Use JavaScript strings.
       * </pre>
       *
       * <code>JS_STRING = 1;</code>
       */
      public static final int JS_STRING_VALUE = 1;
      /**
       * <pre>
       * Use JavaScript numbers.
       * </pre>
       *
       * <code>JS_NUMBER = 2;</code>
       */
      public static final int JS_NUMBER_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static JSType valueOf(int value) {
        return forNumber(value);
      }

      public static JSType forNumber(int value) {
        switch (value) {
          case 0: return JS_NORMAL;
          case 1: return JS_STRING;
          case 2: return JS_NUMBER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<JSType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          JSType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<JSType>() {
              @java.lang.Override
              public JSType findValueByNumber(int number) {
                return JSType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return JSTypeVerifier.INSTANCE;
      }

      private static final class JSTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new JSTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return JSType.forNumber(number) != null;
              }
            };

      private final int value;

      private JSType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldOptions.JSType)
    }

    /**
     * <pre>
     * If set to RETENTION_SOURCE, the option will be omitted from the binary.
     * Note: as of January 2023, support for this is in progress and does not yet
     * have an effect (b/264593489).
     * </pre>
     *
     * Protobuf enum {@code google.protobuf.FieldOptions.OptionRetention}
     */
    public enum OptionRetention
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>RETENTION_UNKNOWN = 0;</code>
       */
      RETENTION_UNKNOWN(0),
      /**
       * <code>RETENTION_RUNTIME = 1;</code>
       */
      RETENTION_RUNTIME(1),
      /**
       * <code>RETENTION_SOURCE = 2;</code>
       */
      RETENTION_SOURCE(2),
      ;

      /**
       * <code>RETENTION_UNKNOWN = 0;</code>
       */
      public static final int RETENTION_UNKNOWN_VALUE = 0;
      /**
       * <code>RETENTION_RUNTIME = 1;</code>
       */
      public static final int RETENTION_RUNTIME_VALUE = 1;
      /**
       * <code>RETENTION_SOURCE = 2;</code>
       */
      public static final int RETENTION_SOURCE_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OptionRetention valueOf(int value) {
        return forNumber(value);
      }

      public static OptionRetention forNumber(int value) {
        switch (value) {
          case 0: return RETENTION_UNKNOWN;
          case 1: return RETENTION_RUNTIME;
          case 2: return RETENTION_SOURCE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OptionRetention>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OptionRetention> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OptionRetention>() {
              @java.lang.Override
              public OptionRetention findValueByNumber(int number) {
                return OptionRetention.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return OptionRetentionVerifier.INSTANCE;
      }

      private static final class OptionRetentionVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new OptionRetentionVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return OptionRetention.forNumber(number) != null;
              }
            };

      private final int value;

      private OptionRetention(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldOptions.OptionRetention)
    }

    /**
     * <pre>
     * This indicates the types of entities that the field may apply to when used
     * as an option. If it is unset, then the field may be freely used as an
     * option on any kind of entity. Note: as of January 2023, support for this is
     * in progress and does not yet have an effect (b/264593489).
     * </pre>
     *
     * Protobuf enum {@code google.protobuf.FieldOptions.OptionTargetType}
     */
    public enum OptionTargetType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>TARGET_TYPE_UNKNOWN = 0;</code>
       */
      TARGET_TYPE_UNKNOWN(0),
      /**
       * <code>TARGET_TYPE_FILE = 1;</code>
       */
      TARGET_TYPE_FILE(1),
      /**
       * <code>TARGET_TYPE_EXTENSION_RANGE = 2;</code>
       */
      TARGET_TYPE_EXTENSION_RANGE(2),
      /**
       * <code>TARGET_TYPE_MESSAGE = 3;</code>
       */
      TARGET_TYPE_MESSAGE(3),
      /**
       * <code>TARGET_TYPE_FIELD = 4;</code>
       */
      TARGET_TYPE_FIELD(4),
      /**
       * <code>TARGET_TYPE_ONEOF = 5;</code>
       */
      TARGET_TYPE_ONEOF(5),
      /**
       * <code>TARGET_TYPE_ENUM = 6;</code>
       */
      TARGET_TYPE_ENUM(6),
      /**
       * <code>TARGET_TYPE_ENUM_ENTRY = 7;</code>
       */
      TARGET_TYPE_ENUM_ENTRY(7),
      /**
       * <code>TARGET_TYPE_SERVICE = 8;</code>
       */
      TARGET_TYPE_SERVICE(8),
      /**
       * <code>TARGET_TYPE_METHOD = 9;</code>
       */
      TARGET_TYPE_METHOD(9),
      ;

      /**
       * <code>TARGET_TYPE_UNKNOWN = 0;</code>
       */
      public static final int TARGET_TYPE_UNKNOWN_VALUE = 0;
      /**
       * <code>TARGET_TYPE_FILE = 1;</code>
       */
      public static final int TARGET_TYPE_FILE_VALUE = 1;
      /**
       * <code>TARGET_TYPE_EXTENSION_RANGE = 2;</code>
       */
      public static final int TARGET_TYPE_EXTENSION_RANGE_VALUE = 2;
      /**
       * <code>TARGET_TYPE_MESSAGE = 3;</code>
       */
      public static final int TARGET_TYPE_MESSAGE_VALUE = 3;
      /**
       * <code>TARGET_TYPE_FIELD = 4;</code>
       */
      public static final int TARGET_TYPE_FIELD_VALUE = 4;
      /**
       * <code>TARGET_TYPE_ONEOF = 5;</code>
       */
      public static final int TARGET_TYPE_ONEOF_VALUE = 5;
      /**
       * <code>TARGET_TYPE_ENUM = 6;</code>
       */
      public static final int TARGET_TYPE_ENUM_VALUE = 6;
      /**
       * <code>TARGET_TYPE_ENUM_ENTRY = 7;</code>
       */
      public static final int TARGET_TYPE_ENUM_ENTRY_VALUE = 7;
      /**
       * <code>TARGET_TYPE_SERVICE = 8;</code>
       */
      public static final int TARGET_TYPE_SERVICE_VALUE = 8;
      /**
       * <code>TARGET_TYPE_METHOD = 9;</code>
       */
      public static final int TARGET_TYPE_METHOD_VALUE = 9;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OptionTargetType valueOf(int value) {
        return forNumber(value);
      }

      public static OptionTargetType forNumber(int value) {
        switch (value) {
          case 0: return TARGET_TYPE_UNKNOWN;
          case 1: return TARGET_TYPE_FILE;
          case 2: return TARGET_TYPE_EXTENSION_RANGE;
          case 3: return TARGET_TYPE_MESSAGE;
          case 4: return TARGET_TYPE_FIELD;
          case 5: return TARGET_TYPE_ONEOF;
          case 6: return TARGET_TYPE_ENUM;
          case 7: return TARGET_TYPE_ENUM_ENTRY;
          case 8: return TARGET_TYPE_SERVICE;
          case 9: return TARGET_TYPE_METHOD;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OptionTargetType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          OptionTargetType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<OptionTargetType>() {
              @java.lang.Override
              public OptionTargetType findValueByNumber(int number) {
                return OptionTargetType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return OptionTargetTypeVerifier.INSTANCE;
      }

      private static final class OptionTargetTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new OptionTargetTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return OptionTargetType.forNumber(number) != null;
              }
            };

      private final int value;

      private OptionTargetType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FieldOptions.OptionTargetType)
    }

    public interface EditionDefaultOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.FieldOptions.EditionDefault)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>optional string edition = 1;</code>
       * @return Whether the edition field is set.
       */
      boolean hasEdition();
      /**
       * <code>optional string edition = 1;</code>
       * @return The edition.
       */
      java.lang.String getEdition();
      /**
       * <code>optional string edition = 1;</code>
       * @return The bytes for edition.
       */
      com.google.protobuf.ByteString
          getEditionBytes();

      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return Whether the value field is set.
       */
      boolean hasValue();
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return The value.
       */
      java.lang.String getValue();
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return The bytes for value.
       */
      com.google.protobuf.ByteString
          getValueBytes();
    }
    /**
     * Protobuf type {@code google.protobuf.FieldOptions.EditionDefault}
     */
    public  static final class EditionDefault extends
        com.google.protobuf.GeneratedMessageLite<
            EditionDefault, EditionDefault.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.FieldOptions.EditionDefault)
        EditionDefaultOrBuilder {
      private EditionDefault() {
        edition_ = "";
        value_ = "";
      }
      private int bitField0_;
      public static final int EDITION_FIELD_NUMBER = 1;
      private java.lang.String edition_;
      /**
       * <code>optional string edition = 1;</code>
       * @return Whether the edition field is set.
       */
      @java.lang.Override
      public boolean hasEdition() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string edition = 1;</code>
       * @return The edition.
       */
      @java.lang.Override
      public java.lang.String getEdition() {
        return edition_;
      }
      /**
       * <code>optional string edition = 1;</code>
       * @return The bytes for edition.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getEditionBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(edition_);
      }
      /**
       * <code>optional string edition = 1;</code>
       * @param value The edition to set.
       */
      private void setEdition(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        edition_ = value;
      }
      /**
       * <code>optional string edition = 1;</code>
       */
      private void clearEdition() {
        bitField0_ = (bitField0_ & ~0x00000001);
        edition_ = getDefaultInstance().getEdition();
      }
      /**
       * <code>optional string edition = 1;</code>
       * @param value The bytes for edition to set.
       */
      private void setEditionBytes(
          com.google.protobuf.ByteString value) {
        edition_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int VALUE_FIELD_NUMBER = 2;
      private java.lang.String value_;
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return Whether the value field is set.
       */
      @java.lang.Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return The value.
       */
      @java.lang.Override
      public java.lang.String getValue() {
        return value_;
      }
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @return The bytes for value.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getValueBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(value_);
      }
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @param value The value to set.
       */
      private void setValue(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
        value_ = value;
      }
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       */
      private void clearValue() {
        bitField0_ = (bitField0_ & ~0x00000002);
        value_ = getDefaultInstance().getValue();
      }
      /**
       * <pre>
       * Textproto value.
       * </pre>
       *
       * <code>optional string value = 2;</code>
       * @param value The bytes for value to set.
       */
      private void setValueBytes(
          com.google.protobuf.ByteString value) {
        value_ = value.toStringUtf8();
        bitField0_ |= 0x00000002;
      }

      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code google.protobuf.FieldOptions.EditionDefault}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.FieldOptions.EditionDefault)
          com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefaultOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>optional string edition = 1;</code>
         * @return Whether the edition field is set.
         */
        @java.lang.Override
        public boolean hasEdition() {
          return instance.hasEdition();
        }
        /**
         * <code>optional string edition = 1;</code>
         * @return The edition.
         */
        @java.lang.Override
        public java.lang.String getEdition() {
          return instance.getEdition();
        }
        /**
         * <code>optional string edition = 1;</code>
         * @return The bytes for edition.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getEditionBytes() {
          return instance.getEditionBytes();
        }
        /**
         * <code>optional string edition = 1;</code>
         * @param value The edition to set.
         * @return This builder for chaining.
         */
        public Builder setEdition(
            java.lang.String value) {
          copyOnWrite();
          instance.setEdition(value);
          return this;
        }
        /**
         * <code>optional string edition = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearEdition() {
          copyOnWrite();
          instance.clearEdition();
          return this;
        }
        /**
         * <code>optional string edition = 1;</code>
         * @param value The bytes for edition to set.
         * @return This builder for chaining.
         */
        public Builder setEditionBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setEditionBytes(value);
          return this;
        }

        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @return Whether the value field is set.
         */
        @java.lang.Override
        public boolean hasValue() {
          return instance.hasValue();
        }
        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @return The value.
         */
        @java.lang.Override
        public java.lang.String getValue() {
          return instance.getValue();
        }
        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @return The bytes for value.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getValueBytes() {
          return instance.getValueBytes();
        }
        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @param value The value to set.
         * @return This builder for chaining.
         */
        public Builder setValue(
            java.lang.String value) {
          copyOnWrite();
          instance.setValue(value);
          return this;
        }
        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearValue() {
          copyOnWrite();
          instance.clearValue();
          return this;
        }
        /**
         * <pre>
         * Textproto value.
         * </pre>
         *
         * <code>optional string value = 2;</code>
         * @param value The bytes for value to set.
         * @return This builder for chaining.
         */
        public Builder setValueBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setValueBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.FieldOptions.EditionDefault)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "edition_",
                "value_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                  "\u1008\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.FieldOptions.EditionDefault)
      private static final com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault DEFAULT_INSTANCE;
      static {
        EditionDefault defaultInstance = new EditionDefault();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          EditionDefault.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<EditionDefault> PARSER;

      public static com.google.protobuf.Parser<EditionDefault> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int CTYPE_FIELD_NUMBER = 1;
    private int ctype_;
    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     * @return Whether the ctype field is set.
     */
    @java.lang.Override
    public boolean hasCtype() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     * @return The ctype.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions.CType getCtype() {
      com.google.protobuf.DescriptorProtos.FieldOptions.CType result = com.google.protobuf.DescriptorProtos.FieldOptions.CType.forNumber(ctype_);
      return result == null ? com.google.protobuf.DescriptorProtos.FieldOptions.CType.STRING : result;
    }
    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     * @param value The ctype to set.
     */
    private void setCtype(com.google.protobuf.DescriptorProtos.FieldOptions.CType value) {
      ctype_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The ctype option instructs the C++ code generator to use a different
     * representation of the field than it normally would.  See the specific
     * options below.  This option is only implemented to support use of
     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
     * type "bytes" in the open source release -- sorry, we'll try to include
     * other types in a future version!
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
     */
    private void clearCtype() {
      bitField0_ = (bitField0_ & ~0x00000001);
      ctype_ = 0;
    }

    public static final int PACKED_FIELD_NUMBER = 2;
    private boolean packed_;
    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     * @return Whether the packed field is set.
     */
    @java.lang.Override
    public boolean hasPacked() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     * @return The packed.
     */
    @java.lang.Override
    public boolean getPacked() {
      return packed_;
    }
    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     * @param value The packed to set.
     */
    private void setPacked(boolean value) {
      bitField0_ |= 0x00000002;
      packed_ = value;
    }
    /**
     * <pre>
     * The packed option can be enabled for repeated primitive fields to enable
     * a more efficient representation on the wire. Rather than repeatedly
     * writing the tag and type for each element, the entire array is encoded as
     * a single length-delimited blob. In proto3, only explicit setting it to
     * false will avoid using packed encoding.
     * </pre>
     *
     * <code>optional bool packed = 2;</code>
     */
    private void clearPacked() {
      bitField0_ = (bitField0_ & ~0x00000002);
      packed_ = false;
    }

    public static final int JSTYPE_FIELD_NUMBER = 6;
    private int jstype_;
    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     * @return Whether the jstype field is set.
     */
    @java.lang.Override
    public boolean hasJstype() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     * @return The jstype.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions.JSType getJstype() {
      com.google.protobuf.DescriptorProtos.FieldOptions.JSType result = com.google.protobuf.DescriptorProtos.FieldOptions.JSType.forNumber(jstype_);
      return result == null ? com.google.protobuf.DescriptorProtos.FieldOptions.JSType.JS_NORMAL : result;
    }
    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     * @param value The jstype to set.
     */
    private void setJstype(com.google.protobuf.DescriptorProtos.FieldOptions.JSType value) {
      jstype_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * The jstype option determines the JavaScript type used for values of the
     * field.  The option is permitted only for 64 bit integral and fixed types
     * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
     * is represented as JavaScript string, which avoids loss of precision that
     * can happen when a large value is converted to a floating point JavaScript.
     * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
     * use the JavaScript "number" type.  The behavior of the default option
     * JS_NORMAL is implementation dependent.
     * This option is an enum to permit additional types to be added, e.g.
     * goog.math.Integer.
     * </pre>
     *
     * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
     */
    private void clearJstype() {
      bitField0_ = (bitField0_ & ~0x00000004);
      jstype_ = 0;
    }

    public static final int LAZY_FIELD_NUMBER = 5;
    private boolean lazy_;
    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     * @return Whether the lazy field is set.
     */
    @java.lang.Override
    public boolean hasLazy() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     * @return The lazy.
     */
    @java.lang.Override
    public boolean getLazy() {
      return lazy_;
    }
    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     * @param value The lazy to set.
     */
    private void setLazy(boolean value) {
      bitField0_ |= 0x00000008;
      lazy_ = value;
    }
    /**
     * <pre>
     * Should this field be parsed lazily?  Lazy applies only to message-type
     * fields.  It means that when the outer message is initially parsed, the
     * inner message's contents will not be parsed but instead stored in encoded
     * form.  The inner message will actually be parsed when it is first accessed.
     * This is only a hint.  Implementations are free to choose whether to use
     * eager or lazy parsing regardless of the value of this option.  However,
     * setting this option true suggests that the protocol author believes that
     * using lazy parsing on this field is worth the additional bookkeeping
     * overhead typically needed to implement it.
     * This option does not affect the public interface of any generated code;
     * all method signatures remain the same.  Furthermore, thread-safety of the
     * interface is not affected by this option; const methods remain safe to
     * call from multiple threads concurrently, while non-const methods continue
     * to require exclusive access.
     * Note that implementations may choose not to check required fields within
     * a lazy sub-message.  That is, calling IsInitialized() on the outer message
     * may return true even if the inner message has missing required fields.
     * This is necessary because otherwise the inner message would have to be
     * parsed in order to perform the check, defeating the purpose of lazy
     * parsing.  An implementation which chooses not to check required fields
     * must be consistent about it.  That is, for any particular sub-message, the
     * implementation must either *always* check its required fields, or *never*
     * check its required fields, regardless of whether or not the message has
     * been parsed.
     * As of May 2022, lazy verifies the contents of the byte stream during
     * parsing.  An invalid byte stream will cause the overall parsing to fail.
     * </pre>
     *
     * <code>optional bool lazy = 5 [default = false];</code>
     */
    private void clearLazy() {
      bitField0_ = (bitField0_ & ~0x00000008);
      lazy_ = false;
    }

    public static final int UNVERIFIED_LAZY_FIELD_NUMBER = 15;
    private boolean unverifiedLazy_;
    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     * @return Whether the unverifiedLazy field is set.
     */
    @java.lang.Override
    public boolean hasUnverifiedLazy() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     * @return The unverifiedLazy.
     */
    @java.lang.Override
    public boolean getUnverifiedLazy() {
      return unverifiedLazy_;
    }
    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     * @param value The unverifiedLazy to set.
     */
    private void setUnverifiedLazy(boolean value) {
      bitField0_ |= 0x00000010;
      unverifiedLazy_ = value;
    }
    /**
     * <pre>
     * unverified_lazy does no correctness checks on the byte stream. This should
     * only be used where lazy with verification is prohibitive for performance
     * reasons.
     * </pre>
     *
     * <code>optional bool unverified_lazy = 15 [default = false];</code>
     */
    private void clearUnverifiedLazy() {
      bitField0_ = (bitField0_ & ~0x00000010);
      unverifiedLazy_ = false;
    }

    public static final int DEPRECATED_FIELD_NUMBER = 3;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000020;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this field deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for accessors, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating fields.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000020);
      deprecated_ = false;
    }

    public static final int WEAK_FIELD_NUMBER = 10;
    private boolean weak_;
    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     * @return Whether the weak field is set.
     */
    @java.lang.Override
    public boolean hasWeak() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     * @return The weak.
     */
    @java.lang.Override
    public boolean getWeak() {
      return weak_;
    }
    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     * @param value The weak to set.
     */
    private void setWeak(boolean value) {
      bitField0_ |= 0x00000040;
      weak_ = value;
    }
    /**
     * <pre>
     * For Google-internal migration only. Do not use.
     * </pre>
     *
     * <code>optional bool weak = 10 [default = false];</code>
     */
    private void clearWeak() {
      bitField0_ = (bitField0_ & ~0x00000040);
      weak_ = false;
    }

    public static final int DEBUG_REDACT_FIELD_NUMBER = 16;
    private boolean debugRedact_;
    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     * @return Whether the debugRedact field is set.
     */
    @java.lang.Override
    public boolean hasDebugRedact() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     * @return The debugRedact.
     */
    @java.lang.Override
    public boolean getDebugRedact() {
      return debugRedact_;
    }
    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     * @param value The debugRedact to set.
     */
    private void setDebugRedact(boolean value) {
      bitField0_ |= 0x00000080;
      debugRedact_ = value;
    }
    /**
     * <pre>
     * Indicate that the field value should not be printed out when using debug
     * formats, e.g. when the field contains sensitive credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 16 [default = false];</code>
     */
    private void clearDebugRedact() {
      bitField0_ = (bitField0_ & ~0x00000080);
      debugRedact_ = false;
    }

    public static final int RETENTION_FIELD_NUMBER = 17;
    private int retention_;
    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     * @return Whether the retention field is set.
     */
    @java.lang.Override
    public boolean hasRetention() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     * @return The retention.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention getRetention() {
      com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention result = com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention.forNumber(retention_);
      return result == null ? com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention.RETENTION_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     * @param value The retention to set.
     */
    private void setRetention(com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention value) {
      retention_ = value.getNumber();
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
     */
    private void clearRetention() {
      bitField0_ = (bitField0_ & ~0x00000100);
      retention_ = 0;
    }

    public static final int TARGETS_FIELD_NUMBER = 19;
    private com.google.protobuf.Internal.IntList targets_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> targets_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType>() {
              @java.lang.Override
              public com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType convert(java.lang.Integer from) {
                com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType result = com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType.forNumber(from);
                return result == null ? com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType.TARGET_TYPE_UNKNOWN : result;
              }
            };
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @return A list containing the targets.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> getTargetsList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType>(targets_, targets_converter_);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @return The count of targets.
     */
    @java.lang.Override
    public int getTargetsCount() {
      return targets_.size();
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @param index The index of the element to return.
     * @return The targets at the given index.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType getTargets(int index) {
      com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType result = com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType.forNumber(targets_.getInt(index));
      return result == null ? com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType.TARGET_TYPE_UNKNOWN : result;
    }
    private void ensureTargetsIsMutable() {
      com.google.protobuf.Internal.IntList tmp = targets_;
      if (!tmp.isModifiable()) {
        targets_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
      }
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @param index The index to set the value at.
     * @param value The targets to set.
     */
    private void setTargets(
        int index, com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType value) {
      value.getClass();
  ensureTargetsIsMutable();
      targets_.setInt(index, value.getNumber());
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @param value The targets to add.
     */
    private void addTargets(com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType value) {
      value.getClass();
  ensureTargetsIsMutable();
      targets_.addInt(value.getNumber());
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     * @param values The targets to add.
     */
    private void addAllTargets(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> values) {
      ensureTargetsIsMutable();
      for (com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType value : values) {
        targets_.addInt(value.getNumber());
      }
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
     */
    private void clearTargets() {
      targets_ = emptyIntList();
    }

    public static final int EDITION_DEFAULTS_FIELD_NUMBER = 20;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> editionDefaults_;
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> getEditionDefaultsList() {
      return editionDefaults_;
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefaultOrBuilder> 
        getEditionDefaultsOrBuilderList() {
      return editionDefaults_;
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    @java.lang.Override
    public int getEditionDefaultsCount() {
      return editionDefaults_.size();
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault getEditionDefaults(int index) {
      return editionDefaults_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    public com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefaultOrBuilder getEditionDefaultsOrBuilder(
        int index) {
      return editionDefaults_.get(index);
    }
    private void ensureEditionDefaultsIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> tmp = editionDefaults_;
      if (!tmp.isModifiable()) {
        editionDefaults_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void setEditionDefaults(
        int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
      value.getClass();
  ensureEditionDefaultsIsMutable();
      editionDefaults_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void addEditionDefaults(com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
      value.getClass();
  ensureEditionDefaultsIsMutable();
      editionDefaults_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void addEditionDefaults(
        int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
      value.getClass();
  ensureEditionDefaultsIsMutable();
      editionDefaults_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void addAllEditionDefaults(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> values) {
      ensureEditionDefaultsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, editionDefaults_);
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void clearEditionDefaults() {
      editionDefaults_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
     */
    private void removeEditionDefaults(int index) {
      ensureEditionDefaultsIsMutable();
      editionDefaults_.remove(index);
    }

    public static final int FEATURES_FIELD_NUMBER = 21;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 21;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FieldOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FieldOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.FieldOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.FieldOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FieldOptions)
        com.google.protobuf.DescriptorProtos.FieldOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FieldOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The ctype option instructs the C++ code generator to use a different
       * representation of the field than it normally would.  See the specific
       * options below.  This option is only implemented to support use of
       * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
       * type "bytes" in the open source release -- sorry, we'll try to include
       * other types in a future version!
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
       * @return Whether the ctype field is set.
       */
      @java.lang.Override
      public boolean hasCtype() {
        return instance.hasCtype();
      }
      /**
       * <pre>
       * The ctype option instructs the C++ code generator to use a different
       * representation of the field than it normally would.  See the specific
       * options below.  This option is only implemented to support use of
       * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
       * type "bytes" in the open source release -- sorry, we'll try to include
       * other types in a future version!
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
       * @return The ctype.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions.CType getCtype() {
        return instance.getCtype();
      }
      /**
       * <pre>
       * The ctype option instructs the C++ code generator to use a different
       * representation of the field than it normally would.  See the specific
       * options below.  This option is only implemented to support use of
       * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
       * type "bytes" in the open source release -- sorry, we'll try to include
       * other types in a future version!
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
       * @param value The enum numeric value on the wire for ctype to set.
       * @return This builder for chaining.
       */
      public Builder setCtype(com.google.protobuf.DescriptorProtos.FieldOptions.CType value) {
        copyOnWrite();
        instance.setCtype(value);
        return this;
      }
      /**
       * <pre>
       * The ctype option instructs the C++ code generator to use a different
       * representation of the field than it normally would.  See the specific
       * options below.  This option is only implemented to support use of
       * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
       * type "bytes" in the open source release -- sorry, we'll try to include
       * other types in a future version!
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
       * @return This builder for chaining.
       */
      public Builder clearCtype() {
        copyOnWrite();
        instance.clearCtype();
        return this;
      }

      /**
       * <pre>
       * The packed option can be enabled for repeated primitive fields to enable
       * a more efficient representation on the wire. Rather than repeatedly
       * writing the tag and type for each element, the entire array is encoded as
       * a single length-delimited blob. In proto3, only explicit setting it to
       * false will avoid using packed encoding.
       * </pre>
       *
       * <code>optional bool packed = 2;</code>
       * @return Whether the packed field is set.
       */
      @java.lang.Override
      public boolean hasPacked() {
        return instance.hasPacked();
      }
      /**
       * <pre>
       * The packed option can be enabled for repeated primitive fields to enable
       * a more efficient representation on the wire. Rather than repeatedly
       * writing the tag and type for each element, the entire array is encoded as
       * a single length-delimited blob. In proto3, only explicit setting it to
       * false will avoid using packed encoding.
       * </pre>
       *
       * <code>optional bool packed = 2;</code>
       * @return The packed.
       */
      @java.lang.Override
      public boolean getPacked() {
        return instance.getPacked();
      }
      /**
       * <pre>
       * The packed option can be enabled for repeated primitive fields to enable
       * a more efficient representation on the wire. Rather than repeatedly
       * writing the tag and type for each element, the entire array is encoded as
       * a single length-delimited blob. In proto3, only explicit setting it to
       * false will avoid using packed encoding.
       * </pre>
       *
       * <code>optional bool packed = 2;</code>
       * @param value The packed to set.
       * @return This builder for chaining.
       */
      public Builder setPacked(boolean value) {
        copyOnWrite();
        instance.setPacked(value);
        return this;
      }
      /**
       * <pre>
       * The packed option can be enabled for repeated primitive fields to enable
       * a more efficient representation on the wire. Rather than repeatedly
       * writing the tag and type for each element, the entire array is encoded as
       * a single length-delimited blob. In proto3, only explicit setting it to
       * false will avoid using packed encoding.
       * </pre>
       *
       * <code>optional bool packed = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPacked() {
        copyOnWrite();
        instance.clearPacked();
        return this;
      }

      /**
       * <pre>
       * The jstype option determines the JavaScript type used for values of the
       * field.  The option is permitted only for 64 bit integral and fixed types
       * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
       * is represented as JavaScript string, which avoids loss of precision that
       * can happen when a large value is converted to a floating point JavaScript.
       * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
       * use the JavaScript "number" type.  The behavior of the default option
       * JS_NORMAL is implementation dependent.
       * This option is an enum to permit additional types to be added, e.g.
       * goog.math.Integer.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
       * @return Whether the jstype field is set.
       */
      @java.lang.Override
      public boolean hasJstype() {
        return instance.hasJstype();
      }
      /**
       * <pre>
       * The jstype option determines the JavaScript type used for values of the
       * field.  The option is permitted only for 64 bit integral and fixed types
       * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
       * is represented as JavaScript string, which avoids loss of precision that
       * can happen when a large value is converted to a floating point JavaScript.
       * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
       * use the JavaScript "number" type.  The behavior of the default option
       * JS_NORMAL is implementation dependent.
       * This option is an enum to permit additional types to be added, e.g.
       * goog.math.Integer.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
       * @return The jstype.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions.JSType getJstype() {
        return instance.getJstype();
      }
      /**
       * <pre>
       * The jstype option determines the JavaScript type used for values of the
       * field.  The option is permitted only for 64 bit integral and fixed types
       * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
       * is represented as JavaScript string, which avoids loss of precision that
       * can happen when a large value is converted to a floating point JavaScript.
       * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
       * use the JavaScript "number" type.  The behavior of the default option
       * JS_NORMAL is implementation dependent.
       * This option is an enum to permit additional types to be added, e.g.
       * goog.math.Integer.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
       * @param value The enum numeric value on the wire for jstype to set.
       * @return This builder for chaining.
       */
      public Builder setJstype(com.google.protobuf.DescriptorProtos.FieldOptions.JSType value) {
        copyOnWrite();
        instance.setJstype(value);
        return this;
      }
      /**
       * <pre>
       * The jstype option determines the JavaScript type used for values of the
       * field.  The option is permitted only for 64 bit integral and fixed types
       * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
       * is represented as JavaScript string, which avoids loss of precision that
       * can happen when a large value is converted to a floating point JavaScript.
       * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
       * use the JavaScript "number" type.  The behavior of the default option
       * JS_NORMAL is implementation dependent.
       * This option is an enum to permit additional types to be added, e.g.
       * goog.math.Integer.
       * </pre>
       *
       * <code>optional .google.protobuf.FieldOptions.JSType jstype = 6 [default = JS_NORMAL];</code>
       * @return This builder for chaining.
       */
      public Builder clearJstype() {
        copyOnWrite();
        instance.clearJstype();
        return this;
      }

      /**
       * <pre>
       * Should this field be parsed lazily?  Lazy applies only to message-type
       * fields.  It means that when the outer message is initially parsed, the
       * inner message's contents will not be parsed but instead stored in encoded
       * form.  The inner message will actually be parsed when it is first accessed.
       * This is only a hint.  Implementations are free to choose whether to use
       * eager or lazy parsing regardless of the value of this option.  However,
       * setting this option true suggests that the protocol author believes that
       * using lazy parsing on this field is worth the additional bookkeeping
       * overhead typically needed to implement it.
       * This option does not affect the public interface of any generated code;
       * all method signatures remain the same.  Furthermore, thread-safety of the
       * interface is not affected by this option; const methods remain safe to
       * call from multiple threads concurrently, while non-const methods continue
       * to require exclusive access.
       * Note that implementations may choose not to check required fields within
       * a lazy sub-message.  That is, calling IsInitialized() on the outer message
       * may return true even if the inner message has missing required fields.
       * This is necessary because otherwise the inner message would have to be
       * parsed in order to perform the check, defeating the purpose of lazy
       * parsing.  An implementation which chooses not to check required fields
       * must be consistent about it.  That is, for any particular sub-message, the
       * implementation must either *always* check its required fields, or *never*
       * check its required fields, regardless of whether or not the message has
       * been parsed.
       * As of May 2022, lazy verifies the contents of the byte stream during
       * parsing.  An invalid byte stream will cause the overall parsing to fail.
       * </pre>
       *
       * <code>optional bool lazy = 5 [default = false];</code>
       * @return Whether the lazy field is set.
       */
      @java.lang.Override
      public boolean hasLazy() {
        return instance.hasLazy();
      }
      /**
       * <pre>
       * Should this field be parsed lazily?  Lazy applies only to message-type
       * fields.  It means that when the outer message is initially parsed, the
       * inner message's contents will not be parsed but instead stored in encoded
       * form.  The inner message will actually be parsed when it is first accessed.
       * This is only a hint.  Implementations are free to choose whether to use
       * eager or lazy parsing regardless of the value of this option.  However,
       * setting this option true suggests that the protocol author believes that
       * using lazy parsing on this field is worth the additional bookkeeping
       * overhead typically needed to implement it.
       * This option does not affect the public interface of any generated code;
       * all method signatures remain the same.  Furthermore, thread-safety of the
       * interface is not affected by this option; const methods remain safe to
       * call from multiple threads concurrently, while non-const methods continue
       * to require exclusive access.
       * Note that implementations may choose not to check required fields within
       * a lazy sub-message.  That is, calling IsInitialized() on the outer message
       * may return true even if the inner message has missing required fields.
       * This is necessary because otherwise the inner message would have to be
       * parsed in order to perform the check, defeating the purpose of lazy
       * parsing.  An implementation which chooses not to check required fields
       * must be consistent about it.  That is, for any particular sub-message, the
       * implementation must either *always* check its required fields, or *never*
       * check its required fields, regardless of whether or not the message has
       * been parsed.
       * As of May 2022, lazy verifies the contents of the byte stream during
       * parsing.  An invalid byte stream will cause the overall parsing to fail.
       * </pre>
       *
       * <code>optional bool lazy = 5 [default = false];</code>
       * @return The lazy.
       */
      @java.lang.Override
      public boolean getLazy() {
        return instance.getLazy();
      }
      /**
       * <pre>
       * Should this field be parsed lazily?  Lazy applies only to message-type
       * fields.  It means that when the outer message is initially parsed, the
       * inner message's contents will not be parsed but instead stored in encoded
       * form.  The inner message will actually be parsed when it is first accessed.
       * This is only a hint.  Implementations are free to choose whether to use
       * eager or lazy parsing regardless of the value of this option.  However,
       * setting this option true suggests that the protocol author believes that
       * using lazy parsing on this field is worth the additional bookkeeping
       * overhead typically needed to implement it.
       * This option does not affect the public interface of any generated code;
       * all method signatures remain the same.  Furthermore, thread-safety of the
       * interface is not affected by this option; const methods remain safe to
       * call from multiple threads concurrently, while non-const methods continue
       * to require exclusive access.
       * Note that implementations may choose not to check required fields within
       * a lazy sub-message.  That is, calling IsInitialized() on the outer message
       * may return true even if the inner message has missing required fields.
       * This is necessary because otherwise the inner message would have to be
       * parsed in order to perform the check, defeating the purpose of lazy
       * parsing.  An implementation which chooses not to check required fields
       * must be consistent about it.  That is, for any particular sub-message, the
       * implementation must either *always* check its required fields, or *never*
       * check its required fields, regardless of whether or not the message has
       * been parsed.
       * As of May 2022, lazy verifies the contents of the byte stream during
       * parsing.  An invalid byte stream will cause the overall parsing to fail.
       * </pre>
       *
       * <code>optional bool lazy = 5 [default = false];</code>
       * @param value The lazy to set.
       * @return This builder for chaining.
       */
      public Builder setLazy(boolean value) {
        copyOnWrite();
        instance.setLazy(value);
        return this;
      }
      /**
       * <pre>
       * Should this field be parsed lazily?  Lazy applies only to message-type
       * fields.  It means that when the outer message is initially parsed, the
       * inner message's contents will not be parsed but instead stored in encoded
       * form.  The inner message will actually be parsed when it is first accessed.
       * This is only a hint.  Implementations are free to choose whether to use
       * eager or lazy parsing regardless of the value of this option.  However,
       * setting this option true suggests that the protocol author believes that
       * using lazy parsing on this field is worth the additional bookkeeping
       * overhead typically needed to implement it.
       * This option does not affect the public interface of any generated code;
       * all method signatures remain the same.  Furthermore, thread-safety of the
       * interface is not affected by this option; const methods remain safe to
       * call from multiple threads concurrently, while non-const methods continue
       * to require exclusive access.
       * Note that implementations may choose not to check required fields within
       * a lazy sub-message.  That is, calling IsInitialized() on the outer message
       * may return true even if the inner message has missing required fields.
       * This is necessary because otherwise the inner message would have to be
       * parsed in order to perform the check, defeating the purpose of lazy
       * parsing.  An implementation which chooses not to check required fields
       * must be consistent about it.  That is, for any particular sub-message, the
       * implementation must either *always* check its required fields, or *never*
       * check its required fields, regardless of whether or not the message has
       * been parsed.
       * As of May 2022, lazy verifies the contents of the byte stream during
       * parsing.  An invalid byte stream will cause the overall parsing to fail.
       * </pre>
       *
       * <code>optional bool lazy = 5 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLazy() {
        copyOnWrite();
        instance.clearLazy();
        return this;
      }

      /**
       * <pre>
       * unverified_lazy does no correctness checks on the byte stream. This should
       * only be used where lazy with verification is prohibitive for performance
       * reasons.
       * </pre>
       *
       * <code>optional bool unverified_lazy = 15 [default = false];</code>
       * @return Whether the unverifiedLazy field is set.
       */
      @java.lang.Override
      public boolean hasUnverifiedLazy() {
        return instance.hasUnverifiedLazy();
      }
      /**
       * <pre>
       * unverified_lazy does no correctness checks on the byte stream. This should
       * only be used where lazy with verification is prohibitive for performance
       * reasons.
       * </pre>
       *
       * <code>optional bool unverified_lazy = 15 [default = false];</code>
       * @return The unverifiedLazy.
       */
      @java.lang.Override
      public boolean getUnverifiedLazy() {
        return instance.getUnverifiedLazy();
      }
      /**
       * <pre>
       * unverified_lazy does no correctness checks on the byte stream. This should
       * only be used where lazy with verification is prohibitive for performance
       * reasons.
       * </pre>
       *
       * <code>optional bool unverified_lazy = 15 [default = false];</code>
       * @param value The unverifiedLazy to set.
       * @return This builder for chaining.
       */
      public Builder setUnverifiedLazy(boolean value) {
        copyOnWrite();
        instance.setUnverifiedLazy(value);
        return this;
      }
      /**
       * <pre>
       * unverified_lazy does no correctness checks on the byte stream. This should
       * only be used where lazy with verification is prohibitive for performance
       * reasons.
       * </pre>
       *
       * <code>optional bool unverified_lazy = 15 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUnverifiedLazy() {
        copyOnWrite();
        instance.clearUnverifiedLazy();
        return this;
      }

      /**
       * <pre>
       * Is this field deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for accessors, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating fields.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this field deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for accessors, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating fields.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this field deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for accessors, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating fields.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this field deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for accessors, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating fields.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>optional bool weak = 10 [default = false];</code>
       * @return Whether the weak field is set.
       */
      @java.lang.Override
      public boolean hasWeak() {
        return instance.hasWeak();
      }
      /**
       * <pre>
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>optional bool weak = 10 [default = false];</code>
       * @return The weak.
       */
      @java.lang.Override
      public boolean getWeak() {
        return instance.getWeak();
      }
      /**
       * <pre>
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>optional bool weak = 10 [default = false];</code>
       * @param value The weak to set.
       * @return This builder for chaining.
       */
      public Builder setWeak(boolean value) {
        copyOnWrite();
        instance.setWeak(value);
        return this;
      }
      /**
       * <pre>
       * For Google-internal migration only. Do not use.
       * </pre>
       *
       * <code>optional bool weak = 10 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearWeak() {
        copyOnWrite();
        instance.clearWeak();
        return this;
      }

      /**
       * <pre>
       * Indicate that the field value should not be printed out when using debug
       * formats, e.g. when the field contains sensitive credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 16 [default = false];</code>
       * @return Whether the debugRedact field is set.
       */
      @java.lang.Override
      public boolean hasDebugRedact() {
        return instance.hasDebugRedact();
      }
      /**
       * <pre>
       * Indicate that the field value should not be printed out when using debug
       * formats, e.g. when the field contains sensitive credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 16 [default = false];</code>
       * @return The debugRedact.
       */
      @java.lang.Override
      public boolean getDebugRedact() {
        return instance.getDebugRedact();
      }
      /**
       * <pre>
       * Indicate that the field value should not be printed out when using debug
       * formats, e.g. when the field contains sensitive credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 16 [default = false];</code>
       * @param value The debugRedact to set.
       * @return This builder for chaining.
       */
      public Builder setDebugRedact(boolean value) {
        copyOnWrite();
        instance.setDebugRedact(value);
        return this;
      }
      /**
       * <pre>
       * Indicate that the field value should not be printed out when using debug
       * formats, e.g. when the field contains sensitive credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 16 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDebugRedact() {
        copyOnWrite();
        instance.clearDebugRedact();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
       * @return Whether the retention field is set.
       */
      @java.lang.Override
      public boolean hasRetention() {
        return instance.hasRetention();
      }
      /**
       * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
       * @return The retention.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention getRetention() {
        return instance.getRetention();
      }
      /**
       * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
       * @param value The enum numeric value on the wire for retention to set.
       * @return This builder for chaining.
       */
      public Builder setRetention(com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention value) {
        copyOnWrite();
        instance.setRetention(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearRetention() {
        copyOnWrite();
        instance.clearRetention();
        return this;
      }

      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @return A list containing the targets.
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> getTargetsList() {
        return instance.getTargetsList();
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @return The count of targets.
       */
      @java.lang.Override
      public int getTargetsCount() {
        return instance.getTargetsCount();
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @param index The index of the element to return.
       * @return The targets at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType getTargets(int index) {
        return instance.getTargets(index);
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @param index The index to set the value at.
       * @param value The targets to set.
       * @return This builder for chaining.
       */
      public Builder setTargets(
          int index, com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType value) {
        copyOnWrite();
        instance.setTargets(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @param value The targets to add.
       * @return This builder for chaining.
       */
      public Builder addTargets(com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType value) {
        copyOnWrite();
        instance.addTargets(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @param values The targets to add.
       * @return This builder for chaining.
       */
      public Builder addAllTargets(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType> values) {
        copyOnWrite();
        instance.addAllTargets(values);  return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargets() {
        copyOnWrite();
        instance.clearTargets();
        return this;
      }

      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> getEditionDefaultsList() {
        return java.util.Collections.unmodifiableList(
            instance.getEditionDefaultsList());
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      @java.lang.Override
      public int getEditionDefaultsCount() {
        return instance.getEditionDefaultsCount();
      }/**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault getEditionDefaults(int index) {
        return instance.getEditionDefaults(index);
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder setEditionDefaults(
          int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
        copyOnWrite();
        instance.setEditionDefaults(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder setEditionDefaults(
          int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.Builder builderForValue) {
        copyOnWrite();
        instance.setEditionDefaults(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder addEditionDefaults(com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
        copyOnWrite();
        instance.addEditionDefaults(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder addEditionDefaults(
          int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault value) {
        copyOnWrite();
        instance.addEditionDefaults(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder addEditionDefaults(
          com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.Builder builderForValue) {
        copyOnWrite();
        instance.addEditionDefaults(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder addEditionDefaults(
          int index, com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.Builder builderForValue) {
        copyOnWrite();
        instance.addEditionDefaults(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder addAllEditionDefaults(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault> values) {
        copyOnWrite();
        instance.addAllEditionDefaults(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder clearEditionDefaults() {
        copyOnWrite();
        instance.clearEditionDefaults();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
       */
      public Builder removeEditionDefaults(int index) {
        copyOnWrite();
        instance.removeEditionDefaults(index);
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 21;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FieldOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FieldOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "ctype_",
              com.google.protobuf.DescriptorProtos.FieldOptions.CType.internalGetVerifier(),
              "packed_",
              "deprecated_",
              "lazy_",
              "jstype_",
              com.google.protobuf.DescriptorProtos.FieldOptions.JSType.internalGetVerifier(),
              "weak_",
              "unverifiedLazy_",
              "debugRedact_",
              "retention_",
              com.google.protobuf.DescriptorProtos.FieldOptions.OptionRetention.internalGetVerifier(),
              "targets_",
              com.google.protobuf.DescriptorProtos.FieldOptions.OptionTargetType.internalGetVerifier(),
              "editionDefaults_",
              com.google.protobuf.DescriptorProtos.FieldOptions.EditionDefault.class,
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\r\u0000\u0001\u0001\u03e7\r\u0000\u0003\u0002\u0001\u100c\u0000\u0002\u1007" +
                "\u0001\u0003\u1007\u0005\u0005\u1007\u0003\u0006\u100c\u0002\n\u1007\u0006\u000f" +
                "\u1007\u0004\u0010\u1007\u0007\u0011\u100c\b\u0013\u001e\u0014\u001b\u0015\u1409" +
                "\t\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FieldOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FieldOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FieldOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FieldOptions)
    private static final com.google.protobuf.DescriptorProtos.FieldOptions DEFAULT_INSTANCE;
    static {
      FieldOptions defaultInstance = new FieldOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FieldOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FieldOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FieldOptions> PARSER;

    public static com.google.protobuf.Parser<FieldOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OneofOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.OneofOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                OneofOptions, OneofOptions.Builder> {

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.OneofOptions}
   */
  public  static final class OneofOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        OneofOptions, OneofOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.OneofOptions)
      OneofOptionsOrBuilder {
    private OneofOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int FEATURES_FIELD_NUMBER = 1;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 1;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.OneofOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.OneofOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.OneofOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.OneofOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.OneofOptions)
        com.google.protobuf.DescriptorProtos.OneofOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.OneofOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 1;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.OneofOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.OneofOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u03e7\u0002\u0000\u0001\u0002\u0001\u1409\u0000\u03e7" +
                "\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.OneofOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.OneofOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.OneofOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.OneofOptions)
    private static final com.google.protobuf.DescriptorProtos.OneofOptions DEFAULT_INSTANCE;
    static {
      OneofOptions defaultInstance = new OneofOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OneofOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.OneofOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OneofOptions> PARSER;

    public static com.google.protobuf.Parser<OneofOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EnumOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.EnumOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                EnumOptions, EnumOptions.Builder> {

    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     * @return Whether the allowAlias field is set.
     */
    boolean hasAllowAlias();
    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     * @return The allowAlias.
     */
    boolean getAllowAlias();

    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
     */
    @java.lang.Deprecated boolean hasDeprecatedLegacyJsonFieldConflicts();
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     * @return The deprecatedLegacyJsonFieldConflicts.
     */
    @java.lang.Deprecated boolean getDeprecatedLegacyJsonFieldConflicts();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.EnumOptions}
   */
  public  static final class EnumOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        EnumOptions, EnumOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.EnumOptions)
      EnumOptionsOrBuilder {
    private EnumOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int ALLOW_ALIAS_FIELD_NUMBER = 2;
    private boolean allowAlias_;
    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     * @return Whether the allowAlias field is set.
     */
    @java.lang.Override
    public boolean hasAllowAlias() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     * @return The allowAlias.
     */
    @java.lang.Override
    public boolean getAllowAlias() {
      return allowAlias_;
    }
    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     * @param value The allowAlias to set.
     */
    private void setAllowAlias(boolean value) {
      bitField0_ |= 0x00000001;
      allowAlias_ = value;
    }
    /**
     * <pre>
     * Set this option to true to allow mapping different tag names to the same
     * value.
     * </pre>
     *
     * <code>optional bool allow_alias = 2;</code>
     */
    private void clearAllowAlias() {
      bitField0_ = (bitField0_ & ~0x00000001);
      allowAlias_ = false;
    }

    public static final int DEPRECATED_FIELD_NUMBER = 3;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000002;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this enum deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum, or it will be completely ignored; in the very least, this
     * is a formalization for deprecating enums.
     * </pre>
     *
     * <code>optional bool deprecated = 3 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000002);
      deprecated_ = false;
    }

    public static final int DEPRECATED_LEGACY_JSON_FIELD_CONFLICTS_FIELD_NUMBER = 6;
    private boolean deprecatedLegacyJsonFieldConflicts_;
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasDeprecatedLegacyJsonFieldConflicts() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     * @return The deprecatedLegacyJsonFieldConflicts.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getDeprecatedLegacyJsonFieldConflicts() {
      return deprecatedLegacyJsonFieldConflicts_;
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     * @param value The deprecatedLegacyJsonFieldConflicts to set.
     */
    private void setDeprecatedLegacyJsonFieldConflicts(boolean value) {
      bitField0_ |= 0x00000004;
      deprecatedLegacyJsonFieldConflicts_ = value;
    }
    /**
     * <pre>
     * Enable the legacy handling of JSON field name conflicts.  This lowercases
     * and strips underscored from the fields before comparison in proto3 only.
     * The new behavior takes `json_name` into account and applies to proto2 as
     * well.
     * TODO(b/261750190) Remove this legacy behavior once downstream teams have
     * had time to migrate.
     * </pre>
     *
     * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
     * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
     *     See google/protobuf/descriptor.proto;l=772
     */
    private void clearDeprecatedLegacyJsonFieldConflicts() {
      bitField0_ = (bitField0_ & ~0x00000004);
      deprecatedLegacyJsonFieldConflicts_ = false;
    }

    public static final int FEATURES_FIELD_NUMBER = 7;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 7;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.EnumOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.EnumOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.EnumOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.EnumOptions)
        com.google.protobuf.DescriptorProtos.EnumOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.EnumOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Set this option to true to allow mapping different tag names to the same
       * value.
       * </pre>
       *
       * <code>optional bool allow_alias = 2;</code>
       * @return Whether the allowAlias field is set.
       */
      @java.lang.Override
      public boolean hasAllowAlias() {
        return instance.hasAllowAlias();
      }
      /**
       * <pre>
       * Set this option to true to allow mapping different tag names to the same
       * value.
       * </pre>
       *
       * <code>optional bool allow_alias = 2;</code>
       * @return The allowAlias.
       */
      @java.lang.Override
      public boolean getAllowAlias() {
        return instance.getAllowAlias();
      }
      /**
       * <pre>
       * Set this option to true to allow mapping different tag names to the same
       * value.
       * </pre>
       *
       * <code>optional bool allow_alias = 2;</code>
       * @param value The allowAlias to set.
       * @return This builder for chaining.
       */
      public Builder setAllowAlias(boolean value) {
        copyOnWrite();
        instance.setAllowAlias(value);
        return this;
      }
      /**
       * <pre>
       * Set this option to true to allow mapping different tag names to the same
       * value.
       * </pre>
       *
       * <code>optional bool allow_alias = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllowAlias() {
        copyOnWrite();
        instance.clearAllowAlias();
        return this;
      }

      /**
       * <pre>
       * Is this enum deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating enums.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this enum deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating enums.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this enum deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating enums.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this enum deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum, or it will be completely ignored; in the very least, this
       * is a formalization for deprecating enums.
       * </pre>
       *
       * <code>optional bool deprecated = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * TODO(b/261750190) Remove this legacy behavior once downstream teams have
       * had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
       * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=772
       * @return Whether the deprecatedLegacyJsonFieldConflicts field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasDeprecatedLegacyJsonFieldConflicts() {
        return instance.hasDeprecatedLegacyJsonFieldConflicts();
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * TODO(b/261750190) Remove this legacy behavior once downstream teams have
       * had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
       * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=772
       * @return The deprecatedLegacyJsonFieldConflicts.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getDeprecatedLegacyJsonFieldConflicts() {
        return instance.getDeprecatedLegacyJsonFieldConflicts();
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * TODO(b/261750190) Remove this legacy behavior once downstream teams have
       * had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
       * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=772
       * @param value The deprecatedLegacyJsonFieldConflicts to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setDeprecatedLegacyJsonFieldConflicts(boolean value) {
        copyOnWrite();
        instance.setDeprecatedLegacyJsonFieldConflicts(value);
        return this;
      }
      /**
       * <pre>
       * Enable the legacy handling of JSON field name conflicts.  This lowercases
       * and strips underscored from the fields before comparison in proto3 only.
       * The new behavior takes `json_name` into account and applies to proto2 as
       * well.
       * TODO(b/261750190) Remove this legacy behavior once downstream teams have
       * had time to migrate.
       * </pre>
       *
       * <code>optional bool deprecated_legacy_json_field_conflicts = 6 [deprecated = true];</code>
       * @deprecated google.protobuf.EnumOptions.deprecated_legacy_json_field_conflicts is deprecated.
       *     See google/protobuf/descriptor.proto;l=772
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearDeprecatedLegacyJsonFieldConflicts() {
        copyOnWrite();
        instance.clearDeprecatedLegacyJsonFieldConflicts();
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 7;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.EnumOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.EnumOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "allowAlias_",
              "deprecated_",
              "deprecatedLegacyJsonFieldConflicts_",
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0005\u0000\u0001\u0002\u03e7\u0005\u0000\u0001\u0002\u0002\u1007\u0000\u0003" +
                "\u1007\u0001\u0006\u1007\u0002\u0007\u1409\u0003\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.EnumOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.EnumOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.EnumOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.EnumOptions)
    private static final com.google.protobuf.DescriptorProtos.EnumOptions DEFAULT_INSTANCE;
    static {
      EnumOptions defaultInstance = new EnumOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EnumOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.EnumOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EnumOptions> PARSER;

    public static com.google.protobuf.Parser<EnumOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EnumValueOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.EnumValueOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                EnumValueOptions, EnumValueOptions.Builder> {

    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     * @return Whether the debugRedact field is set.
     */
    boolean hasDebugRedact();
    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     * @return The debugRedact.
     */
    boolean getDebugRedact();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.EnumValueOptions}
   */
  public  static final class EnumValueOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        EnumValueOptions, EnumValueOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.EnumValueOptions)
      EnumValueOptionsOrBuilder {
    private EnumValueOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int DEPRECATED_FIELD_NUMBER = 1;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000001;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this enum value deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the enum value, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating enum values.
     * </pre>
     *
     * <code>optional bool deprecated = 1 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000001);
      deprecated_ = false;
    }

    public static final int FEATURES_FIELD_NUMBER = 2;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 2;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int DEBUG_REDACT_FIELD_NUMBER = 3;
    private boolean debugRedact_;
    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     * @return Whether the debugRedact field is set.
     */
    @java.lang.Override
    public boolean hasDebugRedact() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     * @return The debugRedact.
     */
    @java.lang.Override
    public boolean getDebugRedact() {
      return debugRedact_;
    }
    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     * @param value The debugRedact to set.
     */
    private void setDebugRedact(boolean value) {
      bitField0_ |= 0x00000004;
      debugRedact_ = value;
    }
    /**
     * <pre>
     * Indicate that fields annotated with this enum value should not be printed
     * out when using debug formats, e.g. when the field contains sensitive
     * credentials.
     * </pre>
     *
     * <code>optional bool debug_redact = 3 [default = false];</code>
     */
    private void clearDebugRedact() {
      bitField0_ = (bitField0_ & ~0x00000004);
      debugRedact_ = false;
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.EnumValueOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.EnumValueOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.EnumValueOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.EnumValueOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.EnumValueOptions)
        com.google.protobuf.DescriptorProtos.EnumValueOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.EnumValueOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Is this enum value deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum value, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating enum values.
       * </pre>
       *
       * <code>optional bool deprecated = 1 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this enum value deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum value, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating enum values.
       * </pre>
       *
       * <code>optional bool deprecated = 1 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this enum value deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum value, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating enum values.
       * </pre>
       *
       * <code>optional bool deprecated = 1 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this enum value deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the enum value, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating enum values.
       * </pre>
       *
       * <code>optional bool deprecated = 1 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 2;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * Indicate that fields annotated with this enum value should not be printed
       * out when using debug formats, e.g. when the field contains sensitive
       * credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 3 [default = false];</code>
       * @return Whether the debugRedact field is set.
       */
      @java.lang.Override
      public boolean hasDebugRedact() {
        return instance.hasDebugRedact();
      }
      /**
       * <pre>
       * Indicate that fields annotated with this enum value should not be printed
       * out when using debug formats, e.g. when the field contains sensitive
       * credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 3 [default = false];</code>
       * @return The debugRedact.
       */
      @java.lang.Override
      public boolean getDebugRedact() {
        return instance.getDebugRedact();
      }
      /**
       * <pre>
       * Indicate that fields annotated with this enum value should not be printed
       * out when using debug formats, e.g. when the field contains sensitive
       * credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 3 [default = false];</code>
       * @param value The debugRedact to set.
       * @return This builder for chaining.
       */
      public Builder setDebugRedact(boolean value) {
        copyOnWrite();
        instance.setDebugRedact(value);
        return this;
      }
      /**
       * <pre>
       * Indicate that fields annotated with this enum value should not be printed
       * out when using debug formats, e.g. when the field contains sensitive
       * credentials.
       * </pre>
       *
       * <code>optional bool debug_redact = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDebugRedact() {
        copyOnWrite();
        instance.clearDebugRedact();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.EnumValueOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.EnumValueOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "deprecated_",
              "features_",
              "debugRedact_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u03e7\u0004\u0000\u0001\u0002\u0001\u1007\u0000\u0002" +
                "\u1409\u0001\u0003\u1007\u0002\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.EnumValueOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.EnumValueOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.EnumValueOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.EnumValueOptions)
    private static final com.google.protobuf.DescriptorProtos.EnumValueOptions DEFAULT_INSTANCE;
    static {
      EnumValueOptions defaultInstance = new EnumValueOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EnumValueOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.EnumValueOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EnumValueOptions> PARSER;

    public static com.google.protobuf.Parser<EnumValueOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ServiceOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.ServiceOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                ServiceOptions, ServiceOptions.Builder> {

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.ServiceOptions}
   */
  public  static final class ServiceOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        ServiceOptions, ServiceOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.ServiceOptions)
      ServiceOptionsOrBuilder {
    private ServiceOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int FEATURES_FIELD_NUMBER = 34;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000001;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 34;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int DEPRECATED_FIELD_NUMBER = 33;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000002;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this service deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the service, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating services.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000002);
      deprecated_ = false;
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.ServiceOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.ServiceOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.ServiceOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.ServiceOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.ServiceOptions)
        com.google.protobuf.DescriptorProtos.ServiceOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.ServiceOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 34;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * Is this service deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the service, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating services.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this service deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the service, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating services.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this service deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the service, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating services.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this service deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the service, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating services.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.ServiceOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.ServiceOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "deprecated_",
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001!\u03e7\u0003\u0000\u0001\u0002!\u1007\u0001\"\u1409\u0000" +
                "\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.ServiceOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.ServiceOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.ServiceOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.ServiceOptions)
    private static final com.google.protobuf.DescriptorProtos.ServiceOptions DEFAULT_INSTANCE;
    static {
      ServiceOptions defaultInstance = new ServiceOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ServiceOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.ServiceOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ServiceOptions> PARSER;

    public static com.google.protobuf.Parser<ServiceOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface MethodOptionsOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.MethodOptions)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                MethodOptions, MethodOptions.Builder> {

    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    boolean hasDeprecated();
    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return The deprecated.
     */
    boolean getDeprecated();

    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     * @return Whether the idempotencyLevel field is set.
     */
    boolean hasIdempotencyLevel();
    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     * @return The idempotencyLevel.
     */
    com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel getIdempotencyLevel();

    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     * @return Whether the features field is set.
     */
    boolean hasFeatures();
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     * @return The features.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getFeatures();

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> 
        getUninterpretedOptionList();
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index);
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    int getUninterpretedOptionCount();
  }
  /**
   * Protobuf type {@code google.protobuf.MethodOptions}
   */
  public  static final class MethodOptions extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        MethodOptions, MethodOptions.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.MethodOptions)
      MethodOptionsOrBuilder {
    private MethodOptions() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
     * or neither? HTTP based RPC implementation may choose GET verb for safe
     * methods, and PUT verb for idempotent methods instead of the default POST.
     * </pre>
     *
     * Protobuf enum {@code google.protobuf.MethodOptions.IdempotencyLevel}
     */
    public enum IdempotencyLevel
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>IDEMPOTENCY_UNKNOWN = 0;</code>
       */
      IDEMPOTENCY_UNKNOWN(0),
      /**
       * <pre>
       * implies idempotent
       * </pre>
       *
       * <code>NO_SIDE_EFFECTS = 1;</code>
       */
      NO_SIDE_EFFECTS(1),
      /**
       * <pre>
       * idempotent, but may have side effects
       * </pre>
       *
       * <code>IDEMPOTENT = 2;</code>
       */
      IDEMPOTENT(2),
      ;

      /**
       * <code>IDEMPOTENCY_UNKNOWN = 0;</code>
       */
      public static final int IDEMPOTENCY_UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * implies idempotent
       * </pre>
       *
       * <code>NO_SIDE_EFFECTS = 1;</code>
       */
      public static final int NO_SIDE_EFFECTS_VALUE = 1;
      /**
       * <pre>
       * idempotent, but may have side effects
       * </pre>
       *
       * <code>IDEMPOTENT = 2;</code>
       */
      public static final int IDEMPOTENT_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static IdempotencyLevel valueOf(int value) {
        return forNumber(value);
      }

      public static IdempotencyLevel forNumber(int value) {
        switch (value) {
          case 0: return IDEMPOTENCY_UNKNOWN;
          case 1: return NO_SIDE_EFFECTS;
          case 2: return IDEMPOTENT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<IdempotencyLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          IdempotencyLevel> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<IdempotencyLevel>() {
              @java.lang.Override
              public IdempotencyLevel findValueByNumber(int number) {
                return IdempotencyLevel.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return IdempotencyLevelVerifier.INSTANCE;
      }

      private static final class IdempotencyLevelVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new IdempotencyLevelVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return IdempotencyLevel.forNumber(number) != null;
              }
            };

      private final int value;

      private IdempotencyLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.MethodOptions.IdempotencyLevel)
    }

    private int bitField0_;
    public static final int DEPRECATED_FIELD_NUMBER = 33;
    private boolean deprecated_;
    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return Whether the deprecated field is set.
     */
    @java.lang.Override
    public boolean hasDeprecated() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @return The deprecated.
     */
    @java.lang.Override
    public boolean getDeprecated() {
      return deprecated_;
    }
    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     * @param value The deprecated to set.
     */
    private void setDeprecated(boolean value) {
      bitField0_ |= 0x00000001;
      deprecated_ = value;
    }
    /**
     * <pre>
     * Is this method deprecated?
     * Depending on the target platform, this can emit Deprecated annotations
     * for the method, or it will be completely ignored; in the very least,
     * this is a formalization for deprecating methods.
     * </pre>
     *
     * <code>optional bool deprecated = 33 [default = false];</code>
     */
    private void clearDeprecated() {
      bitField0_ = (bitField0_ & ~0x00000001);
      deprecated_ = false;
    }

    public static final int IDEMPOTENCY_LEVEL_FIELD_NUMBER = 34;
    private int idempotencyLevel_;
    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     * @return Whether the idempotencyLevel field is set.
     */
    @java.lang.Override
    public boolean hasIdempotencyLevel() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     * @return The idempotencyLevel.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel getIdempotencyLevel() {
      com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel result = com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel.forNumber(idempotencyLevel_);
      return result == null ? com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel.IDEMPOTENCY_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     * @param value The idempotencyLevel to set.
     */
    private void setIdempotencyLevel(com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel value) {
      idempotencyLevel_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
     */
    private void clearIdempotencyLevel() {
      bitField0_ = (bitField0_ & ~0x00000002);
      idempotencyLevel_ = 0;
    }

    public static final int FEATURES_FIELD_NUMBER = 35;
    private com.google.protobuf.DescriptorProtos.FeatureSet features_;
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     */
    @java.lang.Override
    public boolean hasFeatures() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
      return features_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : features_;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     */
    private void setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  features_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (features_ != null &&
          features_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        features_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(features_).mergeFrom(value).buildPartial();
      } else {
        features_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Any features defined in the specific edition.
     * </pre>
     *
     * <code>optional .google.protobuf.FeatureSet features = 35;</code>
     */
    private void clearFeatures() {  features_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int UNINTERPRETED_OPTION_FIELD_NUMBER = 999;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> uninterpretedOption_;
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder> 
        getUninterpretedOptionOrBuilderList() {
      return uninterpretedOption_;
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public int getUninterpretedOptionCount() {
      return uninterpretedOption_.size();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
      return uninterpretedOption_.get(index);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
        int index) {
      return uninterpretedOption_.get(index);
    }
    private void ensureUninterpretedOptionIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption> tmp = uninterpretedOption_;
      if (!tmp.isModifiable()) {
        uninterpretedOption_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void setUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.set(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addUninterpretedOption(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
      value.getClass();
  ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.add(index, value);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void addAllUninterpretedOption(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
      ensureUninterpretedOptionIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, uninterpretedOption_);
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void clearUninterpretedOption() {
      uninterpretedOption_ = emptyProtobufList();
    }
    /**
     * <pre>
     * The parser stores options it doesn't recognize here. See above.
     * </pre>
     *
     * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
     */
    private void removeUninterpretedOption(int index) {
      ensureUninterpretedOptionIsMutable();
      uninterpretedOption_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.MethodOptions parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.MethodOptions prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code google.protobuf.MethodOptions}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.MethodOptions, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.MethodOptions)
        com.google.protobuf.DescriptorProtos.MethodOptionsOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.MethodOptions.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Is this method deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the method, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating methods.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return Whether the deprecated field is set.
       */
      @java.lang.Override
      public boolean hasDeprecated() {
        return instance.hasDeprecated();
      }
      /**
       * <pre>
       * Is this method deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the method, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating methods.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return The deprecated.
       */
      @java.lang.Override
      public boolean getDeprecated() {
        return instance.getDeprecated();
      }
      /**
       * <pre>
       * Is this method deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the method, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating methods.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @param value The deprecated to set.
       * @return This builder for chaining.
       */
      public Builder setDeprecated(boolean value) {
        copyOnWrite();
        instance.setDeprecated(value);
        return this;
      }
      /**
       * <pre>
       * Is this method deprecated?
       * Depending on the target platform, this can emit Deprecated annotations
       * for the method, or it will be completely ignored; in the very least,
       * this is a formalization for deprecating methods.
       * </pre>
       *
       * <code>optional bool deprecated = 33 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearDeprecated() {
        copyOnWrite();
        instance.clearDeprecated();
        return this;
      }

      /**
       * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
       * @return Whether the idempotencyLevel field is set.
       */
      @java.lang.Override
      public boolean hasIdempotencyLevel() {
        return instance.hasIdempotencyLevel();
      }
      /**
       * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
       * @return The idempotencyLevel.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel getIdempotencyLevel() {
        return instance.getIdempotencyLevel();
      }
      /**
       * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
       * @param value The enum numeric value on the wire for idempotencyLevel to set.
       * @return This builder for chaining.
       */
      public Builder setIdempotencyLevel(com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel value) {
        copyOnWrite();
        instance.setIdempotencyLevel(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
       * @return This builder for chaining.
       */
      public Builder clearIdempotencyLevel() {
        copyOnWrite();
        instance.clearIdempotencyLevel();
        return this;
      }

      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      @java.lang.Override
      public boolean hasFeatures() {
        return instance.hasFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getFeatures() {
        return instance.getFeatures();
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      public Builder setFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setFeatures(value);
        return this;
        }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      public Builder setFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setFeatures(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      public Builder mergeFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeFeatures(value);
        return this;
      }
      /**
       * <pre>
       * Any features defined in the specific edition.
       * </pre>
       *
       * <code>optional .google.protobuf.FeatureSet features = 35;</code>
       */
      public Builder clearFeatures() {  copyOnWrite();
        instance.clearFeatures();
        return this;
      }

      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption> getUninterpretedOptionList() {
        return java.util.Collections.unmodifiableList(
            instance.getUninterpretedOptionList());
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public int getUninterpretedOptionCount() {
        return instance.getUninterpretedOptionCount();
      }/**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption getUninterpretedOption(int index) {
        return instance.getUninterpretedOption(index);
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.setUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder setUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.setUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption value) {
        copyOnWrite();
        instance.addUninterpretedOption(index, value);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addUninterpretedOption(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.Builder builderForValue) {
        copyOnWrite();
        instance.addUninterpretedOption(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder addAllUninterpretedOption(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption> values) {
        copyOnWrite();
        instance.addAllUninterpretedOption(values);
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder clearUninterpretedOption() {
        copyOnWrite();
        instance.clearUninterpretedOption();
        return this;
      }
      /**
       * <pre>
       * The parser stores options it doesn't recognize here. See above.
       * </pre>
       *
       * <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
       */
      public Builder removeUninterpretedOption(int index) {
        copyOnWrite();
        instance.removeUninterpretedOption(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.MethodOptions)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.MethodOptions();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "deprecated_",
              "idempotencyLevel_",
              com.google.protobuf.DescriptorProtos.MethodOptions.IdempotencyLevel.internalGetVerifier(),
              "features_",
              "uninterpretedOption_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.class,
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001!\u03e7\u0004\u0000\u0001\u0002!\u1007\u0000\"\u100c\u0001" +
                "#\u1409\u0002\u03e7\u041b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.MethodOptions> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.MethodOptions.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.MethodOptions>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.MethodOptions)
    private static final com.google.protobuf.DescriptorProtos.MethodOptions DEFAULT_INSTANCE;
    static {
      MethodOptions defaultInstance = new MethodOptions();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        MethodOptions.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.MethodOptions getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<MethodOptions> PARSER;

    public static com.google.protobuf.Parser<MethodOptions> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface UninterpretedOptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.UninterpretedOption)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> 
        getNameList();
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart getName(int index);
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    int getNameCount();

    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return Whether the identifierValue field is set.
     */
    boolean hasIdentifierValue();
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return The identifierValue.
     */
    java.lang.String getIdentifierValue();
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return The bytes for identifierValue.
     */
    com.google.protobuf.ByteString
        getIdentifierValueBytes();

    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     * @return Whether the positiveIntValue field is set.
     */
    boolean hasPositiveIntValue();
    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     * @return The positiveIntValue.
     */
    long getPositiveIntValue();

    /**
     * <code>optional int64 negative_int_value = 5;</code>
     * @return Whether the negativeIntValue field is set.
     */
    boolean hasNegativeIntValue();
    /**
     * <code>optional int64 negative_int_value = 5;</code>
     * @return The negativeIntValue.
     */
    long getNegativeIntValue();

    /**
     * <code>optional double double_value = 6;</code>
     * @return Whether the doubleValue field is set.
     */
    boolean hasDoubleValue();
    /**
     * <code>optional double double_value = 6;</code>
     * @return The doubleValue.
     */
    double getDoubleValue();

    /**
     * <code>optional bytes string_value = 7;</code>
     * @return Whether the stringValue field is set.
     */
    boolean hasStringValue();
    /**
     * <code>optional bytes string_value = 7;</code>
     * @return The stringValue.
     */
    com.google.protobuf.ByteString getStringValue();

    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return Whether the aggregateValue field is set.
     */
    boolean hasAggregateValue();
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return The aggregateValue.
     */
    java.lang.String getAggregateValue();
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return The bytes for aggregateValue.
     */
    com.google.protobuf.ByteString
        getAggregateValueBytes();
  }
  /**
   * <pre>
   * A message representing a option the parser does not recognize. This only
   * appears in options protos created by the compiler::Parser class.
   * DescriptorPool resolves these when building Descriptor objects. Therefore,
   * options protos in descriptor objects (e.g. returned by Descriptor::options(),
   * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
   * in them.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.UninterpretedOption}
   */
  public  static final class UninterpretedOption extends
      com.google.protobuf.GeneratedMessageLite<
          UninterpretedOption, UninterpretedOption.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.UninterpretedOption)
      UninterpretedOptionOrBuilder {
    private UninterpretedOption() {
      name_ = emptyProtobufList();
      identifierValue_ = "";
      stringValue_ = com.google.protobuf.ByteString.EMPTY;
      aggregateValue_ = "";
    }
    public interface NamePartOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.UninterpretedOption.NamePart)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <code>required string name_part = 1;</code>
       * @return Whether the namePart field is set.
       */
      boolean hasNamePart();
      /**
       * <code>required string name_part = 1;</code>
       * @return The namePart.
       */
      java.lang.String getNamePart();
      /**
       * <code>required string name_part = 1;</code>
       * @return The bytes for namePart.
       */
      com.google.protobuf.ByteString
          getNamePartBytes();

      /**
       * <code>required bool is_extension = 2;</code>
       * @return Whether the isExtension field is set.
       */
      boolean hasIsExtension();
      /**
       * <code>required bool is_extension = 2;</code>
       * @return The isExtension.
       */
      boolean getIsExtension();
    }
    /**
     * <pre>
     * The name of the uninterpreted option.  Each string represents a segment in
     * a dot-separated name.  is_extension is true iff a segment represents an
     * extension (denoted with parentheses in options specs in .proto files).
     * E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
     * "foo.(bar.baz).moo".
     * </pre>
     *
     * Protobuf type {@code google.protobuf.UninterpretedOption.NamePart}
     */
    public  static final class NamePart extends
        com.google.protobuf.GeneratedMessageLite<
            NamePart, NamePart.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.UninterpretedOption.NamePart)
        NamePartOrBuilder {
      private NamePart() {
        namePart_ = "";
      }
      private int bitField0_;
      public static final int NAME_PART_FIELD_NUMBER = 1;
      private java.lang.String namePart_;
      /**
       * <code>required string name_part = 1;</code>
       * @return Whether the namePart field is set.
       */
      @java.lang.Override
      public boolean hasNamePart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required string name_part = 1;</code>
       * @return The namePart.
       */
      @java.lang.Override
      public java.lang.String getNamePart() {
        return namePart_;
      }
      /**
       * <code>required string name_part = 1;</code>
       * @return The bytes for namePart.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getNamePartBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(namePart_);
      }
      /**
       * <code>required string name_part = 1;</code>
       * @param value The namePart to set.
       */
      private void setNamePart(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        namePart_ = value;
      }
      /**
       * <code>required string name_part = 1;</code>
       */
      private void clearNamePart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        namePart_ = getDefaultInstance().getNamePart();
      }
      /**
       * <code>required string name_part = 1;</code>
       * @param value The bytes for namePart to set.
       */
      private void setNamePartBytes(
          com.google.protobuf.ByteString value) {
        namePart_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int IS_EXTENSION_FIELD_NUMBER = 2;
      private boolean isExtension_;
      /**
       * <code>required bool is_extension = 2;</code>
       * @return Whether the isExtension field is set.
       */
      @java.lang.Override
      public boolean hasIsExtension() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>required bool is_extension = 2;</code>
       * @return The isExtension.
       */
      @java.lang.Override
      public boolean getIsExtension() {
        return isExtension_;
      }
      /**
       * <code>required bool is_extension = 2;</code>
       * @param value The isExtension to set.
       */
      private void setIsExtension(boolean value) {
        bitField0_ |= 0x00000002;
        isExtension_ = value;
      }
      /**
       * <code>required bool is_extension = 2;</code>
       */
      private void clearIsExtension() {
        bitField0_ = (bitField0_ & ~0x00000002);
        isExtension_ = false;
      }

      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * <pre>
       * The name of the uninterpreted option.  Each string represents a segment in
       * a dot-separated name.  is_extension is true iff a segment represents an
       * extension (denoted with parentheses in options specs in .proto files).
       * E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
       * "foo.(bar.baz).moo".
       * </pre>
       *
       * Protobuf type {@code google.protobuf.UninterpretedOption.NamePart}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.UninterpretedOption.NamePart)
          com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePartOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <code>required string name_part = 1;</code>
         * @return Whether the namePart field is set.
         */
        @java.lang.Override
        public boolean hasNamePart() {
          return instance.hasNamePart();
        }
        /**
         * <code>required string name_part = 1;</code>
         * @return The namePart.
         */
        @java.lang.Override
        public java.lang.String getNamePart() {
          return instance.getNamePart();
        }
        /**
         * <code>required string name_part = 1;</code>
         * @return The bytes for namePart.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getNamePartBytes() {
          return instance.getNamePartBytes();
        }
        /**
         * <code>required string name_part = 1;</code>
         * @param value The namePart to set.
         * @return This builder for chaining.
         */
        public Builder setNamePart(
            java.lang.String value) {
          copyOnWrite();
          instance.setNamePart(value);
          return this;
        }
        /**
         * <code>required string name_part = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearNamePart() {
          copyOnWrite();
          instance.clearNamePart();
          return this;
        }
        /**
         * <code>required string name_part = 1;</code>
         * @param value The bytes for namePart to set.
         * @return This builder for chaining.
         */
        public Builder setNamePartBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setNamePartBytes(value);
          return this;
        }

        /**
         * <code>required bool is_extension = 2;</code>
         * @return Whether the isExtension field is set.
         */
        @java.lang.Override
        public boolean hasIsExtension() {
          return instance.hasIsExtension();
        }
        /**
         * <code>required bool is_extension = 2;</code>
         * @return The isExtension.
         */
        @java.lang.Override
        public boolean getIsExtension() {
          return instance.getIsExtension();
        }
        /**
         * <code>required bool is_extension = 2;</code>
         * @param value The isExtension to set.
         * @return This builder for chaining.
         */
        public Builder setIsExtension(boolean value) {
          copyOnWrite();
          instance.setIsExtension(value);
          return this;
        }
        /**
         * <code>required bool is_extension = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearIsExtension() {
          copyOnWrite();
          instance.clearIsExtension();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.UninterpretedOption.NamePart)
      }
      private byte memoizedIsInitialized = 2;
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "namePart_",
                "isExtension_",
              };
              java.lang.String info =
                  "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u1508\u0000\u0002" +
                  "\u1507\u0001";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return memoizedIsInitialized;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.UninterpretedOption.NamePart)
      private static final com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart DEFAULT_INSTANCE;
      static {
        NamePart defaultInstance = new NamePart();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          NamePart.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<NamePart> PARSER;

      public static com.google.protobuf.Parser<NamePart> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> name_;
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> getNameList() {
      return name_;
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePartOrBuilder> 
        getNameOrBuilderList() {
      return name_;
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    @java.lang.Override
    public int getNameCount() {
      return name_.size();
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart getName(int index) {
      return name_.get(index);
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    public com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePartOrBuilder getNameOrBuilder(
        int index) {
      return name_.get(index);
    }
    private void ensureNameIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> tmp = name_;
      if (!tmp.isModifiable()) {
        name_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void setName(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
      value.getClass();
  ensureNameIsMutable();
      name_.set(index, value);
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void addName(com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
      value.getClass();
  ensureNameIsMutable();
      name_.add(value);
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void addName(
        int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
      value.getClass();
  ensureNameIsMutable();
      name_.add(index, value);
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void addAllName(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> values) {
      ensureNameIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, name_);
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void clearName() {
      name_ = emptyProtobufList();
    }
    /**
     * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
     */
    private void removeName(int index) {
      ensureNameIsMutable();
      name_.remove(index);
    }

    public static final int IDENTIFIER_VALUE_FIELD_NUMBER = 3;
    private java.lang.String identifierValue_;
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return Whether the identifierValue field is set.
     */
    @java.lang.Override
    public boolean hasIdentifierValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return The identifierValue.
     */
    @java.lang.Override
    public java.lang.String getIdentifierValue() {
      return identifierValue_;
    }
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @return The bytes for identifierValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getIdentifierValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(identifierValue_);
    }
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @param value The identifierValue to set.
     */
    private void setIdentifierValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      identifierValue_ = value;
    }
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     */
    private void clearIdentifierValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      identifierValue_ = getDefaultInstance().getIdentifierValue();
    }
    /**
     * <pre>
     * The value of the uninterpreted option, in whatever type the tokenizer
     * identified it as during parsing. Exactly one of these should be set.
     * </pre>
     *
     * <code>optional string identifier_value = 3;</code>
     * @param value The bytes for identifierValue to set.
     */
    private void setIdentifierValueBytes(
        com.google.protobuf.ByteString value) {
      identifierValue_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int POSITIVE_INT_VALUE_FIELD_NUMBER = 4;
    private long positiveIntValue_;
    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     * @return Whether the positiveIntValue field is set.
     */
    @java.lang.Override
    public boolean hasPositiveIntValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     * @return The positiveIntValue.
     */
    @java.lang.Override
    public long getPositiveIntValue() {
      return positiveIntValue_;
    }
    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     * @param value The positiveIntValue to set.
     */
    private void setPositiveIntValue(long value) {
      bitField0_ |= 0x00000002;
      positiveIntValue_ = value;
    }
    /**
     * <code>optional uint64 positive_int_value = 4;</code>
     */
    private void clearPositiveIntValue() {
      bitField0_ = (bitField0_ & ~0x00000002);
      positiveIntValue_ = 0L;
    }

    public static final int NEGATIVE_INT_VALUE_FIELD_NUMBER = 5;
    private long negativeIntValue_;
    /**
     * <code>optional int64 negative_int_value = 5;</code>
     * @return Whether the negativeIntValue field is set.
     */
    @java.lang.Override
    public boolean hasNegativeIntValue() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional int64 negative_int_value = 5;</code>
     * @return The negativeIntValue.
     */
    @java.lang.Override
    public long getNegativeIntValue() {
      return negativeIntValue_;
    }
    /**
     * <code>optional int64 negative_int_value = 5;</code>
     * @param value The negativeIntValue to set.
     */
    private void setNegativeIntValue(long value) {
      bitField0_ |= 0x00000004;
      negativeIntValue_ = value;
    }
    /**
     * <code>optional int64 negative_int_value = 5;</code>
     */
    private void clearNegativeIntValue() {
      bitField0_ = (bitField0_ & ~0x00000004);
      negativeIntValue_ = 0L;
    }

    public static final int DOUBLE_VALUE_FIELD_NUMBER = 6;
    private double doubleValue_;
    /**
     * <code>optional double double_value = 6;</code>
     * @return Whether the doubleValue field is set.
     */
    @java.lang.Override
    public boolean hasDoubleValue() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional double double_value = 6;</code>
     * @return The doubleValue.
     */
    @java.lang.Override
    public double getDoubleValue() {
      return doubleValue_;
    }
    /**
     * <code>optional double double_value = 6;</code>
     * @param value The doubleValue to set.
     */
    private void setDoubleValue(double value) {
      bitField0_ |= 0x00000008;
      doubleValue_ = value;
    }
    /**
     * <code>optional double double_value = 6;</code>
     */
    private void clearDoubleValue() {
      bitField0_ = (bitField0_ & ~0x00000008);
      doubleValue_ = 0D;
    }

    public static final int STRING_VALUE_FIELD_NUMBER = 7;
    private com.google.protobuf.ByteString stringValue_;
    /**
     * <code>optional bytes string_value = 7;</code>
     * @return Whether the stringValue field is set.
     */
    @java.lang.Override
    public boolean hasStringValue() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional bytes string_value = 7;</code>
     * @return The stringValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getStringValue() {
      return stringValue_;
    }
    /**
     * <code>optional bytes string_value = 7;</code>
     * @param value The stringValue to set.
     */
    private void setStringValue(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000010;
      stringValue_ = value;
    }
    /**
     * <code>optional bytes string_value = 7;</code>
     */
    private void clearStringValue() {
      bitField0_ = (bitField0_ & ~0x00000010);
      stringValue_ = getDefaultInstance().getStringValue();
    }

    public static final int AGGREGATE_VALUE_FIELD_NUMBER = 8;
    private java.lang.String aggregateValue_;
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return Whether the aggregateValue field is set.
     */
    @java.lang.Override
    public boolean hasAggregateValue() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return The aggregateValue.
     */
    @java.lang.Override
    public java.lang.String getAggregateValue() {
      return aggregateValue_;
    }
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @return The bytes for aggregateValue.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAggregateValueBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(aggregateValue_);
    }
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @param value The aggregateValue to set.
     */
    private void setAggregateValue(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000020;
      aggregateValue_ = value;
    }
    /**
     * <code>optional string aggregate_value = 8;</code>
     */
    private void clearAggregateValue() {
      bitField0_ = (bitField0_ & ~0x00000020);
      aggregateValue_ = getDefaultInstance().getAggregateValue();
    }
    /**
     * <code>optional string aggregate_value = 8;</code>
     * @param value The bytes for aggregateValue to set.
     */
    private void setAggregateValueBytes(
        com.google.protobuf.ByteString value) {
      aggregateValue_ = value.toStringUtf8();
      bitField0_ |= 0x00000020;
    }

    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.UninterpretedOption parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.UninterpretedOption prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A message representing a option the parser does not recognize. This only
     * appears in options protos created by the compiler::Parser class.
     * DescriptorPool resolves these when building Descriptor objects. Therefore,
     * options protos in descriptor objects (e.g. returned by Descriptor::options(),
     * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
     * in them.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.UninterpretedOption}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.UninterpretedOption, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.UninterpretedOption)
        com.google.protobuf.DescriptorProtos.UninterpretedOptionOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.UninterpretedOption.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> getNameList() {
        return java.util.Collections.unmodifiableList(
            instance.getNameList());
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      @java.lang.Override
      public int getNameCount() {
        return instance.getNameCount();
      }/**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart getName(int index) {
        return instance.getName(index);
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder setName(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
        copyOnWrite();
        instance.setName(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder setName(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.Builder builderForValue) {
        copyOnWrite();
        instance.setName(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder addName(com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
        copyOnWrite();
        instance.addName(value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder addName(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart value) {
        copyOnWrite();
        instance.addName(index, value);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder addName(
          com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.Builder builderForValue) {
        copyOnWrite();
        instance.addName(builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder addName(
          int index, com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.Builder builderForValue) {
        copyOnWrite();
        instance.addName(index,
            builderForValue.build());
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder addAllName(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart> values) {
        copyOnWrite();
        instance.addAllName(values);
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <code>repeated .google.protobuf.UninterpretedOption.NamePart name = 2;</code>
       */
      public Builder removeName(int index) {
        copyOnWrite();
        instance.removeName(index);
        return this;
      }

      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @return Whether the identifierValue field is set.
       */
      @java.lang.Override
      public boolean hasIdentifierValue() {
        return instance.hasIdentifierValue();
      }
      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @return The identifierValue.
       */
      @java.lang.Override
      public java.lang.String getIdentifierValue() {
        return instance.getIdentifierValue();
      }
      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @return The bytes for identifierValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getIdentifierValueBytes() {
        return instance.getIdentifierValueBytes();
      }
      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @param value The identifierValue to set.
       * @return This builder for chaining.
       */
      public Builder setIdentifierValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setIdentifierValue(value);
        return this;
      }
      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIdentifierValue() {
        copyOnWrite();
        instance.clearIdentifierValue();
        return this;
      }
      /**
       * <pre>
       * The value of the uninterpreted option, in whatever type the tokenizer
       * identified it as during parsing. Exactly one of these should be set.
       * </pre>
       *
       * <code>optional string identifier_value = 3;</code>
       * @param value The bytes for identifierValue to set.
       * @return This builder for chaining.
       */
      public Builder setIdentifierValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdentifierValueBytes(value);
        return this;
      }

      /**
       * <code>optional uint64 positive_int_value = 4;</code>
       * @return Whether the positiveIntValue field is set.
       */
      @java.lang.Override
      public boolean hasPositiveIntValue() {
        return instance.hasPositiveIntValue();
      }
      /**
       * <code>optional uint64 positive_int_value = 4;</code>
       * @return The positiveIntValue.
       */
      @java.lang.Override
      public long getPositiveIntValue() {
        return instance.getPositiveIntValue();
      }
      /**
       * <code>optional uint64 positive_int_value = 4;</code>
       * @param value The positiveIntValue to set.
       * @return This builder for chaining.
       */
      public Builder setPositiveIntValue(long value) {
        copyOnWrite();
        instance.setPositiveIntValue(value);
        return this;
      }
      /**
       * <code>optional uint64 positive_int_value = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPositiveIntValue() {
        copyOnWrite();
        instance.clearPositiveIntValue();
        return this;
      }

      /**
       * <code>optional int64 negative_int_value = 5;</code>
       * @return Whether the negativeIntValue field is set.
       */
      @java.lang.Override
      public boolean hasNegativeIntValue() {
        return instance.hasNegativeIntValue();
      }
      /**
       * <code>optional int64 negative_int_value = 5;</code>
       * @return The negativeIntValue.
       */
      @java.lang.Override
      public long getNegativeIntValue() {
        return instance.getNegativeIntValue();
      }
      /**
       * <code>optional int64 negative_int_value = 5;</code>
       * @param value The negativeIntValue to set.
       * @return This builder for chaining.
       */
      public Builder setNegativeIntValue(long value) {
        copyOnWrite();
        instance.setNegativeIntValue(value);
        return this;
      }
      /**
       * <code>optional int64 negative_int_value = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearNegativeIntValue() {
        copyOnWrite();
        instance.clearNegativeIntValue();
        return this;
      }

      /**
       * <code>optional double double_value = 6;</code>
       * @return Whether the doubleValue field is set.
       */
      @java.lang.Override
      public boolean hasDoubleValue() {
        return instance.hasDoubleValue();
      }
      /**
       * <code>optional double double_value = 6;</code>
       * @return The doubleValue.
       */
      @java.lang.Override
      public double getDoubleValue() {
        return instance.getDoubleValue();
      }
      /**
       * <code>optional double double_value = 6;</code>
       * @param value The doubleValue to set.
       * @return This builder for chaining.
       */
      public Builder setDoubleValue(double value) {
        copyOnWrite();
        instance.setDoubleValue(value);
        return this;
      }
      /**
       * <code>optional double double_value = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDoubleValue() {
        copyOnWrite();
        instance.clearDoubleValue();
        return this;
      }

      /**
       * <code>optional bytes string_value = 7;</code>
       * @return Whether the stringValue field is set.
       */
      @java.lang.Override
      public boolean hasStringValue() {
        return instance.hasStringValue();
      }
      /**
       * <code>optional bytes string_value = 7;</code>
       * @return The stringValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getStringValue() {
        return instance.getStringValue();
      }
      /**
       * <code>optional bytes string_value = 7;</code>
       * @param value The stringValue to set.
       * @return This builder for chaining.
       */
      public Builder setStringValue(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStringValue(value);
        return this;
      }
      /**
       * <code>optional bytes string_value = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringValue() {
        copyOnWrite();
        instance.clearStringValue();
        return this;
      }

      /**
       * <code>optional string aggregate_value = 8;</code>
       * @return Whether the aggregateValue field is set.
       */
      @java.lang.Override
      public boolean hasAggregateValue() {
        return instance.hasAggregateValue();
      }
      /**
       * <code>optional string aggregate_value = 8;</code>
       * @return The aggregateValue.
       */
      @java.lang.Override
      public java.lang.String getAggregateValue() {
        return instance.getAggregateValue();
      }
      /**
       * <code>optional string aggregate_value = 8;</code>
       * @return The bytes for aggregateValue.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getAggregateValueBytes() {
        return instance.getAggregateValueBytes();
      }
      /**
       * <code>optional string aggregate_value = 8;</code>
       * @param value The aggregateValue to set.
       * @return This builder for chaining.
       */
      public Builder setAggregateValue(
          java.lang.String value) {
        copyOnWrite();
        instance.setAggregateValue(value);
        return this;
      }
      /**
       * <code>optional string aggregate_value = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearAggregateValue() {
        copyOnWrite();
        instance.clearAggregateValue();
        return this;
      }
      /**
       * <code>optional string aggregate_value = 8;</code>
       * @param value The bytes for aggregateValue to set.
       * @return This builder for chaining.
       */
      public Builder setAggregateValueBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAggregateValueBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.UninterpretedOption)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.UninterpretedOption();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "name_",
              com.google.protobuf.DescriptorProtos.UninterpretedOption.NamePart.class,
              "identifierValue_",
              "positiveIntValue_",
              "negativeIntValue_",
              "doubleValue_",
              "stringValue_",
              "aggregateValue_",
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0001\u0002\b\u0007\u0000\u0001\u0001\u0002\u041b\u0003\u1008" +
                "\u0000\u0004\u1003\u0001\u0005\u1002\u0002\u0006\u1000\u0003\u0007\u100a\u0004\b" +
                "\u1008\u0005";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.UninterpretedOption> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.UninterpretedOption.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.UninterpretedOption>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.UninterpretedOption)
    private static final com.google.protobuf.DescriptorProtos.UninterpretedOption DEFAULT_INSTANCE;
    static {
      UninterpretedOption defaultInstance = new UninterpretedOption();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        UninterpretedOption.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.UninterpretedOption getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<UninterpretedOption> PARSER;

    public static com.google.protobuf.Parser<UninterpretedOption> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeatureSetOrBuilder extends 
      // @@protoc_insertion_point(interface_extends:google.protobuf.FeatureSet)
       com.google.protobuf.GeneratedMessageLite.
            ExtendableMessageOrBuilder<
                FeatureSet, FeatureSet.Builder> {

    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the fieldPresence field is set.
     */
    boolean hasFieldPresence();
    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The fieldPresence.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence getFieldPresence();

    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the enumType field is set.
     */
    boolean hasEnumType();
    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The enumType.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.EnumType getEnumType();

    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the repeatedFieldEncoding field is set.
     */
    boolean hasRepeatedFieldEncoding();
    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The repeatedFieldEncoding.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding getRepeatedFieldEncoding();

    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the stringFieldValidation field is set.
     */
    boolean hasStringFieldValidation();
    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The stringFieldValidation.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation getStringFieldValidation();

    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the messageEncoding field is set.
     */
    boolean hasMessageEncoding();
    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The messageEncoding.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding getMessageEncoding();

    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the jsonFormat field is set.
     */
    boolean hasJsonFormat();
    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The jsonFormat.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat getJsonFormat();

    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     * @return Whether the rawFeatures field is set.
     */
    boolean hasRawFeatures();
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     * @return The rawFeatures.
     */
    com.google.protobuf.DescriptorProtos.FeatureSet getRawFeatures();
  }
  /**
   * <pre>
   * TODO(b/274655146) Enums in C++ gencode (and potentially other languages) are
   * not well scoped.  This means that each of the feature enums below can clash
   * with each other.  The short names we've chosen maximize call-site
   * readability, but leave us very open to this scenario.  A future feature will
   * be designed and implemented to handle this, hopefully before we ever hit a
   * conflict here.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.FeatureSet}
   */
  public  static final class FeatureSet extends
      com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
        FeatureSet, FeatureSet.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.FeatureSet)
      FeatureSetOrBuilder {
    private FeatureSet() {
    }
    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.FieldPresence}
     */
    public enum FieldPresence
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>FIELD_PRESENCE_UNKNOWN = 0;</code>
       */
      FIELD_PRESENCE_UNKNOWN(0),
      /**
       * <code>EXPLICIT = 1;</code>
       */
      EXPLICIT(1),
      /**
       * <code>IMPLICIT = 2;</code>
       */
      IMPLICIT(2),
      /**
       * <code>LEGACY_REQUIRED = 3;</code>
       */
      LEGACY_REQUIRED(3),
      ;

      /**
       * <code>FIELD_PRESENCE_UNKNOWN = 0;</code>
       */
      public static final int FIELD_PRESENCE_UNKNOWN_VALUE = 0;
      /**
       * <code>EXPLICIT = 1;</code>
       */
      public static final int EXPLICIT_VALUE = 1;
      /**
       * <code>IMPLICIT = 2;</code>
       */
      public static final int IMPLICIT_VALUE = 2;
      /**
       * <code>LEGACY_REQUIRED = 3;</code>
       */
      public static final int LEGACY_REQUIRED_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FieldPresence valueOf(int value) {
        return forNumber(value);
      }

      public static FieldPresence forNumber(int value) {
        switch (value) {
          case 0: return FIELD_PRESENCE_UNKNOWN;
          case 1: return EXPLICIT;
          case 2: return IMPLICIT;
          case 3: return LEGACY_REQUIRED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FieldPresence>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FieldPresence> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FieldPresence>() {
              @java.lang.Override
              public FieldPresence findValueByNumber(int number) {
                return FieldPresence.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return FieldPresenceVerifier.INSTANCE;
      }

      private static final class FieldPresenceVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new FieldPresenceVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return FieldPresence.forNumber(number) != null;
              }
            };

      private final int value;

      private FieldPresence(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.FieldPresence)
    }

    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.EnumType}
     */
    public enum EnumType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>ENUM_TYPE_UNKNOWN = 0;</code>
       */
      ENUM_TYPE_UNKNOWN(0),
      /**
       * <code>OPEN = 1;</code>
       */
      OPEN(1),
      /**
       * <code>CLOSED = 2;</code>
       */
      CLOSED(2),
      ;

      /**
       * <code>ENUM_TYPE_UNKNOWN = 0;</code>
       */
      public static final int ENUM_TYPE_UNKNOWN_VALUE = 0;
      /**
       * <code>OPEN = 1;</code>
       */
      public static final int OPEN_VALUE = 1;
      /**
       * <code>CLOSED = 2;</code>
       */
      public static final int CLOSED_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static EnumType valueOf(int value) {
        return forNumber(value);
      }

      public static EnumType forNumber(int value) {
        switch (value) {
          case 0: return ENUM_TYPE_UNKNOWN;
          case 1: return OPEN;
          case 2: return CLOSED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<EnumType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          EnumType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<EnumType>() {
              @java.lang.Override
              public EnumType findValueByNumber(int number) {
                return EnumType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return EnumTypeVerifier.INSTANCE;
      }

      private static final class EnumTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new EnumTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return EnumType.forNumber(number) != null;
              }
            };

      private final int value;

      private EnumType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.EnumType)
    }

    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.RepeatedFieldEncoding}
     */
    public enum RepeatedFieldEncoding
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>REPEATED_FIELD_ENCODING_UNKNOWN = 0;</code>
       */
      REPEATED_FIELD_ENCODING_UNKNOWN(0),
      /**
       * <code>PACKED = 1;</code>
       */
      PACKED(1),
      /**
       * <code>EXPANDED = 2;</code>
       */
      EXPANDED(2),
      ;

      /**
       * <code>REPEATED_FIELD_ENCODING_UNKNOWN = 0;</code>
       */
      public static final int REPEATED_FIELD_ENCODING_UNKNOWN_VALUE = 0;
      /**
       * <code>PACKED = 1;</code>
       */
      public static final int PACKED_VALUE = 1;
      /**
       * <code>EXPANDED = 2;</code>
       */
      public static final int EXPANDED_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static RepeatedFieldEncoding valueOf(int value) {
        return forNumber(value);
      }

      public static RepeatedFieldEncoding forNumber(int value) {
        switch (value) {
          case 0: return REPEATED_FIELD_ENCODING_UNKNOWN;
          case 1: return PACKED;
          case 2: return EXPANDED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<RepeatedFieldEncoding>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          RepeatedFieldEncoding> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RepeatedFieldEncoding>() {
              @java.lang.Override
              public RepeatedFieldEncoding findValueByNumber(int number) {
                return RepeatedFieldEncoding.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return RepeatedFieldEncodingVerifier.INSTANCE;
      }

      private static final class RepeatedFieldEncodingVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new RepeatedFieldEncodingVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return RepeatedFieldEncoding.forNumber(number) != null;
              }
            };

      private final int value;

      private RepeatedFieldEncoding(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.RepeatedFieldEncoding)
    }

    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.StringFieldValidation}
     */
    public enum StringFieldValidation
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>STRING_FIELD_VALIDATION_UNKNOWN = 0;</code>
       */
      STRING_FIELD_VALIDATION_UNKNOWN(0),
      /**
       * <code>MANDATORY = 1;</code>
       */
      MANDATORY(1),
      /**
       * <code>HINT = 2;</code>
       */
      HINT(2),
      /**
       * <code>NONE = 3;</code>
       */
      NONE(3),
      ;

      /**
       * <code>STRING_FIELD_VALIDATION_UNKNOWN = 0;</code>
       */
      public static final int STRING_FIELD_VALIDATION_UNKNOWN_VALUE = 0;
      /**
       * <code>MANDATORY = 1;</code>
       */
      public static final int MANDATORY_VALUE = 1;
      /**
       * <code>HINT = 2;</code>
       */
      public static final int HINT_VALUE = 2;
      /**
       * <code>NONE = 3;</code>
       */
      public static final int NONE_VALUE = 3;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static StringFieldValidation valueOf(int value) {
        return forNumber(value);
      }

      public static StringFieldValidation forNumber(int value) {
        switch (value) {
          case 0: return STRING_FIELD_VALIDATION_UNKNOWN;
          case 1: return MANDATORY;
          case 2: return HINT;
          case 3: return NONE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<StringFieldValidation>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          StringFieldValidation> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<StringFieldValidation>() {
              @java.lang.Override
              public StringFieldValidation findValueByNumber(int number) {
                return StringFieldValidation.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return StringFieldValidationVerifier.INSTANCE;
      }

      private static final class StringFieldValidationVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new StringFieldValidationVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return StringFieldValidation.forNumber(number) != null;
              }
            };

      private final int value;

      private StringFieldValidation(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.StringFieldValidation)
    }

    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.MessageEncoding}
     */
    public enum MessageEncoding
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>MESSAGE_ENCODING_UNKNOWN = 0;</code>
       */
      MESSAGE_ENCODING_UNKNOWN(0),
      /**
       * <code>LENGTH_PREFIXED = 1;</code>
       */
      LENGTH_PREFIXED(1),
      /**
       * <code>DELIMITED = 2;</code>
       */
      DELIMITED(2),
      ;

      /**
       * <code>MESSAGE_ENCODING_UNKNOWN = 0;</code>
       */
      public static final int MESSAGE_ENCODING_UNKNOWN_VALUE = 0;
      /**
       * <code>LENGTH_PREFIXED = 1;</code>
       */
      public static final int LENGTH_PREFIXED_VALUE = 1;
      /**
       * <code>DELIMITED = 2;</code>
       */
      public static final int DELIMITED_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static MessageEncoding valueOf(int value) {
        return forNumber(value);
      }

      public static MessageEncoding forNumber(int value) {
        switch (value) {
          case 0: return MESSAGE_ENCODING_UNKNOWN;
          case 1: return LENGTH_PREFIXED;
          case 2: return DELIMITED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<MessageEncoding>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          MessageEncoding> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<MessageEncoding>() {
              @java.lang.Override
              public MessageEncoding findValueByNumber(int number) {
                return MessageEncoding.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return MessageEncodingVerifier.INSTANCE;
      }

      private static final class MessageEncodingVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new MessageEncodingVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return MessageEncoding.forNumber(number) != null;
              }
            };

      private final int value;

      private MessageEncoding(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.MessageEncoding)
    }

    /**
     * Protobuf enum {@code google.protobuf.FeatureSet.JsonFormat}
     */
    public enum JsonFormat
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>JSON_FORMAT_UNKNOWN = 0;</code>
       */
      JSON_FORMAT_UNKNOWN(0),
      /**
       * <code>ALLOW = 1;</code>
       */
      ALLOW(1),
      /**
       * <code>LEGACY_BEST_EFFORT = 2;</code>
       */
      LEGACY_BEST_EFFORT(2),
      ;

      /**
       * <code>JSON_FORMAT_UNKNOWN = 0;</code>
       */
      public static final int JSON_FORMAT_UNKNOWN_VALUE = 0;
      /**
       * <code>ALLOW = 1;</code>
       */
      public static final int ALLOW_VALUE = 1;
      /**
       * <code>LEGACY_BEST_EFFORT = 2;</code>
       */
      public static final int LEGACY_BEST_EFFORT_VALUE = 2;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static JsonFormat valueOf(int value) {
        return forNumber(value);
      }

      public static JsonFormat forNumber(int value) {
        switch (value) {
          case 0: return JSON_FORMAT_UNKNOWN;
          case 1: return ALLOW;
          case 2: return LEGACY_BEST_EFFORT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<JsonFormat>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          JsonFormat> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<JsonFormat>() {
              @java.lang.Override
              public JsonFormat findValueByNumber(int number) {
                return JsonFormat.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return JsonFormatVerifier.INSTANCE;
      }

      private static final class JsonFormatVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new JsonFormatVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return JsonFormat.forNumber(number) != null;
              }
            };

      private final int value;

      private JsonFormat(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:google.protobuf.FeatureSet.JsonFormat)
    }

    private int bitField0_;
    public static final int FIELD_PRESENCE_FIELD_NUMBER = 1;
    private int fieldPresence_;
    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the fieldPresence field is set.
     */
    @java.lang.Override
    public boolean hasFieldPresence() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The fieldPresence.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence getFieldPresence() {
      com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence result = com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence.forNumber(fieldPresence_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence.FIELD_PRESENCE_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The fieldPresence to set.
     */
    private void setFieldPresence(com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence value) {
      fieldPresence_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearFieldPresence() {
      bitField0_ = (bitField0_ & ~0x00000001);
      fieldPresence_ = 0;
    }

    public static final int ENUM_TYPE_FIELD_NUMBER = 2;
    private int enumType_;
    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the enumType field is set.
     */
    @java.lang.Override
    public boolean hasEnumType() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The enumType.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.EnumType getEnumType() {
      com.google.protobuf.DescriptorProtos.FeatureSet.EnumType result = com.google.protobuf.DescriptorProtos.FeatureSet.EnumType.forNumber(enumType_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.EnumType.ENUM_TYPE_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The enumType to set.
     */
    private void setEnumType(com.google.protobuf.DescriptorProtos.FeatureSet.EnumType value) {
      enumType_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearEnumType() {
      bitField0_ = (bitField0_ & ~0x00000002);
      enumType_ = 0;
    }

    public static final int REPEATED_FIELD_ENCODING_FIELD_NUMBER = 3;
    private int repeatedFieldEncoding_;
    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the repeatedFieldEncoding field is set.
     */
    @java.lang.Override
    public boolean hasRepeatedFieldEncoding() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The repeatedFieldEncoding.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding getRepeatedFieldEncoding() {
      com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding result = com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding.forNumber(repeatedFieldEncoding_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding.REPEATED_FIELD_ENCODING_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The repeatedFieldEncoding to set.
     */
    private void setRepeatedFieldEncoding(com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding value) {
      repeatedFieldEncoding_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearRepeatedFieldEncoding() {
      bitField0_ = (bitField0_ & ~0x00000004);
      repeatedFieldEncoding_ = 0;
    }

    public static final int STRING_FIELD_VALIDATION_FIELD_NUMBER = 4;
    private int stringFieldValidation_;
    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the stringFieldValidation field is set.
     */
    @java.lang.Override
    public boolean hasStringFieldValidation() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The stringFieldValidation.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation getStringFieldValidation() {
      com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation result = com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation.forNumber(stringFieldValidation_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation.STRING_FIELD_VALIDATION_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The stringFieldValidation to set.
     */
    private void setStringFieldValidation(com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation value) {
      stringFieldValidation_ = value.getNumber();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearStringFieldValidation() {
      bitField0_ = (bitField0_ & ~0x00000008);
      stringFieldValidation_ = 0;
    }

    public static final int MESSAGE_ENCODING_FIELD_NUMBER = 5;
    private int messageEncoding_;
    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the messageEncoding field is set.
     */
    @java.lang.Override
    public boolean hasMessageEncoding() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The messageEncoding.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding getMessageEncoding() {
      com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding result = com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding.forNumber(messageEncoding_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding.MESSAGE_ENCODING_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The messageEncoding to set.
     */
    private void setMessageEncoding(com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding value) {
      messageEncoding_ = value.getNumber();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearMessageEncoding() {
      bitField0_ = (bitField0_ & ~0x00000010);
      messageEncoding_ = 0;
    }

    public static final int JSON_FORMAT_FIELD_NUMBER = 6;
    private int jsonFormat_;
    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return Whether the jsonFormat field is set.
     */
    @java.lang.Override
    public boolean hasJsonFormat() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @return The jsonFormat.
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat getJsonFormat() {
      com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat result = com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat.forNumber(jsonFormat_);
      return result == null ? com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat.JSON_FORMAT_UNKNOWN : result;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     * @param value The jsonFormat to set.
     */
    private void setJsonFormat(com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat value) {
      jsonFormat_ = value.getNumber();
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
     */
    private void clearJsonFormat() {
      bitField0_ = (bitField0_ & ~0x00000020);
      jsonFormat_ = 0;
    }

    public static final int RAW_FEATURES_FIELD_NUMBER = 999;
    private com.google.protobuf.DescriptorProtos.FeatureSet rawFeatures_;
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     */
    @java.lang.Override
    public boolean hasRawFeatures() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.FeatureSet getRawFeatures() {
      return rawFeatures_ == null ? com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance() : rawFeatures_;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     */
    private void setRawFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  rawFeatures_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeRawFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
      value.getClass();
  if (rawFeatures_ != null &&
          rawFeatures_ != com.google.protobuf.DescriptorProtos.FeatureSet.getDefaultInstance()) {
        rawFeatures_ =
          com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder(rawFeatures_).mergeFrom(value).buildPartial();
      } else {
        rawFeatures_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
     */
    private void clearRawFeatures() {  rawFeatures_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.FeatureSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.FeatureSet prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * TODO(b/274655146) Enums in C++ gencode (and potentially other languages) are
     * not well scoped.  This means that each of the feature enums below can clash
     * with each other.  The short names we've chosen maximize call-site
     * readability, but leave us very open to this scenario.  A future feature will
     * be designed and implemented to handle this, hopefully before we ever hit a
     * conflict here.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.FeatureSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
          com.google.protobuf.DescriptorProtos.FeatureSet, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.FeatureSet)
        com.google.protobuf.DescriptorProtos.FeatureSetOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.FeatureSet.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the fieldPresence field is set.
       */
      @java.lang.Override
      public boolean hasFieldPresence() {
        return instance.hasFieldPresence();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The fieldPresence.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence getFieldPresence() {
        return instance.getFieldPresence();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for fieldPresence to set.
       * @return This builder for chaining.
       */
      public Builder setFieldPresence(com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence value) {
        copyOnWrite();
        instance.setFieldPresence(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearFieldPresence() {
        copyOnWrite();
        instance.clearFieldPresence();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the enumType field is set.
       */
      @java.lang.Override
      public boolean hasEnumType() {
        return instance.hasEnumType();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The enumType.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.EnumType getEnumType() {
        return instance.getEnumType();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for enumType to set.
       * @return This builder for chaining.
       */
      public Builder setEnumType(com.google.protobuf.DescriptorProtos.FeatureSet.EnumType value) {
        copyOnWrite();
        instance.setEnumType(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearEnumType() {
        copyOnWrite();
        instance.clearEnumType();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the repeatedFieldEncoding field is set.
       */
      @java.lang.Override
      public boolean hasRepeatedFieldEncoding() {
        return instance.hasRepeatedFieldEncoding();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The repeatedFieldEncoding.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding getRepeatedFieldEncoding() {
        return instance.getRepeatedFieldEncoding();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for repeatedFieldEncoding to set.
       * @return This builder for chaining.
       */
      public Builder setRepeatedFieldEncoding(com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding value) {
        copyOnWrite();
        instance.setRepeatedFieldEncoding(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearRepeatedFieldEncoding() {
        copyOnWrite();
        instance.clearRepeatedFieldEncoding();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the stringFieldValidation field is set.
       */
      @java.lang.Override
      public boolean hasStringFieldValidation() {
        return instance.hasStringFieldValidation();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The stringFieldValidation.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation getStringFieldValidation() {
        return instance.getStringFieldValidation();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for stringFieldValidation to set.
       * @return This builder for chaining.
       */
      public Builder setStringFieldValidation(com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation value) {
        copyOnWrite();
        instance.setStringFieldValidation(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.StringFieldValidation string_field_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearStringFieldValidation() {
        copyOnWrite();
        instance.clearStringFieldValidation();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the messageEncoding field is set.
       */
      @java.lang.Override
      public boolean hasMessageEncoding() {
        return instance.hasMessageEncoding();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The messageEncoding.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding getMessageEncoding() {
        return instance.getMessageEncoding();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for messageEncoding to set.
       * @return This builder for chaining.
       */
      public Builder setMessageEncoding(com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding value) {
        copyOnWrite();
        instance.setMessageEncoding(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearMessageEncoding() {
        copyOnWrite();
        instance.clearMessageEncoding();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return Whether the jsonFormat field is set.
       */
      @java.lang.Override
      public boolean hasJsonFormat() {
        return instance.hasJsonFormat();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return The jsonFormat.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat getJsonFormat() {
        return instance.getJsonFormat();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @param value The enum numeric value on the wire for jsonFormat to set.
       * @return This builder for chaining.
       */
      public Builder setJsonFormat(com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat value) {
        copyOnWrite();
        instance.setJsonFormat(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = { ... }</code>
       * @return This builder for chaining.
       */
      public Builder clearJsonFormat() {
        copyOnWrite();
        instance.clearJsonFormat();
        return this;
      }

      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      @java.lang.Override
      public boolean hasRawFeatures() {
        return instance.hasRawFeatures();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.FeatureSet getRawFeatures() {
        return instance.getRawFeatures();
      }
      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      public Builder setRawFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.setRawFeatures(value);
        return this;
        }
      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      public Builder setRawFeatures(
          com.google.protobuf.DescriptorProtos.FeatureSet.Builder builderForValue) {
        copyOnWrite();
        instance.setRawFeatures(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      public Builder mergeRawFeatures(com.google.protobuf.DescriptorProtos.FeatureSet value) {
        copyOnWrite();
        instance.mergeRawFeatures(value);
        return this;
      }
      /**
       * <code>optional .google.protobuf.FeatureSet raw_features = 999 [targets = TARGET_TYPE_UNKNOWN];</code>
       */
      public Builder clearRawFeatures() {  copyOnWrite();
        instance.clearRawFeatures();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.FeatureSet)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.FeatureSet();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "fieldPresence_",
              com.google.protobuf.DescriptorProtos.FeatureSet.FieldPresence.internalGetVerifier(),
              "enumType_",
              com.google.protobuf.DescriptorProtos.FeatureSet.EnumType.internalGetVerifier(),
              "repeatedFieldEncoding_",
              com.google.protobuf.DescriptorProtos.FeatureSet.RepeatedFieldEncoding.internalGetVerifier(),
              "stringFieldValidation_",
              com.google.protobuf.DescriptorProtos.FeatureSet.StringFieldValidation.internalGetVerifier(),
              "messageEncoding_",
              com.google.protobuf.DescriptorProtos.FeatureSet.MessageEncoding.internalGetVerifier(),
              "jsonFormat_",
              com.google.protobuf.DescriptorProtos.FeatureSet.JsonFormat.internalGetVerifier(),
              "rawFeatures_",
            };
            java.lang.String info =
                "\u0001\u0007\u0000\u0001\u0001\u03e7\u0007\u0000\u0000\u0001\u0001\u100c\u0000\u0002" +
                "\u100c\u0001\u0003\u100c\u0002\u0004\u100c\u0003\u0005\u100c\u0004\u0006\u100c\u0005" +
                "\u03e7\u1409\u0006";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.FeatureSet> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.FeatureSet.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.FeatureSet>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.FeatureSet)
    private static final com.google.protobuf.DescriptorProtos.FeatureSet DEFAULT_INSTANCE;
    static {
      FeatureSet defaultInstance = new FeatureSet();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        FeatureSet.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.FeatureSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeatureSet> PARSER;

    public static com.google.protobuf.Parser<FeatureSet> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SourceCodeInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.SourceCodeInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> 
        getLocationList();
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location getLocation(int index);
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    int getLocationCount();
  }
  /**
   * <pre>
   * Encapsulates information about the original source file from which a
   * FileDescriptorProto was generated.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.SourceCodeInfo}
   */
  public  static final class SourceCodeInfo extends
      com.google.protobuf.GeneratedMessageLite<
          SourceCodeInfo, SourceCodeInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.SourceCodeInfo)
      SourceCodeInfoOrBuilder {
    private SourceCodeInfo() {
      location_ = emptyProtobufList();
    }
    public interface LocationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.SourceCodeInfo.Location)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return A list containing the path.
       */
      java.util.List<java.lang.Integer> getPathList();
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return The count of path.
       */
      int getPathCount();
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The path at the given index.
       */
      int getPath(int index);

      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @return A list containing the span.
       */
      java.util.List<java.lang.Integer> getSpanList();
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @return The count of span.
       */
      int getSpanCount();
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The span at the given index.
       */
      int getSpan(int index);

      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return Whether the leadingComments field is set.
       */
      boolean hasLeadingComments();
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return The leadingComments.
       */
      java.lang.String getLeadingComments();
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return The bytes for leadingComments.
       */
      com.google.protobuf.ByteString
          getLeadingCommentsBytes();

      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return Whether the trailingComments field is set.
       */
      boolean hasTrailingComments();
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return The trailingComments.
       */
      java.lang.String getTrailingComments();
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return The bytes for trailingComments.
       */
      com.google.protobuf.ByteString
          getTrailingCommentsBytes();

      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @return A list containing the leadingDetachedComments.
       */
      java.util.List<java.lang.String>
          getLeadingDetachedCommentsList();
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @return The count of leadingDetachedComments.
       */
      int getLeadingDetachedCommentsCount();
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index of the element to return.
       * @return The leadingDetachedComments at the given index.
       */
      java.lang.String getLeadingDetachedComments(int index);
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index of the element to return.
       * @return The leadingDetachedComments at the given index.
       */
      com.google.protobuf.ByteString
          getLeadingDetachedCommentsBytes(int index);
    }
    /**
     * Protobuf type {@code google.protobuf.SourceCodeInfo.Location}
     */
    public  static final class Location extends
        com.google.protobuf.GeneratedMessageLite<
            Location, Location.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.SourceCodeInfo.Location)
        LocationOrBuilder {
      private Location() {
        path_ = emptyIntList();
        span_ = emptyIntList();
        leadingComments_ = "";
        trailingComments_ = "";
        leadingDetachedComments_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      }
      private int bitField0_;
      public static final int PATH_FIELD_NUMBER = 1;
      private com.google.protobuf.Internal.IntList path_;
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return A list containing the path.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getPathList() {
        return path_;
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return The count of path.
       */
      @java.lang.Override
      public int getPathCount() {
        return path_.size();
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The path at the given index.
       */
      @java.lang.Override
      public int getPath(int index) {
        return path_.getInt(index);
      }
      private int pathMemoizedSerializedSize = -1;
      private void ensurePathIsMutable() {
        com.google.protobuf.Internal.IntList tmp = path_;
        if (!tmp.isModifiable()) {
          path_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The path to set.
       */
      private void setPath(
          int index, int value) {
        ensurePathIsMutable();
        path_.setInt(index, value);
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param value The path to add.
       */
      private void addPath(int value) {
        ensurePathIsMutable();
        path_.addInt(value);
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param values The path to add.
       */
      private void addAllPath(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensurePathIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, path_);
      }
      /**
       * <pre>
       * Identifies which part of the FileDescriptorProto was defined at this
       * location.
       * Each element is a field number or an index.  They form a path from
       * the root FileDescriptorProto to the place where the definition occurs.
       * For example, this path:
       *   [ 4, 3, 2, 7, 1 ]
       * refers to:
       *   file.message_type(3)  // 4, 3
       *       .field(7)         // 2, 7
       *       .name()           // 1
       * This is because FileDescriptorProto.message_type has field number 4:
       *   repeated DescriptorProto message_type = 4;
       * and DescriptorProto.field has field number 2:
       *   repeated FieldDescriptorProto field = 2;
       * and FieldDescriptorProto.name has field number 1:
       *   optional string name = 1;
       * Thus, the above path gives the location of a field name.  If we removed
       * the last element:
       *   [ 4, 3, 2, 7 ]
       * this path refers to the whole field declaration (from the beginning
       * of the label to the terminating semicolon).
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       */
      private void clearPath() {
        path_ = emptyIntList();
      }

      public static final int SPAN_FIELD_NUMBER = 2;
      private com.google.protobuf.Internal.IntList span_;
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @return A list containing the span.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getSpanList() {
        return span_;
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @return The count of span.
       */
      @java.lang.Override
      public int getSpanCount() {
        return span_.size();
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The span at the given index.
       */
      @java.lang.Override
      public int getSpan(int index) {
        return span_.getInt(index);
      }
      private int spanMemoizedSerializedSize = -1;
      private void ensureSpanIsMutable() {
        com.google.protobuf.Internal.IntList tmp = span_;
        if (!tmp.isModifiable()) {
          span_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The span to set.
       */
      private void setSpan(
          int index, int value) {
        ensureSpanIsMutable();
        span_.setInt(index, value);
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param value The span to add.
       */
      private void addSpan(int value) {
        ensureSpanIsMutable();
        span_.addInt(value);
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       * @param values The span to add.
       */
      private void addAllSpan(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureSpanIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, span_);
      }
      /**
       * <pre>
       * Always has exactly three or four elements: start line, start column,
       * end line (optional, otherwise assumed same as start line), end column.
       * These are packed into a single field for efficiency.  Note that line
       * and column numbers are zero-based -- typically you will want to add
       * 1 to each before displaying to a user.
       * </pre>
       *
       * <code>repeated int32 span = 2 [packed = true];</code>
       */
      private void clearSpan() {
        span_ = emptyIntList();
      }

      public static final int LEADING_COMMENTS_FIELD_NUMBER = 3;
      private java.lang.String leadingComments_;
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return Whether the leadingComments field is set.
       */
      @java.lang.Override
      public boolean hasLeadingComments() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return The leadingComments.
       */
      @java.lang.Override
      public java.lang.String getLeadingComments() {
        return leadingComments_;
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @return The bytes for leadingComments.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLeadingCommentsBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(leadingComments_);
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @param value The leadingComments to set.
       */
      private void setLeadingComments(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        leadingComments_ = value;
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       */
      private void clearLeadingComments() {
        bitField0_ = (bitField0_ & ~0x00000001);
        leadingComments_ = getDefaultInstance().getLeadingComments();
      }
      /**
       * <pre>
       * If this SourceCodeInfo represents a complete declaration, these are any
       * comments appearing before and after the declaration which appear to be
       * attached to the declaration.
       * A series of line comments appearing on consecutive lines, with no other
       * tokens appearing on those lines, will be treated as a single comment.
       * leading_detached_comments will keep paragraphs of comments that appear
       * before (but not connected to) the current element. Each paragraph,
       * separated by empty lines, will be one comment element in the repeated
       * field.
       * Only the comment content is provided; comment markers (e.g. //) are
       * stripped out.  For block comments, leading whitespace and an asterisk
       * will be stripped from the beginning of each line other than the first.
       * Newlines are included in the output.
       * Examples:
       *   optional int32 foo = 1;  // Comment attached to foo.
       *   // Comment attached to bar.
       *   optional int32 bar = 2;
       *   optional string baz = 3;
       *   // Comment attached to baz.
       *   // Another line attached to baz.
       *   // Comment attached to moo.
       *   //
       *   // Another line attached to moo.
       *   optional double moo = 4;
       *   // Detached comment for corge. This is not leading or trailing comments
       *   // to moo or corge because there are blank lines separating it from
       *   // both.
       *   // Detached comment for corge paragraph 2.
       *   optional string corge = 5;
       *   /&#42; Block comment attached
       *    * to corge.  Leading asterisks
       *    * will be removed. *&#47;
       *   /&#42; Block comment attached to
       *    * grault. *&#47;
       *   optional int32 grault = 6;
       *   // ignored detached comments.
       * </pre>
       *
       * <code>optional string leading_comments = 3;</code>
       * @param value The bytes for leadingComments to set.
       */
      private void setLeadingCommentsBytes(
          com.google.protobuf.ByteString value) {
        leadingComments_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int TRAILING_COMMENTS_FIELD_NUMBER = 4;
      private java.lang.String trailingComments_;
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return Whether the trailingComments field is set.
       */
      @java.lang.Override
      public boolean hasTrailingComments() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return The trailingComments.
       */
      @java.lang.Override
      public java.lang.String getTrailingComments() {
        return trailingComments_;
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @return The bytes for trailingComments.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTrailingCommentsBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(trailingComments_);
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @param value The trailingComments to set.
       */
      private void setTrailingComments(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
        trailingComments_ = value;
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       */
      private void clearTrailingComments() {
        bitField0_ = (bitField0_ & ~0x00000002);
        trailingComments_ = getDefaultInstance().getTrailingComments();
      }
      /**
       * <code>optional string trailing_comments = 4;</code>
       * @param value The bytes for trailingComments to set.
       */
      private void setTrailingCommentsBytes(
          com.google.protobuf.ByteString value) {
        trailingComments_ = value.toStringUtf8();
        bitField0_ |= 0x00000002;
      }

      public static final int LEADING_DETACHED_COMMENTS_FIELD_NUMBER = 6;
      private com.google.protobuf.Internal.ProtobufList<java.lang.String> leadingDetachedComments_;
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @return A list containing the leadingDetachedComments.
       */
      @java.lang.Override
      public java.util.List<java.lang.String> getLeadingDetachedCommentsList() {
        return leadingDetachedComments_;
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @return The count of leadingDetachedComments.
       */
      @java.lang.Override
      public int getLeadingDetachedCommentsCount() {
        return leadingDetachedComments_.size();
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index of the element to return.
       * @return The leadingDetachedComments at the given index.
       */
      @java.lang.Override
      public java.lang.String getLeadingDetachedComments(int index) {
        return leadingDetachedComments_.get(index);
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index of the value to return.
       * @return The bytes of the leadingDetachedComments at the given index.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getLeadingDetachedCommentsBytes(int index) {
        return com.google.protobuf.ByteString.copyFromUtf8(
            leadingDetachedComments_.get(index));
      }
      private void ensureLeadingDetachedCommentsIsMutable() {
        com.google.protobuf.Internal.ProtobufList<java.lang.String> tmp =
            leadingDetachedComments_;  if (!tmp.isModifiable()) {
          leadingDetachedComments_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param index The index to set the value at.
       * @param value The leadingDetachedComments to set.
       */
      private void setLeadingDetachedComments(
          int index, java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  ensureLeadingDetachedCommentsIsMutable();
        leadingDetachedComments_.set(index, value);
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param value The leadingDetachedComments to add.
       */
      private void addLeadingDetachedComments(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  ensureLeadingDetachedCommentsIsMutable();
        leadingDetachedComments_.add(value);
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param values The leadingDetachedComments to add.
       */
      private void addAllLeadingDetachedComments(
          java.lang.Iterable<java.lang.String> values) {
        ensureLeadingDetachedCommentsIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, leadingDetachedComments_);
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       */
      private void clearLeadingDetachedComments() {
        leadingDetachedComments_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
      }
      /**
       * <code>repeated string leading_detached_comments = 6;</code>
       * @param value The bytes of the leadingDetachedComments to add.
       */
      private void addLeadingDetachedCommentsBytes(
          com.google.protobuf.ByteString value) {
        ensureLeadingDetachedCommentsIsMutable();
        leadingDetachedComments_.add(value.toStringUtf8());
      }

      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code google.protobuf.SourceCodeInfo.Location}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.SourceCodeInfo.Location)
          com.google.protobuf.DescriptorProtos.SourceCodeInfo.LocationOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return A list containing the path.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getPathList() {
          return java.util.Collections.unmodifiableList(
              instance.getPathList());
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return The count of path.
         */
        @java.lang.Override
        public int getPathCount() {
          return instance.getPathCount();
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The path at the given index.
         */
        @java.lang.Override
        public int getPath(int index) {
          return instance.getPath(index);
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param value The path to set.
         * @return This builder for chaining.
         */
        public Builder setPath(
            int index, int value) {
          copyOnWrite();
          instance.setPath(index, value);
          return this;
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param value The path to add.
         * @return This builder for chaining.
         */
        public Builder addPath(int value) {
          copyOnWrite();
          instance.addPath(value);
          return this;
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param values The path to add.
         * @return This builder for chaining.
         */
        public Builder addAllPath(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllPath(values);
          return this;
        }
        /**
         * <pre>
         * Identifies which part of the FileDescriptorProto was defined at this
         * location.
         * Each element is a field number or an index.  They form a path from
         * the root FileDescriptorProto to the place where the definition occurs.
         * For example, this path:
         *   [ 4, 3, 2, 7, 1 ]
         * refers to:
         *   file.message_type(3)  // 4, 3
         *       .field(7)         // 2, 7
         *       .name()           // 1
         * This is because FileDescriptorProto.message_type has field number 4:
         *   repeated DescriptorProto message_type = 4;
         * and DescriptorProto.field has field number 2:
         *   repeated FieldDescriptorProto field = 2;
         * and FieldDescriptorProto.name has field number 1:
         *   optional string name = 1;
         * Thus, the above path gives the location of a field name.  If we removed
         * the last element:
         *   [ 4, 3, 2, 7 ]
         * this path refers to the whole field declaration (from the beginning
         * of the label to the terminating semicolon).
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearPath() {
          copyOnWrite();
          instance.clearPath();
          return this;
        }

        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @return A list containing the span.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getSpanList() {
          return java.util.Collections.unmodifiableList(
              instance.getSpanList());
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @return The count of span.
         */
        @java.lang.Override
        public int getSpanCount() {
          return instance.getSpanCount();
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The span at the given index.
         */
        @java.lang.Override
        public int getSpan(int index) {
          return instance.getSpan(index);
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @param value The span to set.
         * @return This builder for chaining.
         */
        public Builder setSpan(
            int index, int value) {
          copyOnWrite();
          instance.setSpan(index, value);
          return this;
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @param value The span to add.
         * @return This builder for chaining.
         */
        public Builder addSpan(int value) {
          copyOnWrite();
          instance.addSpan(value);
          return this;
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @param values The span to add.
         * @return This builder for chaining.
         */
        public Builder addAllSpan(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllSpan(values);
          return this;
        }
        /**
         * <pre>
         * Always has exactly three or four elements: start line, start column,
         * end line (optional, otherwise assumed same as start line), end column.
         * These are packed into a single field for efficiency.  Note that line
         * and column numbers are zero-based -- typically you will want to add
         * 1 to each before displaying to a user.
         * </pre>
         *
         * <code>repeated int32 span = 2 [packed = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearSpan() {
          copyOnWrite();
          instance.clearSpan();
          return this;
        }

        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @return Whether the leadingComments field is set.
         */
        @java.lang.Override
        public boolean hasLeadingComments() {
          return instance.hasLeadingComments();
        }
        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @return The leadingComments.
         */
        @java.lang.Override
        public java.lang.String getLeadingComments() {
          return instance.getLeadingComments();
        }
        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @return The bytes for leadingComments.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getLeadingCommentsBytes() {
          return instance.getLeadingCommentsBytes();
        }
        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @param value The leadingComments to set.
         * @return This builder for chaining.
         */
        public Builder setLeadingComments(
            java.lang.String value) {
          copyOnWrite();
          instance.setLeadingComments(value);
          return this;
        }
        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearLeadingComments() {
          copyOnWrite();
          instance.clearLeadingComments();
          return this;
        }
        /**
         * <pre>
         * If this SourceCodeInfo represents a complete declaration, these are any
         * comments appearing before and after the declaration which appear to be
         * attached to the declaration.
         * A series of line comments appearing on consecutive lines, with no other
         * tokens appearing on those lines, will be treated as a single comment.
         * leading_detached_comments will keep paragraphs of comments that appear
         * before (but not connected to) the current element. Each paragraph,
         * separated by empty lines, will be one comment element in the repeated
         * field.
         * Only the comment content is provided; comment markers (e.g. //) are
         * stripped out.  For block comments, leading whitespace and an asterisk
         * will be stripped from the beginning of each line other than the first.
         * Newlines are included in the output.
         * Examples:
         *   optional int32 foo = 1;  // Comment attached to foo.
         *   // Comment attached to bar.
         *   optional int32 bar = 2;
         *   optional string baz = 3;
         *   // Comment attached to baz.
         *   // Another line attached to baz.
         *   // Comment attached to moo.
         *   //
         *   // Another line attached to moo.
         *   optional double moo = 4;
         *   // Detached comment for corge. This is not leading or trailing comments
         *   // to moo or corge because there are blank lines separating it from
         *   // both.
         *   // Detached comment for corge paragraph 2.
         *   optional string corge = 5;
         *   /&#42; Block comment attached
         *    * to corge.  Leading asterisks
         *    * will be removed. *&#47;
         *   /&#42; Block comment attached to
         *    * grault. *&#47;
         *   optional int32 grault = 6;
         *   // ignored detached comments.
         * </pre>
         *
         * <code>optional string leading_comments = 3;</code>
         * @param value The bytes for leadingComments to set.
         * @return This builder for chaining.
         */
        public Builder setLeadingCommentsBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setLeadingCommentsBytes(value);
          return this;
        }

        /**
         * <code>optional string trailing_comments = 4;</code>
         * @return Whether the trailingComments field is set.
         */
        @java.lang.Override
        public boolean hasTrailingComments() {
          return instance.hasTrailingComments();
        }
        /**
         * <code>optional string trailing_comments = 4;</code>
         * @return The trailingComments.
         */
        @java.lang.Override
        public java.lang.String getTrailingComments() {
          return instance.getTrailingComments();
        }
        /**
         * <code>optional string trailing_comments = 4;</code>
         * @return The bytes for trailingComments.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getTrailingCommentsBytes() {
          return instance.getTrailingCommentsBytes();
        }
        /**
         * <code>optional string trailing_comments = 4;</code>
         * @param value The trailingComments to set.
         * @return This builder for chaining.
         */
        public Builder setTrailingComments(
            java.lang.String value) {
          copyOnWrite();
          instance.setTrailingComments(value);
          return this;
        }
        /**
         * <code>optional string trailing_comments = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearTrailingComments() {
          copyOnWrite();
          instance.clearTrailingComments();
          return this;
        }
        /**
         * <code>optional string trailing_comments = 4;</code>
         * @param value The bytes for trailingComments to set.
         * @return This builder for chaining.
         */
        public Builder setTrailingCommentsBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setTrailingCommentsBytes(value);
          return this;
        }

        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @return A list containing the leadingDetachedComments.
         */
        @java.lang.Override
        public java.util.List<java.lang.String>
            getLeadingDetachedCommentsList() {
          return java.util.Collections.unmodifiableList(
              instance.getLeadingDetachedCommentsList());
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @return The count of leadingDetachedComments.
         */
        @java.lang.Override
        public int getLeadingDetachedCommentsCount() {
          return instance.getLeadingDetachedCommentsCount();
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param index The index of the element to return.
         * @return The leadingDetachedComments at the given index.
         */
        @java.lang.Override
        public java.lang.String getLeadingDetachedComments(int index) {
          return instance.getLeadingDetachedComments(index);
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param index The index of the value to return.
         * @return The bytes of the leadingDetachedComments at the given index.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getLeadingDetachedCommentsBytes(int index) {
          return instance.getLeadingDetachedCommentsBytes(index);
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param index The index to set the value at.
         * @param value The leadingDetachedComments to set.
         * @return This builder for chaining.
         */
        public Builder setLeadingDetachedComments(
            int index, java.lang.String value) {
          copyOnWrite();
          instance.setLeadingDetachedComments(index, value);
          return this;
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param value The leadingDetachedComments to add.
         * @return This builder for chaining.
         */
        public Builder addLeadingDetachedComments(
            java.lang.String value) {
          copyOnWrite();
          instance.addLeadingDetachedComments(value);
          return this;
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param values The leadingDetachedComments to add.
         * @return This builder for chaining.
         */
        public Builder addAllLeadingDetachedComments(
            java.lang.Iterable<java.lang.String> values) {
          copyOnWrite();
          instance.addAllLeadingDetachedComments(values);
          return this;
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearLeadingDetachedComments() {
          copyOnWrite();
          instance.clearLeadingDetachedComments();
          return this;
        }
        /**
         * <code>repeated string leading_detached_comments = 6;</code>
         * @param value The bytes of the leadingDetachedComments to add.
         * @return This builder for chaining.
         */
        public Builder addLeadingDetachedCommentsBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.addLeadingDetachedCommentsBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.SourceCodeInfo.Location)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "path_",
                "span_",
                "leadingComments_",
                "trailingComments_",
                "leadingDetachedComments_",
              };
              java.lang.String info =
                  "\u0001\u0005\u0000\u0001\u0001\u0006\u0005\u0000\u0003\u0000\u0001\'\u0002\'\u0003" +
                  "\u1008\u0000\u0004\u1008\u0001\u0006\u001a";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.SourceCodeInfo.Location)
      private static final com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location DEFAULT_INSTANCE;
      static {
        Location defaultInstance = new Location();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Location.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Location> PARSER;

      public static com.google.protobuf.Parser<Location> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int LOCATION_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> location_;
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> getLocationList() {
      return location_;
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.SourceCodeInfo.LocationOrBuilder> 
        getLocationOrBuilderList() {
      return location_;
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    @java.lang.Override
    public int getLocationCount() {
      return location_.size();
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location getLocation(int index) {
      return location_.get(index);
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    public com.google.protobuf.DescriptorProtos.SourceCodeInfo.LocationOrBuilder getLocationOrBuilder(
        int index) {
      return location_.get(index);
    }
    private void ensureLocationIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> tmp = location_;
      if (!tmp.isModifiable()) {
        location_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void setLocation(
        int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
      value.getClass();
  ensureLocationIsMutable();
      location_.set(index, value);
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void addLocation(com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
      value.getClass();
  ensureLocationIsMutable();
      location_.add(value);
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void addLocation(
        int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
      value.getClass();
  ensureLocationIsMutable();
      location_.add(index, value);
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void addAllLocation(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> values) {
      ensureLocationIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, location_);
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void clearLocation() {
      location_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A Location identifies a piece of source code in a .proto file which
     * corresponds to a particular definition.  This information is intended
     * to be useful to IDEs, code indexers, documentation generators, and similar
     * tools.
     * For example, say we have a file like:
     *   message Foo {
     *     optional string foo = 1;
     *   }
     * Let's look at just the field definition:
     *   optional string foo = 1;
     *   ^       ^^     ^^  ^  ^^^
     *   a       bc     de  f  ghi
     * We have the following locations:
     *   span   path               represents
     *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
     *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
     *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
     *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
     *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
     * Notes:
     * - A location may refer to a repeated field itself (i.e. not to any
     *   particular index within it).  This is used whenever a set of elements are
     *   logically enclosed in a single code segment.  For example, an entire
     *   extend block (possibly containing multiple extension definitions) will
     *   have an outer location whose path refers to the "extensions" repeated
     *   field without an index.
     * - Multiple locations may have the same path.  This happens when a single
     *   logical declaration is spread out across multiple places.  The most
     *   obvious example is the "extend" block again -- there may be multiple
     *   extend blocks in the same scope, each of which will have the same path.
     * - A location's span is not always a subset of its parent's span.  For
     *   example, the "extendee" of an extension declaration appears at the
     *   beginning of the "extend" block and is shared by all extensions within
     *   the block.
     * - Just because a location's span is a subset of some other location's span
     *   does not mean that it is a descendant.  For example, a "group" defines
     *   both a type and a field in a single declaration.  Thus, the locations
     *   corresponding to the type and field and their components will overlap.
     * - Code which tries to interpret locations should probably be designed to
     *   ignore those that it doesn't understand, as more types of locations could
     *   be recorded in the future.
     * </pre>
     *
     * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
     */
    private void removeLocation(int index) {
      ensureLocationIsMutable();
      location_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.SourceCodeInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Encapsulates information about the original source file from which a
     * FileDescriptorProto was generated.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.SourceCodeInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.SourceCodeInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.SourceCodeInfo)
        com.google.protobuf.DescriptorProtos.SourceCodeInfoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.SourceCodeInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> getLocationList() {
        return java.util.Collections.unmodifiableList(
            instance.getLocationList());
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      @java.lang.Override
      public int getLocationCount() {
        return instance.getLocationCount();
      }/**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location getLocation(int index) {
        return instance.getLocation(index);
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder setLocation(
          int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
        copyOnWrite();
        instance.setLocation(index, value);
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder setLocation(
          int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.Builder builderForValue) {
        copyOnWrite();
        instance.setLocation(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder addLocation(com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
        copyOnWrite();
        instance.addLocation(value);
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder addLocation(
          int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location value) {
        copyOnWrite();
        instance.addLocation(index, value);
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder addLocation(
          com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.Builder builderForValue) {
        copyOnWrite();
        instance.addLocation(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder addLocation(
          int index, com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.Builder builderForValue) {
        copyOnWrite();
        instance.addLocation(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder addAllLocation(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location> values) {
        copyOnWrite();
        instance.addAllLocation(values);
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder clearLocation() {
        copyOnWrite();
        instance.clearLocation();
        return this;
      }
      /**
       * <pre>
       * A Location identifies a piece of source code in a .proto file which
       * corresponds to a particular definition.  This information is intended
       * to be useful to IDEs, code indexers, documentation generators, and similar
       * tools.
       * For example, say we have a file like:
       *   message Foo {
       *     optional string foo = 1;
       *   }
       * Let's look at just the field definition:
       *   optional string foo = 1;
       *   ^       ^^     ^^  ^  ^^^
       *   a       bc     de  f  ghi
       * We have the following locations:
       *   span   path               represents
       *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
       *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
       *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
       *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
       *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
       * Notes:
       * - A location may refer to a repeated field itself (i.e. not to any
       *   particular index within it).  This is used whenever a set of elements are
       *   logically enclosed in a single code segment.  For example, an entire
       *   extend block (possibly containing multiple extension definitions) will
       *   have an outer location whose path refers to the "extensions" repeated
       *   field without an index.
       * - Multiple locations may have the same path.  This happens when a single
       *   logical declaration is spread out across multiple places.  The most
       *   obvious example is the "extend" block again -- there may be multiple
       *   extend blocks in the same scope, each of which will have the same path.
       * - A location's span is not always a subset of its parent's span.  For
       *   example, the "extendee" of an extension declaration appears at the
       *   beginning of the "extend" block and is shared by all extensions within
       *   the block.
       * - Just because a location's span is a subset of some other location's span
       *   does not mean that it is a descendant.  For example, a "group" defines
       *   both a type and a field in a single declaration.  Thus, the locations
       *   corresponding to the type and field and their components will overlap.
       * - Code which tries to interpret locations should probably be designed to
       *   ignore those that it doesn't understand, as more types of locations could
       *   be recorded in the future.
       * </pre>
       *
       * <code>repeated .google.protobuf.SourceCodeInfo.Location location = 1;</code>
       */
      public Builder removeLocation(int index) {
        copyOnWrite();
        instance.removeLocation(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.SourceCodeInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.SourceCodeInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "location_",
              com.google.protobuf.DescriptorProtos.SourceCodeInfo.Location.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.SourceCodeInfo> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.SourceCodeInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.SourceCodeInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.SourceCodeInfo)
    private static final com.google.protobuf.DescriptorProtos.SourceCodeInfo DEFAULT_INSTANCE;
    static {
      SourceCodeInfo defaultInstance = new SourceCodeInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SourceCodeInfo.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.SourceCodeInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SourceCodeInfo> PARSER;

    public static com.google.protobuf.Parser<SourceCodeInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface GeneratedCodeInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.protobuf.GeneratedCodeInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    java.util.List<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> 
        getAnnotationList();
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation getAnnotation(int index);
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    int getAnnotationCount();
  }
  /**
   * <pre>
   * Describes the relationship between generated code and its original source
   * file. A GeneratedCodeInfo message is associated with only one generated
   * source file, but may contain references to different source .proto files.
   * </pre>
   *
   * Protobuf type {@code google.protobuf.GeneratedCodeInfo}
   */
  public  static final class GeneratedCodeInfo extends
      com.google.protobuf.GeneratedMessageLite<
          GeneratedCodeInfo, GeneratedCodeInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:google.protobuf.GeneratedCodeInfo)
      GeneratedCodeInfoOrBuilder {
    private GeneratedCodeInfo() {
      annotation_ = emptyProtobufList();
    }
    public interface AnnotationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:google.protobuf.GeneratedCodeInfo.Annotation)
        com.google.protobuf.MessageLiteOrBuilder {

      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return A list containing the path.
       */
      java.util.List<java.lang.Integer> getPathList();
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return The count of path.
       */
      int getPathCount();
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The path at the given index.
       */
      int getPath(int index);

      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return Whether the sourceFile field is set.
       */
      boolean hasSourceFile();
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return The sourceFile.
       */
      java.lang.String getSourceFile();
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return The bytes for sourceFile.
       */
      com.google.protobuf.ByteString
          getSourceFileBytes();

      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       * @return Whether the begin field is set.
       */
      boolean hasBegin();
      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       * @return The begin.
       */
      int getBegin();

      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       * @return Whether the end field is set.
       */
      boolean hasEnd();
      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       * @return The end.
       */
      int getEnd();

      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       * @return Whether the semantic field is set.
       */
      boolean hasSemantic();
      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       * @return The semantic.
       */
      com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic getSemantic();
    }
    /**
     * Protobuf type {@code google.protobuf.GeneratedCodeInfo.Annotation}
     */
    public  static final class Annotation extends
        com.google.protobuf.GeneratedMessageLite<
            Annotation, Annotation.Builder> implements
        // @@protoc_insertion_point(message_implements:google.protobuf.GeneratedCodeInfo.Annotation)
        AnnotationOrBuilder {
      private Annotation() {
        path_ = emptyIntList();
        sourceFile_ = "";
      }
      /**
       * <pre>
       * Represents the identified object's effect on the element in the original
       * .proto file.
       * </pre>
       *
       * Protobuf enum {@code google.protobuf.GeneratedCodeInfo.Annotation.Semantic}
       */
      public enum Semantic
          implements com.google.protobuf.Internal.EnumLite {
        /**
         * <pre>
         * There is no effect or the effect is indescribable.
         * </pre>
         *
         * <code>NONE = 0;</code>
         */
        NONE(0),
        /**
         * <pre>
         * The element is set or otherwise mutated.
         * </pre>
         *
         * <code>SET = 1;</code>
         */
        SET(1),
        /**
         * <pre>
         * An alias to the element is returned.
         * </pre>
         *
         * <code>ALIAS = 2;</code>
         */
        ALIAS(2),
        ;

        /**
         * <pre>
         * There is no effect or the effect is indescribable.
         * </pre>
         *
         * <code>NONE = 0;</code>
         */
        public static final int NONE_VALUE = 0;
        /**
         * <pre>
         * The element is set or otherwise mutated.
         * </pre>
         *
         * <code>SET = 1;</code>
         */
        public static final int SET_VALUE = 1;
        /**
         * <pre>
         * An alias to the element is returned.
         * </pre>
         *
         * <code>ALIAS = 2;</code>
         */
        public static final int ALIAS_VALUE = 2;


        @java.lang.Override
        public final int getNumber() {
          return value;
        }

        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Semantic valueOf(int value) {
          return forNumber(value);
        }

        public static Semantic forNumber(int value) {
          switch (value) {
            case 0: return NONE;
            case 1: return SET;
            case 2: return ALIAS;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Semantic>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Semantic> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Semantic>() {
                @java.lang.Override
                public Semantic findValueByNumber(int number) {
                  return Semantic.forNumber(number);
                }
              };

        public static com.google.protobuf.Internal.EnumVerifier 
            internalGetVerifier() {
          return SemanticVerifier.INSTANCE;
        }

        private static final class SemanticVerifier implements 
             com.google.protobuf.Internal.EnumVerifier { 
                static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new SemanticVerifier();
                @java.lang.Override
                public boolean isInRange(int number) {
                  return Semantic.forNumber(number) != null;
                }
              };

        private final int value;

        private Semantic(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:google.protobuf.GeneratedCodeInfo.Annotation.Semantic)
      }

      private int bitField0_;
      public static final int PATH_FIELD_NUMBER = 1;
      private com.google.protobuf.Internal.IntList path_;
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return A list containing the path.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getPathList() {
        return path_;
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @return The count of path.
       */
      @java.lang.Override
      public int getPathCount() {
        return path_.size();
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The path at the given index.
       */
      @java.lang.Override
      public int getPath(int index) {
        return path_.getInt(index);
      }
      private int pathMemoizedSerializedSize = -1;
      private void ensurePathIsMutable() {
        com.google.protobuf.Internal.IntList tmp = path_;
        if (!tmp.isModifiable()) {
          path_ =
              com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
         }
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The path to set.
       */
      private void setPath(
          int index, int value) {
        ensurePathIsMutable();
        path_.setInt(index, value);
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param value The path to add.
       */
      private void addPath(int value) {
        ensurePathIsMutable();
        path_.addInt(value);
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       * @param values The path to add.
       */
      private void addAllPath(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensurePathIsMutable();
        com.google.protobuf.AbstractMessageLite.addAll(
            values, path_);
      }
      /**
       * <pre>
       * Identifies the element in the original source .proto file. This field
       * is formatted the same as SourceCodeInfo.Location.path.
       * </pre>
       *
       * <code>repeated int32 path = 1 [packed = true];</code>
       */
      private void clearPath() {
        path_ = emptyIntList();
      }

      public static final int SOURCE_FILE_FIELD_NUMBER = 2;
      private java.lang.String sourceFile_;
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return Whether the sourceFile field is set.
       */
      @java.lang.Override
      public boolean hasSourceFile() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return The sourceFile.
       */
      @java.lang.Override
      public java.lang.String getSourceFile() {
        return sourceFile_;
      }
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @return The bytes for sourceFile.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getSourceFileBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(sourceFile_);
      }
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @param value The sourceFile to set.
       */
      private void setSourceFile(
          java.lang.String value) {
        java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
        sourceFile_ = value;
      }
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       */
      private void clearSourceFile() {
        bitField0_ = (bitField0_ & ~0x00000001);
        sourceFile_ = getDefaultInstance().getSourceFile();
      }
      /**
       * <pre>
       * Identifies the filesystem path to the original source .proto.
       * </pre>
       *
       * <code>optional string source_file = 2;</code>
       * @param value The bytes for sourceFile to set.
       */
      private void setSourceFileBytes(
          com.google.protobuf.ByteString value) {
        sourceFile_ = value.toStringUtf8();
        bitField0_ |= 0x00000001;
      }

      public static final int BEGIN_FIELD_NUMBER = 3;
      private int begin_;
      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       * @return Whether the begin field is set.
       */
      @java.lang.Override
      public boolean hasBegin() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       * @return The begin.
       */
      @java.lang.Override
      public int getBegin() {
        return begin_;
      }
      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       * @param value The begin to set.
       */
      private void setBegin(int value) {
        bitField0_ |= 0x00000002;
        begin_ = value;
      }
      /**
       * <pre>
       * Identifies the starting offset in bytes in the generated code
       * that relates to the identified object.
       * </pre>
       *
       * <code>optional int32 begin = 3;</code>
       */
      private void clearBegin() {
        bitField0_ = (bitField0_ & ~0x00000002);
        begin_ = 0;
      }

      public static final int END_FIELD_NUMBER = 4;
      private int end_;
      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       * @return The end.
       */
      @java.lang.Override
      public int getEnd() {
        return end_;
      }
      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       * @param value The end to set.
       */
      private void setEnd(int value) {
        bitField0_ |= 0x00000004;
        end_ = value;
      }
      /**
       * <pre>
       * Identifies the ending offset in bytes in the generated code that
       * relates to the identified object. The end offset should be one past
       * the last relevant byte (so the length of the text = end - begin).
       * </pre>
       *
       * <code>optional int32 end = 4;</code>
       */
      private void clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000004);
        end_ = 0;
      }

      public static final int SEMANTIC_FIELD_NUMBER = 5;
      private int semantic_;
      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       * @return Whether the semantic field is set.
       */
      @java.lang.Override
      public boolean hasSemantic() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       * @return The semantic.
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic getSemantic() {
        com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic result = com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic.forNumber(semantic_);
        return result == null ? com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic.NONE : result;
      }
      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       * @param value The semantic to set.
       */
      private void setSemantic(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic value) {
        semantic_ = value.getNumber();
        bitField0_ |= 0x00000008;
      }
      /**
       * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
       */
      private void clearSemantic() {
        bitField0_ = (bitField0_ & ~0x00000008);
        semantic_ = 0;
      }

      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input);
      }
      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
            DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return (Builder) DEFAULT_INSTANCE.createBuilder();
      }
      public static Builder newBuilder(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation prototype) {
        return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
      }

      /**
       * Protobuf type {@code google.protobuf.GeneratedCodeInfo.Annotation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation, Builder> implements
          // @@protoc_insertion_point(builder_implements:google.protobuf.GeneratedCodeInfo.Annotation)
          com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.AnnotationOrBuilder {
        // Construct using com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return A list containing the path.
         */
        @java.lang.Override
        public java.util.List<java.lang.Integer>
            getPathList() {
          return java.util.Collections.unmodifiableList(
              instance.getPathList());
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return The count of path.
         */
        @java.lang.Override
        public int getPathCount() {
          return instance.getPathCount();
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param index The index of the element to return.
         * @return The path at the given index.
         */
        @java.lang.Override
        public int getPath(int index) {
          return instance.getPath(index);
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param value The path to set.
         * @return This builder for chaining.
         */
        public Builder setPath(
            int index, int value) {
          copyOnWrite();
          instance.setPath(index, value);
          return this;
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param value The path to add.
         * @return This builder for chaining.
         */
        public Builder addPath(int value) {
          copyOnWrite();
          instance.addPath(value);
          return this;
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @param values The path to add.
         * @return This builder for chaining.
         */
        public Builder addAllPath(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          copyOnWrite();
          instance.addAllPath(values);
          return this;
        }
        /**
         * <pre>
         * Identifies the element in the original source .proto file. This field
         * is formatted the same as SourceCodeInfo.Location.path.
         * </pre>
         *
         * <code>repeated int32 path = 1 [packed = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearPath() {
          copyOnWrite();
          instance.clearPath();
          return this;
        }

        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @return Whether the sourceFile field is set.
         */
        @java.lang.Override
        public boolean hasSourceFile() {
          return instance.hasSourceFile();
        }
        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @return The sourceFile.
         */
        @java.lang.Override
        public java.lang.String getSourceFile() {
          return instance.getSourceFile();
        }
        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @return The bytes for sourceFile.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getSourceFileBytes() {
          return instance.getSourceFileBytes();
        }
        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @param value The sourceFile to set.
         * @return This builder for chaining.
         */
        public Builder setSourceFile(
            java.lang.String value) {
          copyOnWrite();
          instance.setSourceFile(value);
          return this;
        }
        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearSourceFile() {
          copyOnWrite();
          instance.clearSourceFile();
          return this;
        }
        /**
         * <pre>
         * Identifies the filesystem path to the original source .proto.
         * </pre>
         *
         * <code>optional string source_file = 2;</code>
         * @param value The bytes for sourceFile to set.
         * @return This builder for chaining.
         */
        public Builder setSourceFileBytes(
            com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setSourceFileBytes(value);
          return this;
        }

        /**
         * <pre>
         * Identifies the starting offset in bytes in the generated code
         * that relates to the identified object.
         * </pre>
         *
         * <code>optional int32 begin = 3;</code>
         * @return Whether the begin field is set.
         */
        @java.lang.Override
        public boolean hasBegin() {
          return instance.hasBegin();
        }
        /**
         * <pre>
         * Identifies the starting offset in bytes in the generated code
         * that relates to the identified object.
         * </pre>
         *
         * <code>optional int32 begin = 3;</code>
         * @return The begin.
         */
        @java.lang.Override
        public int getBegin() {
          return instance.getBegin();
        }
        /**
         * <pre>
         * Identifies the starting offset in bytes in the generated code
         * that relates to the identified object.
         * </pre>
         *
         * <code>optional int32 begin = 3;</code>
         * @param value The begin to set.
         * @return This builder for chaining.
         */
        public Builder setBegin(int value) {
          copyOnWrite();
          instance.setBegin(value);
          return this;
        }
        /**
         * <pre>
         * Identifies the starting offset in bytes in the generated code
         * that relates to the identified object.
         * </pre>
         *
         * <code>optional int32 begin = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearBegin() {
          copyOnWrite();
          instance.clearBegin();
          return this;
        }

        /**
         * <pre>
         * Identifies the ending offset in bytes in the generated code that
         * relates to the identified object. The end offset should be one past
         * the last relevant byte (so the length of the text = end - begin).
         * </pre>
         *
         * <code>optional int32 end = 4;</code>
         * @return Whether the end field is set.
         */
        @java.lang.Override
        public boolean hasEnd() {
          return instance.hasEnd();
        }
        /**
         * <pre>
         * Identifies the ending offset in bytes in the generated code that
         * relates to the identified object. The end offset should be one past
         * the last relevant byte (so the length of the text = end - begin).
         * </pre>
         *
         * <code>optional int32 end = 4;</code>
         * @return The end.
         */
        @java.lang.Override
        public int getEnd() {
          return instance.getEnd();
        }
        /**
         * <pre>
         * Identifies the ending offset in bytes in the generated code that
         * relates to the identified object. The end offset should be one past
         * the last relevant byte (so the length of the text = end - begin).
         * </pre>
         *
         * <code>optional int32 end = 4;</code>
         * @param value The end to set.
         * @return This builder for chaining.
         */
        public Builder setEnd(int value) {
          copyOnWrite();
          instance.setEnd(value);
          return this;
        }
        /**
         * <pre>
         * Identifies the ending offset in bytes in the generated code that
         * relates to the identified object. The end offset should be one past
         * the last relevant byte (so the length of the text = end - begin).
         * </pre>
         *
         * <code>optional int32 end = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnd() {
          copyOnWrite();
          instance.clearEnd();
          return this;
        }

        /**
         * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
         * @return Whether the semantic field is set.
         */
        @java.lang.Override
        public boolean hasSemantic() {
          return instance.hasSemantic();
        }
        /**
         * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
         * @return The semantic.
         */
        @java.lang.Override
        public com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic getSemantic() {
          return instance.getSemantic();
        }
        /**
         * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
         * @param value The enum numeric value on the wire for semantic to set.
         * @return This builder for chaining.
         */
        public Builder setSemantic(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic value) {
          copyOnWrite();
          instance.setSemantic(value);
          return this;
        }
        /**
         * <code>optional .google.protobuf.GeneratedCodeInfo.Annotation.Semantic semantic = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearSemantic() {
          copyOnWrite();
          instance.clearSemantic();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:google.protobuf.GeneratedCodeInfo.Annotation)
      }
      @java.lang.Override
      @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
      protected final java.lang.Object dynamicMethod(
          com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
          java.lang.Object arg0, java.lang.Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation();
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case BUILD_MESSAGE_INFO: {
              java.lang.Object[] objects = new java.lang.Object[] {
                "bitField0_",
                "path_",
                "sourceFile_",
                "begin_",
                "end_",
                "semantic_",
                com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Semantic.internalGetVerifier(),
              };
              java.lang.String info =
                  "\u0001\u0005\u0000\u0001\u0001\u0005\u0005\u0000\u0001\u0000\u0001\'\u0002\u1008" +
                  "\u0000\u0003\u1004\u0001\u0004\u1004\u0002\u0005\u100c\u0003";
              return newMessageInfo(DEFAULT_INSTANCE, info, objects);
          }
          // fall through
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> parser = PARSER;
            if (parser == null) {
              synchronized (com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.class) {
                parser = PARSER;
                if (parser == null) {
                  parser =
                      new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation>(
                          DEFAULT_INSTANCE);
                  PARSER = parser;
                }
              }
            }
            return parser;
        }
        case GET_MEMOIZED_IS_INITIALIZED: {
          return (byte) 1;
        }
        case SET_MEMOIZED_IS_INITIALIZED: {
          return null;
        }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:google.protobuf.GeneratedCodeInfo.Annotation)
      private static final com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation DEFAULT_INSTANCE;
      static {
        Annotation defaultInstance = new Annotation();
        // New instances are implicitly immutable so no need to make
        // immutable.
        DEFAULT_INSTANCE = defaultInstance;
        com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
          Annotation.class, defaultInstance);
      }

      public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Annotation> PARSER;

      public static com.google.protobuf.Parser<Annotation> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int ANNOTATION_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> annotation_;
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> getAnnotationList() {
      return annotation_;
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    public java.util.List<? extends com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.AnnotationOrBuilder> 
        getAnnotationOrBuilderList() {
      return annotation_;
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    @java.lang.Override
    public int getAnnotationCount() {
      return annotation_.size();
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    @java.lang.Override
    public com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation getAnnotation(int index) {
      return annotation_.get(index);
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    public com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.AnnotationOrBuilder getAnnotationOrBuilder(
        int index) {
      return annotation_.get(index);
    }
    private void ensureAnnotationIsMutable() {
      com.google.protobuf.Internal.ProtobufList<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> tmp = annotation_;
      if (!tmp.isModifiable()) {
        annotation_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void setAnnotation(
        int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
      value.getClass();
  ensureAnnotationIsMutable();
      annotation_.set(index, value);
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void addAnnotation(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
      value.getClass();
  ensureAnnotationIsMutable();
      annotation_.add(value);
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void addAnnotation(
        int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
      value.getClass();
  ensureAnnotationIsMutable();
      annotation_.add(index, value);
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void addAllAnnotation(
        java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> values) {
      ensureAnnotationIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, annotation_);
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void clearAnnotation() {
      annotation_ = emptyProtobufList();
    }
    /**
     * <pre>
     * An Annotation connects some span of text in generated code to an element
     * of its generating .proto file.
     * </pre>
     *
     * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
     */
    private void removeAnnotation(int index) {
      ensureAnnotationIsMutable();
      annotation_.remove(index);
    }

    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Describes the relationship between generated code and its original source
     * file. A GeneratedCodeInfo message is associated with only one generated
     * source file, but may contain references to different source .proto files.
     * </pre>
     *
     * Protobuf type {@code google.protobuf.GeneratedCodeInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.protobuf.DescriptorProtos.GeneratedCodeInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.protobuf.GeneratedCodeInfo)
        com.google.protobuf.DescriptorProtos.GeneratedCodeInfoOrBuilder {
      // Construct using com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      @java.lang.Override
      public java.util.List<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> getAnnotationList() {
        return java.util.Collections.unmodifiableList(
            instance.getAnnotationList());
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      @java.lang.Override
      public int getAnnotationCount() {
        return instance.getAnnotationCount();
      }/**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      @java.lang.Override
      public com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation getAnnotation(int index) {
        return instance.getAnnotation(index);
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder setAnnotation(
          int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
        copyOnWrite();
        instance.setAnnotation(index, value);
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder setAnnotation(
          int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Builder builderForValue) {
        copyOnWrite();
        instance.setAnnotation(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder addAnnotation(com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
        copyOnWrite();
        instance.addAnnotation(value);
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder addAnnotation(
          int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation value) {
        copyOnWrite();
        instance.addAnnotation(index, value);
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder addAnnotation(
          com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Builder builderForValue) {
        copyOnWrite();
        instance.addAnnotation(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder addAnnotation(
          int index, com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.Builder builderForValue) {
        copyOnWrite();
        instance.addAnnotation(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder addAllAnnotation(
          java.lang.Iterable<? extends com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation> values) {
        copyOnWrite();
        instance.addAllAnnotation(values);
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder clearAnnotation() {
        copyOnWrite();
        instance.clearAnnotation();
        return this;
      }
      /**
       * <pre>
       * An Annotation connects some span of text in generated code to an element
       * of its generating .proto file.
       * </pre>
       *
       * <code>repeated .google.protobuf.GeneratedCodeInfo.Annotation annotation = 1;</code>
       */
      public Builder removeAnnotation(int index) {
        copyOnWrite();
        instance.removeAnnotation(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.protobuf.GeneratedCodeInfo)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.protobuf.DescriptorProtos.GeneratedCodeInfo();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "annotation_",
              com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.Annotation.class,
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0000\u0001\u0001\u0001\u0000\u0001\u0000\u0001\u001b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.protobuf.DescriptorProtos.GeneratedCodeInfo.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<com.google.protobuf.DescriptorProtos.GeneratedCodeInfo>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.protobuf.GeneratedCodeInfo)
    private static final com.google.protobuf.DescriptorProtos.GeneratedCodeInfo DEFAULT_INSTANCE;
    static {
      GeneratedCodeInfo defaultInstance = new GeneratedCodeInfo();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        GeneratedCodeInfo.class, defaultInstance);
    }

    public static com.google.protobuf.DescriptorProtos.GeneratedCodeInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<GeneratedCodeInfo> PARSER;

    public static com.google.protobuf.Parser<GeneratedCodeInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
